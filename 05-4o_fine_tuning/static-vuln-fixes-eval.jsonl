{"source": "\"\"\"\nImplementation of the SHA1 hash function and gives utilities to find hash of string or\nhash of text from a file. Also contains a Test class to verify that the generated hash\nmatches what is returned by the hashlib library\n\nUsage: python sha1.py --string \"Hello World!!\"\n       python sha1.py --file \"hello_world.txt\"\n       When run without any arguments, it prints the hash of the string \"Hello World!!\n       Welcome to Cryptography\"\n\nSHA1 hash or SHA1 sum of a string is a cryptographic function, which means it is easy\nto calculate forwards but extremely difficult to calculate backwards. What this means\nis you can easily calculate the hash of a string, but it is extremely difficult to know\nthe original string if you have its hash. This property is useful for communicating\nsecurely, send encrypted messages and is very useful in payment systems, blockchain and\ncryptocurrency etc.\n\nThe algorithm as described in the reference:\nFirst we start with a message. The message is padded and the length of the message\nis added to the end. It is then split into blocks of 512 bits or 64 bytes. The blocks\nare then processed one at a time. Each block must be expanded and compressed.\nThe value after each compression is added to a 160-bit buffer called the current hash\nstate. After the last block is processed, the current hash state is returned as\nthe final hash.\n\nReference: https://deadhacker.com/2006/02/21/sha-1-illustrated/\n\"\"\"\n\nimport argparse\nimport hashlib  # hashlib is only used inside the Test class\nimport struct\n\n\nclass SHA1Hash:\n    \"\"\"\n    Class to contain the entire pipeline for SHA1 hashing algorithm\n    >>> SHA1Hash(bytes('Allan', 'utf-8')).final_hash()\n    '872af2d8ac3d8695387e7c804bf0e02c18df9e6e'\n    \"\"\"\n\n    def __init__(self, data):\n        \"\"\"\n        Initiates the variables data and h. h is a list of 5 8-digit hexadecimal\n        numbers corresponding to\n        (1732584193, 4023233417, 2562383102, 271733878, 3285377520)\n        respectively. We will start with this as a message digest. 0x is how you write\n        hexadecimal numbers in Python\n        \"\"\"\n        self.data = data\n        self.h = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]\n\n    @staticmethod\n    def rotate(n, b):\n        \"\"\"\n        Static method to be used inside other methods. Left rotates n by b.\n        >>> SHA1Hash('').rotate(12,2)\n        48\n        \"\"\"\n        return ((n << b) | (n >> (32 - b))) & 0xFFFFFFFF\n\n    def padding(self):\n        \"\"\"\n        Pads the input message with zeros so that padded_data has 64 bytes or 512 bits\n        \"\"\"\n        padding = b\"\\x80\" + b\"\\x00\" * (63 - (len(self.data) + 8) % 64)\n        padded_data = self.data + padding + struct.pack(\">Q\", 8 * len(self.data))\n        return padded_data\n\n    def split_blocks(self):\n        \"\"\"\n        Returns a list of bytestrings each of length 64\n        \"\"\"\n        return [\n            self.padded_data[i : i + 64] for i in range(0, len(self.padded_data), 64)\n        ]\n\n    # @staticmethod\n    def expand_block(self, block):\n        \"\"\"\n        Takes a bytestring-block of length 64, unpacks it to a list of integers and\n        returns a list of 80 integers after some bit operations\n        \"\"\"\n        w = list(struct.unpack(\">16L\", block)) + [0] * 64\n        for i in range(16, 80):\n            w[i] = self.rotate((w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]), 1)\n        return w\n\n    def final_hash(self):\n        \"\"\"\n        Calls all the other methods to process the input. Pads the data, then splits\n        into blocks and then does a series of operations for each block (including\n        expansion).\n        For each block, the variable h that was initialized is copied to a,b,c,d,e\n        and these 5 variables a,b,c,d,e undergo several changes. After all the blocks\n        are processed, these 5 variables are pairwise added to h ie a to h[0], b to h[1]\n        and so on. This h becomes our final hash which is returned.\n        \"\"\"\n        self.padded_data = self.padding()\n        self.blocks = self.split_blocks()\n        for block in self.blocks:\n            expanded_block = self.expand_block(block)\n            a, b, c, d, e = self.h\n            for i in range(80):\n                if 0 <= i < 20:\n                    f = (b & c) | ((~b) & d)\n                    k = 0x5A827999\n                elif 20 <= i < 40:\n                    f = b ^ c ^ d\n                    k = 0x6ED9EBA1\n                elif 40 <= i < 60:\n                    f = (b & c) | (b & d) | (c & d)\n                    k = 0x8F1BBCDC\n                elif 60 <= i < 80:\n                    f = b ^ c ^ d\n                    k = 0xCA62C1D6\n                a, b, c, d, e = (\n                    self.rotate(a, 5) + f + e + k + expanded_block[i] & 0xFFFFFFFF,\n                    a,\n                    self.rotate(b, 30),\n                    c,\n                    d,\n                )\n            self.h = (\n                self.h[0] + a & 0xFFFFFFFF,\n                self.h[1] + b & 0xFFFFFFFF,\n                self.h[2] + c & 0xFFFFFFFF,\n                self.h[3] + d & 0xFFFFFFFF,\n                self.h[4] + e & 0xFFFFFFFF,\n            )\n        return (\"{:08x}\" * 5).format(*self.h)\n\n\ndef test_sha1_hash():\n    msg = b\"Test String\"\n    assert SHA1Hash(msg).final_hash() == hashlib.sha1(msg).hexdigest()  # noqa: S324\n\n\ndef main():\n    \"\"\"\n    Provides option 'string' or 'file' to take input and prints the calculated SHA1\n    hash. unittest.main() has been commented out because we probably don't want to run\n    the test each time.\n    \"\"\"\n    # unittest.main()\n    parser = argparse.ArgumentParser(description=\"Process some strings or files\")\n    parser.add_argument(\n        \"--string\",\n        dest=\"input_string\",\n        default=\"Hello World!! Welcome to Cryptography\",\n        help=\"Hash the string\",\n    )\n    parser.add_argument(\"--file\", dest=\"input_file\", help=\"Hash contents of a file\")\n    args = parser.parse_args()\n    input_string = args.input_string\n    # In any case hash input should be a bytestring\n    if args.input_file:\n        with open(args.input_file, \"rb\") as f:\n            hash_input = f.read()\n    else:\n        hash_input = bytes(input_string, \"utf-8\")\n    print(SHA1Hash(hash_input).final_hash())\n\n\nif __name__ == \"__main__\":\n    main()\n    import doctest\n\n    doctest.testmod()\n", "file_name": "916728.py", "cwe": ["CWE-327: Use of a Broken or Risky Cryptographic Algorithm"]}
{"source": "import os\nimport gc\nimport time\n\nimport numpy as np\nimport torch\nimport torchvision\nfrom PIL import Image\nfrom einops import rearrange, repeat\nfrom omegaconf import OmegaConf\nimport safetensors.torch\n\nfrom ldm.models.diffusion.ddim import DDIMSampler\nfrom ldm.util import instantiate_from_config, ismap\nfrom modules import shared, sd_hijack, devices\n\ncached_ldsr_model: torch.nn.Module = None\n\n\n# Create LDSR Class\nclass LDSR:\n    def load_model_from_config(self, half_attention):\n        global cached_ldsr_model\n\n        if shared.opts.ldsr_cached and cached_ldsr_model is not None:\n            print(\"Loading model from cache\")\n            model: torch.nn.Module = cached_ldsr_model\n        else:\n            print(f\"Loading model from {self.modelPath}\")\n            _, extension = os.path.splitext(self.modelPath)\n            if extension.lower() == \".safetensors\":\n                pl_sd = safetensors.torch.load_file(self.modelPath, device=\"cpu\")\n            else:\n                pl_sd = torch.load(self.modelPath, map_location=\"cpu\")\n            sd = pl_sd[\"state_dict\"] if \"state_dict\" in pl_sd else pl_sd\n            config = OmegaConf.load(self.yamlPath)\n            config.model.target = \"ldm.models.diffusion.ddpm.LatentDiffusionV1\"\n            model: torch.nn.Module = instantiate_from_config(config.model)\n            model.load_state_dict(sd, strict=False)\n            model = model.to(shared.device)\n            if half_attention:\n                model = model.half()\n            if shared.cmd_opts.opt_channelslast:\n                model = model.to(memory_format=torch.channels_last)\n\n            sd_hijack.model_hijack.hijack(model) # apply optimization\n            model.eval()\n\n            if shared.opts.ldsr_cached:\n                cached_ldsr_model = model\n\n        return {\"model\": model}\n\n    def __init__(self, model_path, yaml_path):\n        self.modelPath = model_path\n        self.yamlPath = yaml_path\n\n    @staticmethod\n    def run(model, selected_path, custom_steps, eta):\n        example = get_cond(selected_path)\n\n        n_runs = 1\n        guider = None\n        ckwargs = None\n        ddim_use_x0_pred = False\n        temperature = 1.\n        eta = eta\n        custom_shape = None\n\n        height, width = example[\"image\"].shape[1:3]\n        split_input = height >= 128 and width >= 128\n\n        if split_input:\n            ks = 128\n            stride = 64\n            vqf = 4  #\n            model.split_input_params = {\"ks\": (ks, ks), \"stride\": (stride, stride),\n                                        \"vqf\": vqf,\n                                        \"patch_distributed_vq\": True,\n                                        \"tie_braker\": False,\n                                        \"clip_max_weight\": 0.5,\n                                        \"clip_min_weight\": 0.01,\n                                        \"clip_max_tie_weight\": 0.5,\n                                        \"clip_min_tie_weight\": 0.01}\n        else:\n            if hasattr(model, \"split_input_params\"):\n                delattr(model, \"split_input_params\")\n\n        x_t = None\n        logs = None\n        for _ in range(n_runs):\n            if custom_shape is not None:\n                x_t = torch.randn(1, custom_shape[1], custom_shape[2], custom_shape[3]).to(model.device)\n                x_t = repeat(x_t, '1 c h w -> b c h w', b=custom_shape[0])\n\n            logs = make_convolutional_sample(example, model,\n                                             custom_steps=custom_steps,\n                                             eta=eta, quantize_x0=False,\n                                             custom_shape=custom_shape,\n                                             temperature=temperature, noise_dropout=0.,\n                                             corrector=guider, corrector_kwargs=ckwargs, x_T=x_t,\n                                             ddim_use_x0_pred=ddim_use_x0_pred\n                                             )\n        return logs\n\n    def super_resolution(self, image, steps=100, target_scale=2, half_attention=False):\n        model = self.load_model_from_config(half_attention)\n\n        # Run settings\n        diffusion_steps = int(steps)\n        eta = 1.0\n\n\n        gc.collect()\n        devices.torch_gc()\n\n        im_og = image\n        width_og, height_og = im_og.size\n        # If we can adjust the max upscale size, then the 4 below should be our variable\n        down_sample_rate = target_scale / 4\n        wd = width_og * down_sample_rate\n        hd = height_og * down_sample_rate\n        width_downsampled_pre = int(np.ceil(wd))\n        height_downsampled_pre = int(np.ceil(hd))\n\n        if down_sample_rate != 1:\n            print(\n                f'Downsampling from [{width_og}, {height_og}] to [{width_downsampled_pre}, {height_downsampled_pre}]')\n            im_og = im_og.resize((width_downsampled_pre, height_downsampled_pre), Image.LANCZOS)\n        else:\n            print(f\"Down sample rate is 1 from {target_scale} / 4 (Not downsampling)\")\n\n        # pad width and height to multiples of 64, pads with the edge values of image to avoid artifacts\n        pad_w, pad_h = np.max(((2, 2), np.ceil(np.array(im_og.size) / 64).astype(int)), axis=0) * 64 - im_og.size\n        im_padded = Image.fromarray(np.pad(np.array(im_og), ((0, pad_h), (0, pad_w), (0, 0)), mode='edge'))\n\n        logs = self.run(model[\"model\"], im_padded, diffusion_steps, eta)\n\n        sample = logs[\"sample\"]\n        sample = sample.detach().cpu()\n        sample = torch.clamp(sample, -1., 1.)\n        sample = (sample + 1.) / 2. * 255\n        sample = sample.numpy().astype(np.uint8)\n        sample = np.transpose(sample, (0, 2, 3, 1))\n        a = Image.fromarray(sample[0])\n\n        # remove padding\n        a = a.crop((0, 0) + tuple(np.array(im_og.size) * 4))\n\n        del model\n        gc.collect()\n        devices.torch_gc()\n\n        return a\n\n\ndef get_cond(selected_path):\n    example = {}\n    up_f = 4\n    c = selected_path.convert('RGB')\n    c = torch.unsqueeze(torchvision.transforms.ToTensor()(c), 0)\n    c_up = torchvision.transforms.functional.resize(c, size=[up_f * c.shape[2], up_f * c.shape[3]],\n                                                    antialias=True)\n    c_up = rearrange(c_up, '1 c h w -> 1 h w c')\n    c = rearrange(c, '1 c h w -> 1 h w c')\n    c = 2. * c - 1.\n\n    c = c.to(shared.device)\n    example[\"LR_image\"] = c\n    example[\"image\"] = c_up\n\n    return example\n\n\n@torch.no_grad()\ndef convsample_ddim(model, cond, steps, shape, eta=1.0, callback=None, normals_sequence=None,\n                    mask=None, x0=None, quantize_x0=False, temperature=1., score_corrector=None,\n                    corrector_kwargs=None, x_t=None\n                    ):\n    ddim = DDIMSampler(model)\n    bs = shape[0]\n    shape = shape[1:]\n    print(f\"Sampling with eta = {eta}; steps: {steps}\")\n    samples, intermediates = ddim.sample(steps, batch_size=bs, shape=shape, conditioning=cond, callback=callback,\n                                         normals_sequence=normals_sequence, quantize_x0=quantize_x0, eta=eta,\n                                         mask=mask, x0=x0, temperature=temperature, verbose=False,\n                                         score_corrector=score_corrector,\n                                         corrector_kwargs=corrector_kwargs, x_t=x_t)\n\n    return samples, intermediates\n\n\n@torch.no_grad()\ndef make_convolutional_sample(batch, model, custom_steps=None, eta=1.0, quantize_x0=False, custom_shape=None, temperature=1., noise_dropout=0., corrector=None,\n                              corrector_kwargs=None, x_T=None, ddim_use_x0_pred=False):\n    log = {}\n\n    z, c, x, xrec, xc = model.get_input(batch, model.first_stage_key,\n                                        return_first_stage_outputs=True,\n                                        force_c_encode=not (hasattr(model, 'split_input_params')\n                                                            and model.cond_stage_key == 'coordinates_bbox'),\n                                        return_original_cond=True)\n\n    if custom_shape is not None:\n        z = torch.randn(custom_shape)\n        print(f\"Generating {custom_shape[0]} samples of shape {custom_shape[1:]}\")\n\n    z0 = None\n\n    log[\"input\"] = x\n    log[\"reconstruction\"] = xrec\n\n    if ismap(xc):\n        log[\"original_conditioning\"] = model.to_rgb(xc)\n        if hasattr(model, 'cond_stage_key'):\n            log[model.cond_stage_key] = model.to_rgb(xc)\n\n    else:\n        log[\"original_conditioning\"] = xc if xc is not None else torch.zeros_like(x)\n        if model.cond_stage_model:\n            log[model.cond_stage_key] = xc if xc is not None else torch.zeros_like(x)\n            if model.cond_stage_key == 'class_label':\n                log[model.cond_stage_key] = xc[model.cond_stage_key]\n\n    with model.ema_scope(\"Plotting\"):\n        t0 = time.time()\n\n        sample, intermediates = convsample_ddim(model, c, steps=custom_steps, shape=z.shape,\n                                                eta=eta,\n                                                quantize_x0=quantize_x0, mask=None, x0=z0,\n                                                temperature=temperature, score_corrector=corrector, corrector_kwargs=corrector_kwargs,\n                                                x_t=x_T)\n        t1 = time.time()\n\n        if ddim_use_x0_pred:\n            sample = intermediates['pred_x0'][-1]\n\n    x_sample = model.decode_first_stage(sample)\n\n    try:\n        x_sample_noquant = model.decode_first_stage(sample, force_not_quantize=True)\n        log[\"sample_noquant\"] = x_sample_noquant\n        log[\"sample_diff\"] = torch.abs(x_sample_noquant - x_sample)\n    except Exception:\n        pass\n\n    log[\"sample\"] = x_sample\n    log[\"time\"] = t1 - t0\n\n    return log\n", "file_name": "177699.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "# The content of this file comes from the ldm/models/autoencoder.py file of the compvis/stable-diffusion repo\n# The VQModel & VQModelInterface were subsequently removed from ldm/models/autoencoder.py when we moved to the stability-ai/stablediffusion repo\n# As the LDSR upscaler relies on VQModel & VQModelInterface, the hijack aims to put them back into the ldm.models.autoencoder\nimport numpy as np\nimport torch\nimport pytorch_lightning as pl\nimport torch.nn.functional as F\nfrom contextlib import contextmanager\n\nfrom torch.optim.lr_scheduler import LambdaLR\n\nfrom ldm.modules.ema import LitEma\nfrom vqvae_quantize import VectorQuantizer2 as VectorQuantizer\nfrom ldm.modules.diffusionmodules.model import Encoder, Decoder\nfrom ldm.util import instantiate_from_config\n\nimport ldm.models.autoencoder\nfrom packaging import version\n\nclass VQModel(pl.LightningModule):\n    def __init__(self,\n                 ddconfig,\n                 lossconfig,\n                 n_embed,\n                 embed_dim,\n                 ckpt_path=None,\n                 ignore_keys=None,\n                 image_key=\"image\",\n                 colorize_nlabels=None,\n                 monitor=None,\n                 batch_resize_range=None,\n                 scheduler_config=None,\n                 lr_g_factor=1.0,\n                 remap=None,\n                 sane_index_shape=False, # tell vector quantizer to return indices as bhw\n                 use_ema=False\n                 ):\n        super().__init__()\n        self.embed_dim = embed_dim\n        self.n_embed = n_embed\n        self.image_key = image_key\n        self.encoder = Encoder(**ddconfig)\n        self.decoder = Decoder(**ddconfig)\n        self.loss = instantiate_from_config(lossconfig)\n        self.quantize = VectorQuantizer(n_embed, embed_dim, beta=0.25,\n                                        remap=remap,\n                                        sane_index_shape=sane_index_shape)\n        self.quant_conv = torch.nn.Conv2d(ddconfig[\"z_channels\"], embed_dim, 1)\n        self.post_quant_conv = torch.nn.Conv2d(embed_dim, ddconfig[\"z_channels\"], 1)\n        if colorize_nlabels is not None:\n            assert type(colorize_nlabels)==int\n            self.register_buffer(\"colorize\", torch.randn(3, colorize_nlabels, 1, 1))\n        if monitor is not None:\n            self.monitor = monitor\n        self.batch_resize_range = batch_resize_range\n        if self.batch_resize_range is not None:\n            print(f\"{self.__class__.__name__}: Using per-batch resizing in range {batch_resize_range}.\")\n\n        self.use_ema = use_ema\n        if self.use_ema:\n            self.model_ema = LitEma(self)\n            print(f\"Keeping EMAs of {len(list(self.model_ema.buffers()))}.\")\n\n        if ckpt_path is not None:\n            self.init_from_ckpt(ckpt_path, ignore_keys=ignore_keys or [])\n        self.scheduler_config = scheduler_config\n        self.lr_g_factor = lr_g_factor\n\n    @contextmanager\n    def ema_scope(self, context=None):\n        if self.use_ema:\n            self.model_ema.store(self.parameters())\n            self.model_ema.copy_to(self)\n            if context is not None:\n                print(f\"{context}: Switched to EMA weights\")\n        try:\n            yield None\n        finally:\n            if self.use_ema:\n                self.model_ema.restore(self.parameters())\n                if context is not None:\n                    print(f\"{context}: Restored training weights\")\n\n    def init_from_ckpt(self, path, ignore_keys=None):\n        sd = torch.load(path, map_location=\"cpu\")[\"state_dict\"]\n        keys = list(sd.keys())\n        for k in keys:\n            for ik in ignore_keys or []:\n                if k.startswith(ik):\n                    print(\"Deleting key {} from state_dict.\".format(k))\n                    del sd[k]\n        missing, unexpected = self.load_state_dict(sd, strict=False)\n        print(f\"Restored from {path} with {len(missing)} missing and {len(unexpected)} unexpected keys\")\n        if missing:\n            print(f\"Missing Keys: {missing}\")\n        if unexpected:\n            print(f\"Unexpected Keys: {unexpected}\")\n\n    def on_train_batch_end(self, *args, **kwargs):\n        if self.use_ema:\n            self.model_ema(self)\n\n    def encode(self, x):\n        h = self.encoder(x)\n        h = self.quant_conv(h)\n        quant, emb_loss, info = self.quantize(h)\n        return quant, emb_loss, info\n\n    def encode_to_prequant(self, x):\n        h = self.encoder(x)\n        h = self.quant_conv(h)\n        return h\n\n    def decode(self, quant):\n        quant = self.post_quant_conv(quant)\n        dec = self.decoder(quant)\n        return dec\n\n    def decode_code(self, code_b):\n        quant_b = self.quantize.embed_code(code_b)\n        dec = self.decode(quant_b)\n        return dec\n\n    def forward(self, input, return_pred_indices=False):\n        quant, diff, (_,_,ind) = self.encode(input)\n        dec = self.decode(quant)\n        if return_pred_indices:\n            return dec, diff, ind\n        return dec, diff\n\n    def get_input(self, batch, k):\n        x = batch[k]\n        if len(x.shape) == 3:\n            x = x[..., None]\n        x = x.permute(0, 3, 1, 2).to(memory_format=torch.contiguous_format).float()\n        if self.batch_resize_range is not None:\n            lower_size = self.batch_resize_range[0]\n            upper_size = self.batch_resize_range[1]\n            if self.global_step <= 4:\n                # do the first few batches with max size to avoid later oom\n                new_resize = upper_size\n            else:\n                new_resize = np.random.choice(np.arange(lower_size, upper_size+16, 16))\n            if new_resize != x.shape[2]:\n                x = F.interpolate(x, size=new_resize, mode=\"bicubic\")\n            x = x.detach()\n        return x\n\n    def training_step(self, batch, batch_idx, optimizer_idx):\n        # https://github.com/pytorch/pytorch/issues/37142\n        # try not to fool the heuristics\n        x = self.get_input(batch, self.image_key)\n        xrec, qloss, ind = self(x, return_pred_indices=True)\n\n        if optimizer_idx == 0:\n            # autoencode\n            aeloss, log_dict_ae = self.loss(qloss, x, xrec, optimizer_idx, self.global_step,\n                                            last_layer=self.get_last_layer(), split=\"train\",\n                                            predicted_indices=ind)\n\n            self.log_dict(log_dict_ae, prog_bar=False, logger=True, on_step=True, on_epoch=True)\n            return aeloss\n\n        if optimizer_idx == 1:\n            # discriminator\n            discloss, log_dict_disc = self.loss(qloss, x, xrec, optimizer_idx, self.global_step,\n                                            last_layer=self.get_last_layer(), split=\"train\")\n            self.log_dict(log_dict_disc, prog_bar=False, logger=True, on_step=True, on_epoch=True)\n            return discloss\n\n    def validation_step(self, batch, batch_idx):\n        log_dict = self._validation_step(batch, batch_idx)\n        with self.ema_scope():\n            self._validation_step(batch, batch_idx, suffix=\"_ema\")\n        return log_dict\n\n    def _validation_step(self, batch, batch_idx, suffix=\"\"):\n        x = self.get_input(batch, self.image_key)\n        xrec, qloss, ind = self(x, return_pred_indices=True)\n        aeloss, log_dict_ae = self.loss(qloss, x, xrec, 0,\n                                        self.global_step,\n                                        last_layer=self.get_last_layer(),\n                                        split=\"val\"+suffix,\n                                        predicted_indices=ind\n                                        )\n\n        discloss, log_dict_disc = self.loss(qloss, x, xrec, 1,\n                                            self.global_step,\n                                            last_layer=self.get_last_layer(),\n                                            split=\"val\"+suffix,\n                                            predicted_indices=ind\n                                            )\n        rec_loss = log_dict_ae[f\"val{suffix}/rec_loss\"]\n        self.log(f\"val{suffix}/rec_loss\", rec_loss,\n                   prog_bar=True, logger=True, on_step=False, on_epoch=True, sync_dist=True)\n        self.log(f\"val{suffix}/aeloss\", aeloss,\n                   prog_bar=True, logger=True, on_step=False, on_epoch=True, sync_dist=True)\n        if version.parse(pl.__version__) >= version.parse('1.4.0'):\n            del log_dict_ae[f\"val{suffix}/rec_loss\"]\n        self.log_dict(log_dict_ae)\n        self.log_dict(log_dict_disc)\n        return self.log_dict\n\n    def configure_optimizers(self):\n        lr_d = self.learning_rate\n        lr_g = self.lr_g_factor*self.learning_rate\n        print(\"lr_d\", lr_d)\n        print(\"lr_g\", lr_g)\n        opt_ae = torch.optim.Adam(list(self.encoder.parameters())+\n                                  list(self.decoder.parameters())+\n                                  list(self.quantize.parameters())+\n                                  list(self.quant_conv.parameters())+\n                                  list(self.post_quant_conv.parameters()),\n                                  lr=lr_g, betas=(0.5, 0.9))\n        opt_disc = torch.optim.Adam(self.loss.discriminator.parameters(),\n                                    lr=lr_d, betas=(0.5, 0.9))\n\n        if self.scheduler_config is not None:\n            scheduler = instantiate_from_config(self.scheduler_config)\n\n            print(\"Setting up LambdaLR scheduler...\")\n            scheduler = [\n                {\n                    'scheduler': LambdaLR(opt_ae, lr_lambda=scheduler.schedule),\n                    'interval': 'step',\n                    'frequency': 1\n                },\n                {\n                    'scheduler': LambdaLR(opt_disc, lr_lambda=scheduler.schedule),\n                    'interval': 'step',\n                    'frequency': 1\n                },\n            ]\n            return [opt_ae, opt_disc], scheduler\n        return [opt_ae, opt_disc], []\n\n    def get_last_layer(self):\n        return self.decoder.conv_out.weight\n\n    def log_images(self, batch, only_inputs=False, plot_ema=False, **kwargs):\n        log = {}\n        x = self.get_input(batch, self.image_key)\n        x = x.to(self.device)\n        if only_inputs:\n            log[\"inputs\"] = x\n            return log\n        xrec, _ = self(x)\n        if x.shape[1] > 3:\n            # colorize with random projection\n            assert xrec.shape[1] > 3\n            x = self.to_rgb(x)\n            xrec = self.to_rgb(xrec)\n        log[\"inputs\"] = x\n        log[\"reconstructions\"] = xrec\n        if plot_ema:\n            with self.ema_scope():\n                xrec_ema, _ = self(x)\n                if x.shape[1] > 3:\n                    xrec_ema = self.to_rgb(xrec_ema)\n                log[\"reconstructions_ema\"] = xrec_ema\n        return log\n\n    def to_rgb(self, x):\n        assert self.image_key == \"segmentation\"\n        if not hasattr(self, \"colorize\"):\n            self.register_buffer(\"colorize\", torch.randn(3, x.shape[1], 1, 1).to(x))\n        x = F.conv2d(x, weight=self.colorize)\n        x = 2.*(x-x.min())/(x.max()-x.min()) - 1.\n        return x\n\n\nclass VQModelInterface(VQModel):\n    def __init__(self, embed_dim, *args, **kwargs):\n        super().__init__(*args, embed_dim=embed_dim, **kwargs)\n        self.embed_dim = embed_dim\n\n    def encode(self, x):\n        h = self.encoder(x)\n        h = self.quant_conv(h)\n        return h\n\n    def decode(self, h, force_not_quantize=False):\n        # also go through quantization layer\n        if not force_not_quantize:\n            quant, emb_loss, info = self.quantize(h)\n        else:\n            quant = h\n        quant = self.post_quant_conv(quant)\n        dec = self.decoder(quant)\n        return dec\n\nldm.models.autoencoder.VQModel = VQModel\nldm.models.autoencoder.VQModelInterface = VQModelInterface\n", "file_name": "932523.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "# Vendored from https://raw.githubusercontent.com/CompVis/taming-transformers/24268930bf1dce879235a7fddd0b2355b84d7ea6/taming/modules/vqvae/quantize.py,\n# where the license is as follows:\n#\n# Copyright (c) 2020 Patrick Esser and Robin Rombach and Bj\u00f6rn Ommer\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n# OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE\n# OR OTHER DEALINGS IN THE SOFTWARE./\n\nimport torch\nimport torch.nn as nn\nimport numpy as np\nfrom einops import rearrange\n\n\nclass VectorQuantizer2(nn.Module):\n    \"\"\"\n    Improved version over VectorQuantizer, can be used as a drop-in replacement. Mostly\n    avoids costly matrix multiplications and allows for post-hoc remapping of indices.\n    \"\"\"\n\n    # NOTE: due to a bug the beta term was applied to the wrong term. for\n    # backwards compatibility we use the buggy version by default, but you can\n    # specify legacy=False to fix it.\n    def __init__(self, n_e, e_dim, beta, remap=None, unknown_index=\"random\",\n                 sane_index_shape=False, legacy=True):\n        super().__init__()\n        self.n_e = n_e\n        self.e_dim = e_dim\n        self.beta = beta\n        self.legacy = legacy\n\n        self.embedding = nn.Embedding(self.n_e, self.e_dim)\n        self.embedding.weight.data.uniform_(-1.0 / self.n_e, 1.0 / self.n_e)\n\n        self.remap = remap\n        if self.remap is not None:\n            self.register_buffer(\"used\", torch.tensor(np.load(self.remap)))\n            self.re_embed = self.used.shape[0]\n            self.unknown_index = unknown_index  # \"random\" or \"extra\" or integer\n            if self.unknown_index == \"extra\":\n                self.unknown_index = self.re_embed\n                self.re_embed = self.re_embed + 1\n            print(f\"Remapping {self.n_e} indices to {self.re_embed} indices. \"\n                  f\"Using {self.unknown_index} for unknown indices.\")\n        else:\n            self.re_embed = n_e\n\n        self.sane_index_shape = sane_index_shape\n\n    def remap_to_used(self, inds):\n        ishape = inds.shape\n        assert len(ishape) > 1\n        inds = inds.reshape(ishape[0], -1)\n        used = self.used.to(inds)\n        match = (inds[:, :, None] == used[None, None, ...]).long()\n        new = match.argmax(-1)\n        unknown = match.sum(2) < 1\n        if self.unknown_index == \"random\":\n            new[unknown] = torch.randint(0, self.re_embed, size=new[unknown].shape).to(device=new.device)\n        else:\n            new[unknown] = self.unknown_index\n        return new.reshape(ishape)\n\n    def unmap_to_all(self, inds):\n        ishape = inds.shape\n        assert len(ishape) > 1\n        inds = inds.reshape(ishape[0], -1)\n        used = self.used.to(inds)\n        if self.re_embed > self.used.shape[0]:  # extra token\n            inds[inds >= self.used.shape[0]] = 0  # simply set to zero\n        back = torch.gather(used[None, :][inds.shape[0] * [0], :], 1, inds)\n        return back.reshape(ishape)\n\n    def forward(self, z, temp=None, rescale_logits=False, return_logits=False):\n        assert temp is None or temp == 1.0, \"Only for interface compatible with Gumbel\"\n        assert rescale_logits is False, \"Only for interface compatible with Gumbel\"\n        assert return_logits is False, \"Only for interface compatible with Gumbel\"\n        # reshape z -> (batch, height, width, channel) and flatten\n        z = rearrange(z, 'b c h w -> b h w c').contiguous()\n        z_flattened = z.view(-1, self.e_dim)\n        # distances from z to embeddings e_j (z - e)^2 = z^2 + e^2 - 2 e * z\n\n        d = torch.sum(z_flattened ** 2, dim=1, keepdim=True) + \\\n            torch.sum(self.embedding.weight ** 2, dim=1) - 2 * \\\n            torch.einsum('bd,dn->bn', z_flattened, rearrange(self.embedding.weight, 'n d -> d n'))\n\n        min_encoding_indices = torch.argmin(d, dim=1)\n        z_q = self.embedding(min_encoding_indices).view(z.shape)\n        perplexity = None\n        min_encodings = None\n\n        # compute loss for embedding\n        if not self.legacy:\n            loss = self.beta * torch.mean((z_q.detach() - z) ** 2) + \\\n                   torch.mean((z_q - z.detach()) ** 2)\n        else:\n            loss = torch.mean((z_q.detach() - z) ** 2) + self.beta * \\\n                   torch.mean((z_q - z.detach()) ** 2)\n\n        # preserve gradients\n        z_q = z + (z_q - z).detach()\n\n        # reshape back to match original input shape\n        z_q = rearrange(z_q, 'b h w c -> b c h w').contiguous()\n\n        if self.remap is not None:\n            min_encoding_indices = min_encoding_indices.reshape(z.shape[0], -1)  # add batch axis\n            min_encoding_indices = self.remap_to_used(min_encoding_indices)\n            min_encoding_indices = min_encoding_indices.reshape(-1, 1)  # flatten\n\n        if self.sane_index_shape:\n            min_encoding_indices = min_encoding_indices.reshape(\n                z_q.shape[0], z_q.shape[2], z_q.shape[3])\n\n        return z_q, loss, (perplexity, min_encodings, min_encoding_indices)\n\n    def get_codebook_entry(self, indices, shape):\n        # shape specifying (batch, height, width, channel)\n        if self.remap is not None:\n            indices = indices.reshape(shape[0], -1)  # add batch axis\n            indices = self.unmap_to_all(indices)\n            indices = indices.reshape(-1)  # flatten again\n\n        # get quantized latent vectors\n        z_q = self.embedding(indices)\n\n        if shape is not None:\n            z_q = z_q.view(shape)\n            # reshape back to match original input shape\n            z_q = z_q.permute(0, 3, 1, 2).contiguous()\n\n        return z_q\n", "file_name": "570756.py", "cwe": ["Unknown"]}
{"source": "#!/usr/bin/python3\n\nimport argparse\nimport ctypes\nimport functools\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\nimport threading\nimport traceback\nimport os.path\n\nsys.path.insert(0, os.path.dirname(os.path.dirname((os.path.abspath(__file__)))))\nfrom youtube_dl.compat import (\n    compat_input,\n    compat_http_server,\n    compat_str,\n    compat_urlparse,\n)\n\n# These are not used outside of buildserver.py thus not in compat.py\n\ntry:\n    import winreg as compat_winreg\nexcept ImportError:  # Python 2\n    import _winreg as compat_winreg\n\ntry:\n    import socketserver as compat_socketserver\nexcept ImportError:  # Python 2\n    import SocketServer as compat_socketserver\n\n\nclass BuildHTTPServer(compat_socketserver.ThreadingMixIn, compat_http_server.HTTPServer):\n    allow_reuse_address = True\n\n\nadvapi32 = ctypes.windll.advapi32\n\nSC_MANAGER_ALL_ACCESS = 0xf003f\nSC_MANAGER_CREATE_SERVICE = 0x02\nSERVICE_WIN32_OWN_PROCESS = 0x10\nSERVICE_AUTO_START = 0x2\nSERVICE_ERROR_NORMAL = 0x1\nDELETE = 0x00010000\nSERVICE_STATUS_START_PENDING = 0x00000002\nSERVICE_STATUS_RUNNING = 0x00000004\nSERVICE_ACCEPT_STOP = 0x1\n\nSVCNAME = 'youtubedl_builder'\n\nLPTSTR = ctypes.c_wchar_p\nSTART_CALLBACK = ctypes.WINFUNCTYPE(None, ctypes.c_int, ctypes.POINTER(LPTSTR))\n\n\nclass SERVICE_TABLE_ENTRY(ctypes.Structure):\n    _fields_ = [\n        ('lpServiceName', LPTSTR),\n        ('lpServiceProc', START_CALLBACK)\n    ]\n\n\nHandlerEx = ctypes.WINFUNCTYPE(\n    ctypes.c_int,     # return\n    ctypes.c_int,     # dwControl\n    ctypes.c_int,     # dwEventType\n    ctypes.c_void_p,  # lpEventData,\n    ctypes.c_void_p,  # lpContext,\n)\n\n\ndef _ctypes_array(c_type, py_array):\n    ar = (c_type * len(py_array))()\n    ar[:] = py_array\n    return ar\n\n\ndef win_OpenSCManager():\n    res = advapi32.OpenSCManagerW(None, None, SC_MANAGER_ALL_ACCESS)\n    if not res:\n        raise Exception('Opening service manager failed - '\n                        'are you running this as administrator?')\n    return res\n\n\ndef win_install_service(service_name, cmdline):\n    manager = win_OpenSCManager()\n    try:\n        h = advapi32.CreateServiceW(\n            manager, service_name, None,\n            SC_MANAGER_CREATE_SERVICE, SERVICE_WIN32_OWN_PROCESS,\n            SERVICE_AUTO_START, SERVICE_ERROR_NORMAL,\n            cmdline, None, None, None, None, None)\n        if not h:\n            raise OSError('Service creation failed: %s' % ctypes.FormatError())\n\n        advapi32.CloseServiceHandle(h)\n    finally:\n        advapi32.CloseServiceHandle(manager)\n\n\ndef win_uninstall_service(service_name):\n    manager = win_OpenSCManager()\n    try:\n        h = advapi32.OpenServiceW(manager, service_name, DELETE)\n        if not h:\n            raise OSError('Could not find service %s: %s' % (\n                service_name, ctypes.FormatError()))\n\n        try:\n            if not advapi32.DeleteService(h):\n                raise OSError('Deletion failed: %s' % ctypes.FormatError())\n        finally:\n            advapi32.CloseServiceHandle(h)\n    finally:\n        advapi32.CloseServiceHandle(manager)\n\n\ndef win_service_report_event(service_name, msg, is_error=True):\n    with open('C:/sshkeys/log', 'a', encoding='utf-8') as f:\n        f.write(msg + '\\n')\n\n    event_log = advapi32.RegisterEventSourceW(None, service_name)\n    if not event_log:\n        raise OSError('Could not report event: %s' % ctypes.FormatError())\n\n    try:\n        type_id = 0x0001 if is_error else 0x0004\n        event_id = 0xc0000000 if is_error else 0x40000000\n        lines = _ctypes_array(LPTSTR, [msg])\n\n        if not advapi32.ReportEventW(\n                event_log, type_id, 0, event_id, None, len(lines), 0,\n                lines, None):\n            raise OSError('Event reporting failed: %s' % ctypes.FormatError())\n    finally:\n        advapi32.DeregisterEventSource(event_log)\n\n\ndef win_service_handler(stop_event, *args):\n    try:\n        raise ValueError('Handler called with args ' + repr(args))\n        TODO\n    except Exception as e:\n        tb = traceback.format_exc()\n        msg = str(e) + '\\n' + tb\n        win_service_report_event(service_name, msg, is_error=True)\n        raise\n\n\ndef win_service_set_status(handle, status_code):\n    svcStatus = SERVICE_STATUS()\n    svcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS\n    svcStatus.dwCurrentState = status_code\n    svcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP\n\n    svcStatus.dwServiceSpecificExitCode = 0\n\n    if not advapi32.SetServiceStatus(handle, ctypes.byref(svcStatus)):\n        raise OSError('SetServiceStatus failed: %r' % ctypes.FormatError())\n\n\ndef win_service_main(service_name, real_main, argc, argv_raw):\n    try:\n        # args = [argv_raw[i].value for i in range(argc)]\n        stop_event = threading.Event()\n        handler = HandlerEx(functools.partial(stop_event, win_service_handler))\n        h = advapi32.RegisterServiceCtrlHandlerExW(service_name, handler, None)\n        if not h:\n            raise OSError('Handler registration failed: %s' %\n                          ctypes.FormatError())\n\n        TODO\n    except Exception as e:\n        tb = traceback.format_exc()\n        msg = str(e) + '\\n' + tb\n        win_service_report_event(service_name, msg, is_error=True)\n        raise\n\n\ndef win_service_start(service_name, real_main):\n    try:\n        cb = START_CALLBACK(\n            functools.partial(win_service_main, service_name, real_main))\n        dispatch_table = _ctypes_array(SERVICE_TABLE_ENTRY, [\n            SERVICE_TABLE_ENTRY(\n                service_name,\n                cb\n            ),\n            SERVICE_TABLE_ENTRY(None, ctypes.cast(None, START_CALLBACK))\n        ])\n\n        if not advapi32.StartServiceCtrlDispatcherW(dispatch_table):\n            raise OSError('ctypes start failed: %s' % ctypes.FormatError())\n    except Exception as e:\n        tb = traceback.format_exc()\n        msg = str(e) + '\\n' + tb\n        win_service_report_event(service_name, msg, is_error=True)\n        raise\n\n\ndef main(args=None):\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-i', '--install',\n                        action='store_const', dest='action', const='install',\n                        help='Launch at Windows startup')\n    parser.add_argument('-u', '--uninstall',\n                        action='store_const', dest='action', const='uninstall',\n                        help='Remove Windows service')\n    parser.add_argument('-s', '--service',\n                        action='store_const', dest='action', const='service',\n                        help='Run as a Windows service')\n    parser.add_argument('-b', '--bind', metavar='<host:port>',\n                        action='store', default='0.0.0.0:8142',\n                        help='Bind to host:port (default %default)')\n    options = parser.parse_args(args=args)\n\n    if options.action == 'install':\n        fn = os.path.abspath(__file__).replace('v:', '\\\\\\\\vboxsrv\\\\vbox')\n        cmdline = '%s %s -s -b %s' % (sys.executable, fn, options.bind)\n        win_install_service(SVCNAME, cmdline)\n        return\n\n    if options.action == 'uninstall':\n        win_uninstall_service(SVCNAME)\n        return\n\n    if options.action == 'service':\n        win_service_start(SVCNAME, main)\n        return\n\n    host, port_str = options.bind.split(':')\n    port = int(port_str)\n\n    print('Listening on %s:%d' % (host, port))\n    srv = BuildHTTPServer((host, port), BuildHTTPRequestHandler)\n    thr = threading.Thread(target=srv.serve_forever)\n    thr.start()\n    compat_input('Press ENTER to shut down')\n    srv.shutdown()\n    thr.join()\n\n\ndef rmtree(path):\n    for name in os.listdir(path):\n        fname = os.path.join(path, name)\n        if os.path.isdir(fname):\n            rmtree(fname)\n        else:\n            os.chmod(fname, 0o666)\n            os.remove(fname)\n    os.rmdir(path)\n\n\nclass BuildError(Exception):\n    def __init__(self, output, code=500):\n        self.output = output\n        self.code = code\n\n    def __str__(self):\n        return self.output\n\n\nclass HTTPError(BuildError):\n    pass\n\n\nclass PythonBuilder(object):\n    def __init__(self, **kwargs):\n        python_version = kwargs.pop('python', '3.4')\n        python_path = None\n        for node in ('Wow6432Node\\\\', ''):\n            try:\n                key = compat_winreg.OpenKey(\n                    compat_winreg.HKEY_LOCAL_MACHINE,\n                    r'SOFTWARE\\%sPython\\PythonCore\\%s\\InstallPath' % (node, python_version))\n                try:\n                    python_path, _ = compat_winreg.QueryValueEx(key, '')\n                finally:\n                    compat_winreg.CloseKey(key)\n                break\n            except Exception:\n                pass\n\n        if not python_path:\n            raise BuildError('No such Python version: %s' % python_version)\n\n        self.pythonPath = python_path\n\n        super(PythonBuilder, self).__init__(**kwargs)\n\n\nclass GITInfoBuilder(object):\n    def __init__(self, **kwargs):\n        try:\n            self.user, self.repoName = kwargs['path'][:2]\n            self.rev = kwargs.pop('rev')\n        except ValueError:\n            raise BuildError('Invalid path')\n        except KeyError as e:\n            raise BuildError('Missing mandatory parameter \"%s\"' % e.args[0])\n\n        path = os.path.join(os.environ['APPDATA'], 'Build archive', self.repoName, self.user)\n        if not os.path.exists(path):\n            os.makedirs(path)\n        self.basePath = tempfile.mkdtemp(dir=path)\n        self.buildPath = os.path.join(self.basePath, 'build')\n\n        super(GITInfoBuilder, self).__init__(**kwargs)\n\n\nclass GITBuilder(GITInfoBuilder):\n    def build(self):\n        try:\n            subprocess.check_output(['git', 'clone', 'git://github.com/%s/%s.git' % (self.user, self.repoName), self.buildPath])\n            subprocess.check_output(['git', 'checkout', self.rev], cwd=self.buildPath)\n        except subprocess.CalledProcessError as e:\n            raise BuildError(e.output)\n\n        super(GITBuilder, self).build()\n\n\nclass YoutubeDLBuilder(object):\n    authorizedUsers = ['fraca7', 'phihag', 'rg3', 'FiloSottile', 'ytdl-org']\n\n    def __init__(self, **kwargs):\n        if self.repoName != 'youtube-dl':\n            raise BuildError('Invalid repository \"%s\"' % self.repoName)\n        if self.user not in self.authorizedUsers:\n            raise HTTPError('Unauthorized user \"%s\"' % self.user, 401)\n\n        super(YoutubeDLBuilder, self).__init__(**kwargs)\n\n    def build(self):\n        try:\n            proc = subprocess.Popen([os.path.join(self.pythonPath, 'python.exe'), 'setup.py', 'py2exe'], stdin=subprocess.PIPE, cwd=self.buildPath)\n            proc.wait()\n            #subprocess.check_output([os.path.join(self.pythonPath, 'python.exe'), 'setup.py', 'py2exe'],\n            #                        cwd=self.buildPath)\n        except subprocess.CalledProcessError as e:\n            raise BuildError(e.output)\n\n        super(YoutubeDLBuilder, self).build()\n\n\nclass DownloadBuilder(object):\n    def __init__(self, **kwargs):\n        self.handler = kwargs.pop('handler')\n        self.srcPath = os.path.join(self.buildPath, *tuple(kwargs['path'][2:]))\n        self.srcPath = os.path.abspath(os.path.normpath(self.srcPath))\n        if not self.srcPath.startswith(self.buildPath):\n            raise HTTPError(self.srcPath, 401)\n\n        super(DownloadBuilder, self).__init__(**kwargs)\n\n    def build(self):\n        if not os.path.exists(self.srcPath):\n            raise HTTPError('No such file', 404)\n        if os.path.isdir(self.srcPath):\n            raise HTTPError('Is a directory: %s' % self.srcPath, 401)\n\n        self.handler.send_response(200)\n        self.handler.send_header('Content-Type', 'application/octet-stream')\n        self.handler.send_header('Content-Disposition', 'attachment; filename=%s' % os.path.split(self.srcPath)[-1])\n        self.handler.send_header('Content-Length', str(os.stat(self.srcPath).st_size))\n        self.handler.end_headers()\n\n        with open(self.srcPath, 'rb') as src:\n            shutil.copyfileobj(src, self.handler.wfile)\n\n        super(DownloadBuilder, self).build()\n\n\nclass CleanupTempDir(object):\n    def build(self):\n        try:\n            rmtree(self.basePath)\n        except Exception as e:\n            print('WARNING deleting \"%s\": %s' % (self.basePath, e))\n\n        super(CleanupTempDir, self).build()\n\n\nclass Null(object):\n    def __init__(self, **kwargs):\n        pass\n\n    def start(self):\n        pass\n\n    def close(self):\n        pass\n\n    def build(self):\n        pass\n\n\nclass Builder(PythonBuilder, GITBuilder, YoutubeDLBuilder, DownloadBuilder, CleanupTempDir, Null):\n    pass\n\n\nclass BuildHTTPRequestHandler(compat_http_server.BaseHTTPRequestHandler):\n    actionDict = {'build': Builder, 'download': Builder}  # They're the same, no more caching.\n\n    def do_GET(self):\n        path = compat_urlparse.urlparse(self.path)\n        paramDict = dict([(key, value[0]) for key, value in compat_urlparse.parse_qs(path.query).items()])\n        action, _, path = path.path.strip('/').partition('/')\n        if path:\n            path = path.split('/')\n            if action in self.actionDict:\n                try:\n                    builder = self.actionDict[action](path=path, handler=self, **paramDict)\n                    builder.start()\n                    try:\n                        builder.build()\n                    finally:\n                        builder.close()\n                except BuildError as e:\n                    self.send_response(e.code)\n                    msg = compat_str(e).encode('UTF-8')\n                    self.send_header('Content-Type', 'text/plain; charset=UTF-8')\n                    self.send_header('Content-Length', len(msg))\n                    self.end_headers()\n                    self.wfile.write(msg)\n            else:\n                self.send_response(500, 'Unknown build method \"%s\"' % action)\n        else:\n            self.send_response(500, 'Malformed URL')\n\nif __name__ == '__main__':\n    main()\n", "file_name": "093118.py", "cwe": ["CWE-276: Incorrect Default Permissions"]}
{"source": "from __future__ import unicode_literals\n\nimport errno\nimport hashlib\nimport json\nimport os.path\nimport re\nimport ssl\nimport sys\nimport types\nimport unittest\n\nimport youtube_dl.extractor\nfrom youtube_dl import YoutubeDL\nfrom youtube_dl.compat import (\n    compat_open as open,\n    compat_os_name,\n    compat_str,\n)\nfrom youtube_dl.utils import (\n    IDENTITY,\n    preferredencoding,\n    write_string,\n)\n\n\ndef get_params(override=None):\n    PARAMETERS_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)),\n                                   \"parameters.json\")\n    LOCAL_PARAMETERS_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)),\n                                         \"local_parameters.json\")\n    with open(PARAMETERS_FILE, encoding='utf-8') as pf:\n        parameters = json.load(pf)\n    if os.path.exists(LOCAL_PARAMETERS_FILE):\n        with open(LOCAL_PARAMETERS_FILE, encoding='utf-8') as pf:\n            parameters.update(json.load(pf))\n    if override:\n        parameters.update(override)\n    return parameters\n\n\ndef try_rm(filename):\n    \"\"\" Remove a file if it exists \"\"\"\n    try:\n        os.remove(filename)\n    except OSError as ose:\n        if ose.errno != errno.ENOENT:\n            raise\n\n\ndef report_warning(message):\n    '''\n    Print the message to stderr, it will be prefixed with 'WARNING:'\n    If stderr is a tty file the 'WARNING:' will be colored\n    '''\n    if sys.stderr.isatty() and compat_os_name != 'nt':\n        _msg_header = '\\033[0;33mWARNING:\\033[0m'\n    else:\n        _msg_header = 'WARNING:'\n    output = '%s %s\\n' % (_msg_header, message)\n    if 'b' in getattr(sys.stderr, 'mode', '') or sys.version_info[0] < 3:\n        output = output.encode(preferredencoding())\n    sys.stderr.write(output)\n\n\nclass FakeYDL(YoutubeDL):\n    def __init__(self, override=None):\n        # Different instances of the downloader can't share the same dictionary\n        # some test set the \"sublang\" parameter, which would break the md5 checks.\n        params = get_params(override=override)\n        super(FakeYDL, self).__init__(params, auto_init=False)\n        self.result = []\n\n    def to_screen(self, s, skip_eol=None):\n        print(s)\n\n    def trouble(self, *args, **kwargs):\n        s = args[0] if len(args) > 0 else kwargs.get('message', 'Missing message')\n        raise Exception(s)\n\n    def download(self, x):\n        self.result.append(x)\n\n    def expect_warning(self, regex):\n        # Silence an expected warning matching a regex\n        old_report_warning = self.report_warning\n\n        def report_warning(self, message):\n            if re.match(regex, message):\n                return\n            old_report_warning(message)\n        self.report_warning = types.MethodType(report_warning, self)\n\n\nclass FakeLogger(object):\n    def debug(self, msg):\n        pass\n\n    def warning(self, msg):\n        pass\n\n    def error(self, msg):\n        pass\n\n\ndef gettestcases(include_onlymatching=False):\n    for ie in youtube_dl.extractor.gen_extractors():\n        for tc in ie.get_testcases(include_onlymatching):\n            yield tc\n\n\nmd5 = lambda s: hashlib.md5(s.encode('utf-8')).hexdigest()\n\n\ndef expect_value(self, got, expected, field):\n    if isinstance(expected, compat_str) and expected.startswith('re:'):\n        match_str = expected[len('re:'):]\n        match_rex = re.compile(match_str)\n\n        self.assertTrue(\n            isinstance(got, compat_str),\n            'Expected a %s object, but got %s for field %s' % (\n                compat_str.__name__, type(got).__name__, field))\n        self.assertTrue(\n            match_rex.match(got),\n            'field %s (value: %r) should match %r' % (field, got, match_str))\n    elif isinstance(expected, compat_str) and expected.startswith('startswith:'):\n        start_str = expected[len('startswith:'):]\n        self.assertTrue(\n            isinstance(got, compat_str),\n            'Expected a %s object, but got %s for field %s' % (\n                compat_str.__name__, type(got).__name__, field))\n        self.assertTrue(\n            got.startswith(start_str),\n            'field %s (value: %r) should start with %r' % (field, got, start_str))\n    elif isinstance(expected, compat_str) and expected.startswith('contains:'):\n        contains_str = expected[len('contains:'):]\n        self.assertTrue(\n            isinstance(got, compat_str),\n            'Expected a %s object, but got %s for field %s' % (\n                compat_str.__name__, type(got).__name__, field))\n        self.assertTrue(\n            contains_str in got,\n            'field %s (value: %r) should contain %r' % (field, got, contains_str))\n    elif isinstance(expected, compat_str) and re.match(r'lambda \\w+:', expected):\n        fn = eval(expected)\n        suite = expected.split(':', 1)[1].strip()\n        self.assertTrue(\n            fn(got),\n            'Expected field %s to meet condition %s, but value %r failed ' % (field, suite, got))\n    elif isinstance(expected, type):\n        self.assertTrue(\n            isinstance(got, expected),\n            'Expected type %r for field %s, but got value %r of type %r' % (expected, field, got, type(got)))\n    elif isinstance(expected, dict) and isinstance(got, dict):\n        expect_dict(self, got, expected)\n    elif isinstance(expected, list) and isinstance(got, list):\n        self.assertEqual(\n            len(expected), len(got),\n            'Expected a list of length %d, but got a list of length %d for field %s' % (\n                len(expected), len(got), field))\n        for index, (item_got, item_expected) in enumerate(zip(got, expected)):\n            type_got = type(item_got)\n            type_expected = type(item_expected)\n            self.assertEqual(\n                type_expected, type_got,\n                'Type mismatch for list item at index %d for field %s, expected %r, got %r' % (\n                    index, field, type_expected, type_got))\n            expect_value(self, item_got, item_expected, field)\n    else:\n        if isinstance(expected, compat_str) and expected.startswith('md5:'):\n            self.assertTrue(\n                isinstance(got, compat_str),\n                'Expected field %s to be a unicode object, but got value %r of type %r' % (field, got, type(got)))\n            got = 'md5:' + md5(got)\n        elif isinstance(expected, compat_str) and re.match(r'^(?:min|max)?count:\\d+', expected):\n            self.assertTrue(\n                isinstance(got, (list, dict)),\n                'Expected field %s to be a list or a dict, but it is of type %s' % (\n                    field, type(got).__name__))\n            op, _, expected_num = expected.partition(':')\n            expected_num = int(expected_num)\n            if op == 'mincount':\n                assert_func = self.assertGreaterEqual\n                msg_tmpl = 'Expected %d items in field %s, but only got %d'\n            elif op == 'maxcount':\n                assert_func = self.assertLessEqual\n                msg_tmpl = 'Expected maximum %d items in field %s, but got %d'\n            elif op == 'count':\n                assert_func = self.assertEqual\n                msg_tmpl = 'Expected exactly %d items in field %s, but got %d'\n            else:\n                assert False\n            assert_func(\n                len(got), expected_num,\n                msg_tmpl % (expected_num, field, len(got)))\n            return\n        self.assertEqual(\n            expected, got,\n            'Invalid value for field %s, expected %r, got %r' % (field, expected, got))\n\n\ndef expect_dict(self, got_dict, expected_dict):\n    for info_field, expected in expected_dict.items():\n        got = got_dict.get(info_field)\n        expect_value(self, got, expected, info_field)\n\n\ndef expect_info_dict(self, got_dict, expected_dict):\n    expect_dict(self, got_dict, expected_dict)\n    # Check for the presence of mandatory fields\n    if got_dict.get('_type') not in ('playlist', 'multi_video'):\n        for key in ('id', 'url', 'title', 'ext'):\n            self.assertTrue(got_dict.get(key), 'Missing mandatory field %s' % key)\n    # Check for mandatory fields that are automatically set by YoutubeDL\n    for key in ['webpage_url', 'extractor', 'extractor_key']:\n        self.assertTrue(got_dict.get(key), 'Missing field: %s' % key)\n\n    # Are checkable fields missing from the test case definition?\n    test_info_dict = dict((key, value if not isinstance(value, compat_str) or len(value) < 250 else 'md5:' + md5(value))\n                          for key, value in got_dict.items()\n                          if value and key in ('id', 'title', 'description', 'uploader', 'upload_date', 'timestamp', 'uploader_id', 'location', 'age_limit'))\n    missing_keys = set(test_info_dict.keys()) - set(expected_dict.keys())\n    if missing_keys:\n        def _repr(v):\n            if isinstance(v, compat_str):\n                return \"'%s'\" % v.replace('\\\\', '\\\\\\\\').replace(\"'\", \"\\\\'\").replace('\\n', '\\\\n')\n            else:\n                return repr(v)\n        info_dict_str = ''\n        if len(missing_keys) != len(expected_dict):\n            info_dict_str += ''.join(\n                '    %s: %s,\\n' % (_repr(k), _repr(v))\n                for k, v in test_info_dict.items() if k not in missing_keys)\n\n            if info_dict_str:\n                info_dict_str += '\\n'\n        info_dict_str += ''.join(\n            '    %s: %s,\\n' % (_repr(k), _repr(test_info_dict[k]))\n            for k in missing_keys)\n        write_string(\n            '\\n\\'info_dict\\': {\\n' + info_dict_str + '},\\n', out=sys.stderr)\n        self.assertFalse(\n            missing_keys,\n            'Missing keys in test definition: %s' % (\n                ', '.join(sorted(missing_keys))))\n\n\ndef assertRegexpMatches(self, text, regexp, msg=None):\n    if hasattr(self, 'assertRegexp'):\n        return self.assertRegexp(text, regexp, msg)\n    else:\n        m = re.match(regexp, text)\n        if not m:\n            note = 'Regexp didn\\'t match: %r not found' % (regexp)\n            if len(text) < 1000:\n                note += ' in %r' % text\n            if msg is None:\n                msg = note\n            else:\n                msg = note + ', ' + msg\n            self.assertTrue(m, msg)\n\n\ndef expect_warnings(ydl, warnings_re):\n    real_warning = ydl.report_warning\n\n    def _report_warning(w):\n        if not any(re.search(w_re, w) for w_re in warnings_re):\n            real_warning(w)\n\n    ydl.report_warning = _report_warning\n\n\ndef http_server_port(httpd):\n    if os.name == 'java' and isinstance(httpd.socket, ssl.SSLSocket):\n        # In Jython SSLSocket is not a subclass of socket.socket\n        sock = httpd.socket.sock\n    else:\n        sock = httpd.socket\n    return sock.getsockname()[1]\n\n\ndef expectedFailureIf(cond):\n    return unittest.expectedFailure if cond else IDENTITY\n", "file_name": "717170.py", "cwe": ["CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"]}
{"source": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport json\nimport re\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    clean_html,\n    int_or_none,\n    try_get,\n    unified_strdate,\n    unified_timestamp,\n)\n\n\nclass AmericasTestKitchenIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?(?:americastestkitchen|cooks(?:country|illustrated))\\.com/(?:cooks(?:country|illustrated)/)?(?P<resource_type>episode|videos)/(?P<id>\\d+)'\n    _TESTS = [{\n        'url': 'https://www.americastestkitchen.com/episode/582-weeknight-japanese-suppers',\n        'md5': 'b861c3e365ac38ad319cfd509c30577f',\n        'info_dict': {\n            'id': '5b400b9ee338f922cb06450c',\n            'title': 'Japanese Suppers',\n            'ext': 'mp4',\n            'display_id': 'weeknight-japanese-suppers',\n            'description': 'md5:64e606bfee910627efc4b5f050de92b3',\n            'timestamp': 1523304000,\n            'upload_date': '20180409',\n            'release_date': '20180409',\n            'series': \"America's Test Kitchen\",\n            'season': 'Season 18',\n            'season_number': 18,\n            'episode': 'Japanese Suppers',\n            'episode_number': 15,\n            'duration': 1376,\n            'thumbnail': r're:^https?://',\n            'average_rating': 0,\n            'view_count': int,\n        },\n        'params': {\n            'skip_download': True,\n        },\n    }, {\n        # Metadata parsing behaves differently for newer episodes (705) as opposed to older episodes (582 above)\n        'url': 'https://www.americastestkitchen.com/episode/705-simple-chicken-dinner',\n        'md5': '06451608c57651e985a498e69cec17e5',\n        'info_dict': {\n            'id': '5fbe8c61bda2010001c6763b',\n            'title': 'Simple Chicken Dinner',\n            'ext': 'mp4',\n            'display_id': 'atktv_2103_simple-chicken-dinner_full-episode_web-mp4',\n            'description': 'md5:eb68737cc2fd4c26ca7db30139d109e7',\n            'timestamp': 1610737200,\n            'upload_date': '20210115',\n            'release_date': '20210115',\n            'series': \"America's Test Kitchen\",\n            'season': 'Season 21',\n            'season_number': 21,\n            'episode': 'Simple Chicken Dinner',\n            'episode_number': 3,\n            'duration': 1397,\n            'thumbnail': r're:^https?://',\n            'view_count': int,\n            'average_rating': 0,\n        },\n        'params': {\n            'skip_download': True,\n        },\n    }, {\n        'url': 'https://www.americastestkitchen.com/videos/3420-pan-seared-salmon',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.americastestkitchen.com/cookscountry/episode/564-when-only-chocolate-will-do',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.americastestkitchen.com/cooksillustrated/videos/4478-beef-wellington',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.cookscountry.com/episode/564-when-only-chocolate-will-do',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.cooksillustrated.com/videos/4478-beef-wellington',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        resource_type, video_id = re.match(self._VALID_URL, url).groups()\n        is_episode = resource_type == 'episode'\n        if is_episode:\n            resource_type = 'episodes'\n\n        resource = self._download_json(\n            'https://www.americastestkitchen.com/api/v6/%s/%s' % (resource_type, video_id), video_id)\n        video = resource['video'] if is_episode else resource\n        episode = resource if is_episode else resource.get('episode') or {}\n\n        return {\n            '_type': 'url_transparent',\n            'url': 'https://player.zype.com/embed/%s.js?api_key=jZ9GUhRmxcPvX7M3SlfejB6Hle9jyHTdk2jVxG7wOHPLODgncEKVdPYBhuz9iWXQ' % video['zypeId'],\n            'ie_key': 'Zype',\n            'description': clean_html(video.get('description')),\n            'timestamp': unified_timestamp(video.get('publishDate')),\n            'release_date': unified_strdate(video.get('publishDate')),\n            'episode_number': int_or_none(episode.get('number')),\n            'season_number': int_or_none(episode.get('season')),\n            'series': try_get(episode, lambda x: x['show']['title']),\n            'episode': episode.get('title'),\n        }\n\n\nclass AmericasTestKitchenSeasonIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?(?P<show>americastestkitchen|(?P<cooks>cooks(?:country|illustrated)))\\.com(?:(?:/(?P<show2>cooks(?:country|illustrated)))?(?:/?$|(?<!ated)(?<!ated\\.com)/episodes/browse/season_(?P<season>\\d+)))'\n    _TESTS = [{\n        # ATK Season\n        'url': 'https://www.americastestkitchen.com/episodes/browse/season_1',\n        'info_dict': {\n            'id': 'season_1',\n            'title': 'Season 1',\n        },\n        'playlist_count': 13,\n    }, {\n        # Cooks Country Season\n        'url': 'https://www.americastestkitchen.com/cookscountry/episodes/browse/season_12',\n        'info_dict': {\n            'id': 'season_12',\n            'title': 'Season 12',\n        },\n        'playlist_count': 13,\n    }, {\n        # America's Test Kitchen Series\n        'url': 'https://www.americastestkitchen.com/',\n        'info_dict': {\n            'id': 'americastestkitchen',\n            'title': 'America\\'s Test Kitchen',\n        },\n        'playlist_count': 558,\n    }, {\n        # Cooks Country Series\n        'url': 'https://www.americastestkitchen.com/cookscountry',\n        'info_dict': {\n            'id': 'cookscountry',\n            'title': 'Cook\\'s Country',\n        },\n        'playlist_count': 199,\n    }, {\n        'url': 'https://www.americastestkitchen.com/cookscountry/',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.cookscountry.com/episodes/browse/season_12',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.cookscountry.com',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.americastestkitchen.com/cooksillustrated/',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.cooksillustrated.com',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        match = re.match(self._VALID_URL, url).groupdict()\n        show = match.get('show2')\n        show_path = ('/' + show) if show else ''\n        show = show or match['show']\n        season_number = int_or_none(match.get('season'))\n\n        slug, title = {\n            'americastestkitchen': ('atk', 'America\\'s Test Kitchen'),\n            'cookscountry': ('cco', 'Cook\\'s Country'),\n            'cooksillustrated': ('cio', 'Cook\\'s Illustrated'),\n        }[show]\n\n        facet_filters = [\n            'search_document_klass:episode',\n            'search_show_slug:' + slug,\n        ]\n\n        if season_number:\n            playlist_id = 'season_%d' % season_number\n            playlist_title = 'Season %d' % season_number\n            facet_filters.append('search_season_list:' + playlist_title)\n        else:\n            playlist_id = show\n            playlist_title = title\n\n        season_search = self._download_json(\n            'https://y1fnzxui30-dsn.algolia.net/1/indexes/everest_search_%s_season_desc_production' % slug,\n            playlist_id, headers={\n                'Origin': 'https://www.americastestkitchen.com',\n                'X-Algolia-API-Key': '8d504d0099ed27c1b73708d22871d805',\n                'X-Algolia-Application-Id': 'Y1FNZXUI30',\n            }, query={\n                'facetFilters': json.dumps(facet_filters),\n                'attributesToRetrieve': 'description,search_%s_episode_number,search_document_date,search_url,title,search_atk_episode_season' % slug,\n                'attributesToHighlight': '',\n                'hitsPerPage': 1000,\n            })\n\n        def entries():\n            for episode in (season_search.get('hits') or []):\n                search_url = episode.get('search_url')  # always formatted like '/episode/123-title-of-episode'\n                if not search_url:\n                    continue\n                yield {\n                    '_type': 'url',\n                    'url': 'https://www.americastestkitchen.com%s%s' % (show_path, search_url),\n                    'id': try_get(episode, lambda e: e['objectID'].rsplit('_', 1)[-1]),\n                    'title': episode.get('title'),\n                    'description': episode.get('description'),\n                    'timestamp': unified_timestamp(episode.get('search_document_date')),\n                    'season_number': season_number,\n                    'episode_number': int_or_none(episode.get('search_%s_episode_number' % slug)),\n                    'ie_key': AmericasTestKitchenIE.ie_key(),\n                }\n\n        return self.playlist_result(\n            entries(), playlist_id, playlist_title)\n", "file_name": "773378.py", "cwe": ["CWE-798: Use of Hard-coded Credentials"]}
{"source": "#!/usr/bin/env python\n# Copyright 2020 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport argparse\nimport shutil\nimport time\nfrom json import JSONDecodeError\nfrom logging import getLogger\nfrom pathlib import Path\nfrom typing import Dict, List\n\nimport torch\nfrom torch.utils.data import DataLoader\nfrom tqdm import tqdm\n\nfrom transformers import AutoModelForSeq2SeqLM, AutoTokenizer\nfrom utils import (\n    Seq2SeqDataset,\n    calculate_bleu,\n    calculate_rouge,\n    chunks,\n    lmap,\n    load_json,\n    parse_numeric_n_bool_cl_kwargs,\n    save_json,\n    use_task_specific_params,\n    write_txt_file,\n)\n\n\nlogger = getLogger(__name__)\n\n\ndef eval_data_dir(\n    data_dir,\n    save_dir: str,\n    model_name: str,\n    bs: int = 8,\n    max_source_length: int = 1024,\n    type_path=\"val\",\n    n_obs=None,\n    fp16=False,\n    task=\"summarization\",\n    local_rank=None,\n    num_return_sequences=1,\n    dataset_kwargs: Dict = None,\n    prefix=\"\",\n    **generate_kwargs,\n) -> Dict:\n    \"\"\"Run evaluation on part of the data for one gpu and save to {save_dir}/rank_{rank}_output.json\"\"\"\n    model_name = str(model_name)\n    assert local_rank is not None\n    torch.distributed.init_process_group(backend=\"nccl\", rank=local_rank)\n\n    save_dir = Path(save_dir)\n    save_path = save_dir.joinpath(f\"rank_{local_rank}_output.json\")\n    torch.cuda.set_device(local_rank)\n    model = AutoModelForSeq2SeqLM.from_pretrained(model_name).cuda()\n    if fp16:\n        model = model.half()\n    # determine if we need to increase num_beams\n    use_task_specific_params(model, task)  # update config with task specific params\n    num_beams = generate_kwargs.pop(\"num_beams\", model.config.num_beams)  # AttributeError risk?\n    if num_return_sequences > num_beams:\n        num_beams = num_return_sequences\n\n    tokenizer = AutoTokenizer.from_pretrained(model_name)\n    logger.info(f\"Inferred tokenizer type: {tokenizer.__class__}\")  # if this is wrong, check config.model_type.\n\n    if max_source_length is None:\n        max_source_length = tokenizer.model_max_length\n    if prefix is None:\n        prefix = prefix or getattr(model.config, \"prefix\", \"\") or \"\"\n    ds = Seq2SeqDataset(\n        tokenizer,\n        data_dir,\n        max_source_length,\n        max_target_length=1024,\n        type_path=type_path,\n        n_obs=n_obs,\n        prefix=prefix,\n        **dataset_kwargs,\n    )\n    # I set shuffle=True for a more accurate progress bar.\n    # If all the longest samples are first, the prog bar estimate is too high at the beginning.\n    sampler = ds.make_sortish_sampler(bs, distributed=True, add_extra_examples=False, shuffle=True)\n    data_loader = DataLoader(ds, sampler=sampler, batch_size=bs, collate_fn=ds.collate_fn)\n    results = []\n    for batch in tqdm(data_loader):\n        summaries = model.generate(\n            input_ids=batch[\"input_ids\"].to(model.device),\n            attention_mask=batch[\"attention_mask\"].to(model.device),\n            num_return_sequences=num_return_sequences,\n            num_beams=num_beams,\n            **generate_kwargs,\n        )\n        preds = tokenizer.batch_decode(summaries, skip_special_tokens=True, clean_up_tokenization_spaces=False)\n        ids = batch[\"ids\"]\n        if num_return_sequences > 1:\n            preds = chunks(preds, num_return_sequences)  # batch size chunks, each of size num_return_seq\n        for i, pred in enumerate(preds):\n            results.append({\"pred\": pred, \"id\": ids[i].item()})\n    save_json(results, save_path)\n    return results, sampler.num_replicas\n\n\ndef run_generate():\n    parser = argparse.ArgumentParser(\n        epilog=\"Unspecified args like --num_beams=2 --decoder_start_token_id=4 are passed to model.generate\"\n    )\n    parser.add_argument(\"--data_dir\", type=str, help=\"like cnn_dm/test.source\")\n    parser.add_argument(\n        \"--model_name\",\n        type=str,\n        help=\"like facebook/bart-large-cnn,google-t5/t5-base, etc.\",\n        default=\"sshleifer/distilbart-xsum-12-3\",\n    )\n    parser.add_argument(\"--save_dir\", type=str, help=\"where to save\", default=\"tmp_gen\")\n    parser.add_argument(\"--max_source_length\", type=int, default=None)\n    parser.add_argument(\n        \"--type_path\", type=str, default=\"test\", help=\"which subset to evaluate typically train/val/test\"\n    )\n    parser.add_argument(\"--task\", type=str, default=\"summarization\", help=\"used for task_specific_params + metrics\")\n    parser.add_argument(\"--bs\", type=int, default=8, required=False, help=\"batch size\")\n    parser.add_argument(\n        \"--local_rank\", type=int, default=-1, required=False, help=\"should be passed by distributed.launch\"\n    )\n\n    parser.add_argument(\n        \"--n_obs\", type=int, default=None, required=False, help=\"How many observations. Defaults to all.\"\n    )\n    parser.add_argument(\n        \"--num_return_sequences\", type=int, default=1, required=False, help=\"How many sequences to return\"\n    )\n    parser.add_argument(\n        \"--sync_timeout\",\n        type=int,\n        default=600,\n        required=False,\n        help=\"How long should master process wait for other processes to finish.\",\n    )\n    parser.add_argument(\"--src_lang\", type=str, default=None, required=False)\n    parser.add_argument(\"--tgt_lang\", type=str, default=None, required=False)\n    parser.add_argument(\n        \"--prefix\", type=str, required=False, default=None, help=\"will be added to the beginning of src examples\"\n    )\n    parser.add_argument(\"--fp16\", action=\"store_true\")\n    parser.add_argument(\"--debug\", action=\"store_true\")\n    start_time = time.time()\n    args, rest = parser.parse_known_args()\n    generate_kwargs = parse_numeric_n_bool_cl_kwargs(rest)\n    if generate_kwargs and args.local_rank <= 0:\n        print(f\"parsed the following generate kwargs: {generate_kwargs}\")\n    json_save_dir = Path(args.save_dir + \"_tmp\")\n    Path(json_save_dir).mkdir(exist_ok=True)  # this handles locking.\n    intermediate_files = list(json_save_dir.glob(\"rank_*.json\"))\n    if intermediate_files:\n        raise ValueError(f\"Found files at {json_save_dir} please move or remove them.\")\n        # In theory, a node could finish and save before another node hits this. If this happens, we can address later.\n    dataset_kwargs = {}\n    if args.src_lang is not None:\n        dataset_kwargs[\"src_lang\"] = args.src_lang\n    if args.tgt_lang is not None:\n        dataset_kwargs[\"tgt_lang\"] = args.tgt_lang\n\n    Path(args.save_dir).mkdir(exist_ok=True)\n    results, num_replicas = eval_data_dir(\n        args.data_dir,\n        json_save_dir,\n        args.model_name,\n        type_path=args.type_path,\n        bs=args.bs,\n        fp16=args.fp16,\n        task=args.task,\n        local_rank=args.local_rank,\n        n_obs=args.n_obs,\n        max_source_length=args.max_source_length,\n        num_return_sequences=args.num_return_sequences,\n        prefix=args.prefix,\n        dataset_kwargs=dataset_kwargs,\n        **generate_kwargs,\n    )\n\n    if args.local_rank <= 0:\n        save_dir = Path(args.save_dir)\n        save_dir.mkdir(exist_ok=True)\n        partial_results = gather_results_from_each_node(num_replicas, json_save_dir, args.sync_timeout)\n        preds = combine_partial_results(partial_results)\n        if args.num_return_sequences > 1:\n            save_path = save_dir.joinpath(\"pseudolabel_results.json\")\n            print(f\"Saving aggregated results at {save_path}, intermediate in {json_save_dir}/\")\n            save_json(preds, save_path)\n            return\n        tgt_file = Path(args.data_dir).joinpath(args.type_path + \".target\")\n        with open(tgt_file) as f:\n            labels = [x.rstrip() for x in f.readlines()][: len(preds)]\n\n        # Calculate metrics, save metrics,  and save _generations.txt\n        calc_bleu = \"translation\" in args.task\n        score_fn = calculate_bleu if calc_bleu else calculate_rouge\n        metric_name = \"bleu\" if calc_bleu else \"rouge\"\n        metrics: Dict = score_fn(preds, labels)\n        metrics[\"n_obs\"] = len(preds)\n        runtime = time.time() - start_time\n        metrics[\"seconds_per_sample\"] = round(runtime / metrics[\"n_obs\"], 4)\n        metrics[\"n_gpus\"] = num_replicas\n        # TODO(@stas00): add whatever metadata to metrics\n        metrics_save_path = save_dir.joinpath(f\"{args.type_path}_{metric_name}.json\")\n        save_json(metrics, metrics_save_path, indent=None)\n        print(metrics)\n        write_txt_file(preds, save_dir.joinpath(f\"{args.type_path}_generations.txt\"))\n        if args.debug:\n            write_txt_file(labels, save_dir.joinpath(f\"{args.type_path}.target\"))\n        else:\n            shutil.rmtree(json_save_dir)\n\n\ndef combine_partial_results(partial_results) -> List:\n    \"\"\"Concatenate partial results into one file, then sort it by id.\"\"\"\n    records = []\n    for partial_result in partial_results:\n        records.extend(partial_result)\n    records = sorted(records, key=lambda x: x[\"id\"])\n    preds = [x[\"pred\"] for x in records]\n    return preds\n\n\ndef gather_results_from_each_node(num_replicas, save_dir, timeout) -> List[Dict[str, List]]:\n    # WAIT FOR lots of .json files\n    start_wait = time.time()\n    logger.info(\"waiting for all nodes to finish\")\n    json_data = None\n    while (time.time() - start_wait) < timeout:\n        json_files = list(save_dir.glob(\"rank_*.json\"))\n        if len(json_files) < num_replicas:\n            continue\n        try:\n            # make sure all json files are fully saved\n            json_data = lmap(load_json, json_files)\n            return json_data\n        except JSONDecodeError:\n            continue\n    else:\n        raise TimeoutError(\"Rank 0 gave up on waiting for other processes\")\n    # Unreachable\n\n\nif __name__ == \"__main__\":\n    # Usage for MT:\n    run_generate()\n", "file_name": "627547.py", "cwe": ["CWE-676: Use of Potentially Dangerous Function"]}
{"source": "# coding=utf-8\n# Copyright 2018 The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Convert BertExtAbs's checkpoints.\n\nThe script looks like it is doing something trivial but it is not. The \"weights\"\nproposed by the authors are actually the entire model pickled. We need to load\nthe model within the original codebase to be able to only save its `state_dict`.\n\"\"\"\n\nimport argparse\nimport logging\nfrom collections import namedtuple\n\nimport torch\nfrom model_bertabs import BertAbsSummarizer\nfrom models.model_builder import AbsSummarizer  # The authors' implementation\n\nfrom transformers import BertTokenizer\n\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nSAMPLE_TEXT = \"Hello world! c\u00e9c\u00e9 herlolip\"\n\n\nBertAbsConfig = namedtuple(\n    \"BertAbsConfig\",\n    [\n        \"temp_dir\",\n        \"large\",\n        \"use_bert_emb\",\n        \"finetune_bert\",\n        \"encoder\",\n        \"share_emb\",\n        \"max_pos\",\n        \"enc_layers\",\n        \"enc_hidden_size\",\n        \"enc_heads\",\n        \"enc_ff_size\",\n        \"enc_dropout\",\n        \"dec_layers\",\n        \"dec_hidden_size\",\n        \"dec_heads\",\n        \"dec_ff_size\",\n        \"dec_dropout\",\n    ],\n)\n\n\ndef convert_bertabs_checkpoints(path_to_checkpoints, dump_path):\n    \"\"\"Copy/paste and tweak the pre-trained weights provided by the creators\n    of BertAbs for the internal architecture.\n    \"\"\"\n\n    # Instantiate the authors' model with the pre-trained weights\n    config = BertAbsConfig(\n        temp_dir=\".\",\n        finetune_bert=False,\n        large=False,\n        share_emb=True,\n        use_bert_emb=False,\n        encoder=\"bert\",\n        max_pos=512,\n        enc_layers=6,\n        enc_hidden_size=512,\n        enc_heads=8,\n        enc_ff_size=512,\n        enc_dropout=0.2,\n        dec_layers=6,\n        dec_hidden_size=768,\n        dec_heads=8,\n        dec_ff_size=2048,\n        dec_dropout=0.2,\n    )\n    checkpoints = torch.load(path_to_checkpoints, lambda storage, loc: storage)\n    original = AbsSummarizer(config, torch.device(\"cpu\"), checkpoints)\n    original.eval()\n\n    new_model = BertAbsSummarizer(config, torch.device(\"cpu\"))\n    new_model.eval()\n\n    # -------------------\n    # Convert the weights\n    # -------------------\n\n    logging.info(\"convert the model\")\n    new_model.bert.load_state_dict(original.bert.state_dict())\n    new_model.decoder.load_state_dict(original.decoder.state_dict())\n    new_model.generator.load_state_dict(original.generator.state_dict())\n\n    # ----------------------------------\n    # Make sure the outpus are identical\n    # ----------------------------------\n\n    logging.info(\"Make sure that the models' outputs are identical\")\n    tokenizer = BertTokenizer.from_pretrained(\"google-bert/bert-base-uncased\")\n\n    # prepare the model inputs\n    encoder_input_ids = tokenizer.encode(\"This is sample \u00e9\u00e0alj'-.\")\n    encoder_input_ids.extend([tokenizer.pad_token_id] * (512 - len(encoder_input_ids)))\n    encoder_input_ids = torch.tensor(encoder_input_ids).unsqueeze(0)\n    decoder_input_ids = tokenizer.encode(\"This is sample 3 \u00e9\u00e0alj'-.\")\n    decoder_input_ids.extend([tokenizer.pad_token_id] * (512 - len(decoder_input_ids)))\n    decoder_input_ids = torch.tensor(decoder_input_ids).unsqueeze(0)\n\n    # failsafe to make sure the weights reset does not affect the\n    # loaded weights.\n    assert torch.max(torch.abs(original.generator[0].weight - new_model.generator[0].weight)) == 0\n\n    # forward pass\n    src = encoder_input_ids\n    tgt = decoder_input_ids\n    segs = token_type_ids = None\n    clss = None\n    mask_src = encoder_attention_mask = None\n    mask_tgt = decoder_attention_mask = None\n    mask_cls = None\n\n    # The original model does not apply the geneator layer immediatly but rather in\n    # the beam search (where it combines softmax + linear layer). Since we already\n    # apply the softmax in our generation process we only apply the linear layer here.\n    # We make sure that the outputs of the full stack are identical\n    output_original_model = original(src, tgt, segs, clss, mask_src, mask_tgt, mask_cls)[0]\n    output_original_generator = original.generator(output_original_model)\n\n    output_converted_model = new_model(\n        encoder_input_ids, decoder_input_ids, token_type_ids, encoder_attention_mask, decoder_attention_mask\n    )[0]\n    output_converted_generator = new_model.generator(output_converted_model)\n\n    maximum_absolute_difference = torch.max(torch.abs(output_converted_model - output_original_model)).item()\n    print(\"Maximum absolute difference beween weights: {:.2f}\".format(maximum_absolute_difference))\n    maximum_absolute_difference = torch.max(torch.abs(output_converted_generator - output_original_generator)).item()\n    print(\"Maximum absolute difference beween weights: {:.2f}\".format(maximum_absolute_difference))\n\n    are_identical = torch.allclose(output_converted_model, output_original_model, atol=1e-3)\n    if are_identical:\n        logging.info(\"all weights are equal up to 1e-3\")\n    else:\n        raise ValueError(\"the weights are different. The new model is likely different from the original one.\")\n\n    # The model has been saved with torch.save(model) and this is bound to the exact\n    # directory structure. We save the state_dict instead.\n    logging.info(\"saving the model's state dictionary\")\n    torch.save(\n        new_model.state_dict(), \"./bertabs-finetuned-cnndm-extractive-abstractive-summarization/pytorch_model.bin\"\n    )\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--bertabs_checkpoint_path\",\n        default=None,\n        type=str,\n        required=True,\n        help=\"Path the official PyTorch dump.\",\n    )\n    parser.add_argument(\n        \"--pytorch_dump_folder_path\",\n        default=None,\n        type=str,\n        required=True,\n        help=\"Path to the output PyTorch model.\",\n    )\n    args = parser.parse_args()\n\n    convert_bertabs_checkpoints(\n        args.bertabs_checkpoint_path,\n        args.pytorch_dump_folder_path,\n    )\n", "file_name": "624453.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "#! /usr/bin/python3\nimport argparse\nimport logging\nimport os\nimport sys\nfrom collections import namedtuple\n\nimport torch\nfrom modeling_bertabs import BertAbs, build_predictor\nfrom torch.utils.data import DataLoader, SequentialSampler\nfrom tqdm import tqdm\n\nfrom transformers import BertTokenizer\n\nfrom .utils_summarization import (\n    CNNDMDataset,\n    build_mask,\n    compute_token_type_ids,\n    encode_for_summarization,\n    truncate_or_pad,\n)\n\n\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(stream=sys.stdout, level=logging.INFO)\n\n\nBatch = namedtuple(\"Batch\", [\"document_names\", \"batch_size\", \"src\", \"segs\", \"mask_src\", \"tgt_str\"])\n\n\ndef evaluate(args):\n    tokenizer = BertTokenizer.from_pretrained(\"google-bert/bert-base-uncased\", do_lower_case=True)\n    model = BertAbs.from_pretrained(\"remi/bertabs-finetuned-extractive-abstractive-summarization\")\n    model.to(args.device)\n    model.eval()\n\n    symbols = {\n        \"BOS\": tokenizer.vocab[\"[unused0]\"],\n        \"EOS\": tokenizer.vocab[\"[unused1]\"],\n        \"PAD\": tokenizer.vocab[\"[PAD]\"],\n    }\n\n    if args.compute_rouge:\n        reference_summaries = []\n        generated_summaries = []\n\n        import nltk\n        import rouge\n\n        nltk.download(\"punkt\")\n        rouge_evaluator = rouge.Rouge(\n            metrics=[\"rouge-n\", \"rouge-l\"],\n            max_n=2,\n            limit_length=True,\n            length_limit=args.beam_size,\n            length_limit_type=\"words\",\n            apply_avg=True,\n            apply_best=False,\n            alpha=0.5,  # Default F1_score\n            weight_factor=1.2,\n            stemming=True,\n        )\n\n    # these (unused) arguments are defined to keep the compatibility\n    # with the legacy code and will be deleted in a next iteration.\n    args.result_path = \"\"\n    args.temp_dir = \"\"\n\n    data_iterator = build_data_iterator(args, tokenizer)\n    predictor = build_predictor(args, tokenizer, symbols, model)\n\n    logger.info(\"***** Running evaluation *****\")\n    logger.info(\"  Number examples = %d\", len(data_iterator.dataset))\n    logger.info(\"  Batch size = %d\", args.batch_size)\n    logger.info(\"\")\n    logger.info(\"***** Beam Search parameters *****\")\n    logger.info(\"  Beam size = %d\", args.beam_size)\n    logger.info(\"  Minimum length = %d\", args.min_length)\n    logger.info(\"  Maximum length = %d\", args.max_length)\n    logger.info(\"  Alpha (length penalty) = %.2f\", args.alpha)\n    logger.info(\"  Trigrams %s be blocked\", (\"will\" if args.block_trigram else \"will NOT\"))\n\n    for batch in tqdm(data_iterator):\n        batch_data = predictor.translate_batch(batch)\n        translations = predictor.from_batch(batch_data)\n        summaries = [format_summary(t) for t in translations]\n        save_summaries(summaries, args.summaries_output_dir, batch.document_names)\n\n        if args.compute_rouge:\n            reference_summaries += batch.tgt_str\n            generated_summaries += summaries\n\n    if args.compute_rouge:\n        scores = rouge_evaluator.get_scores(generated_summaries, reference_summaries)\n        str_scores = format_rouge_scores(scores)\n        save_rouge_scores(str_scores)\n        print(str_scores)\n\n\ndef save_summaries(summaries, path, original_document_name):\n    \"\"\"Write the summaries in fies that are prefixed by the original\n    files' name with the `_summary` appended.\n\n    Attributes:\n        original_document_names: List[string]\n            Name of the document that was summarized.\n        path: string\n            Path were the summaries will be written\n        summaries: List[string]\n            The summaries that we produced.\n    \"\"\"\n    for summary, document_name in zip(summaries, original_document_name):\n        # Prepare the summary file's name\n        if \".\" in document_name:\n            bare_document_name = \".\".join(document_name.split(\".\")[:-1])\n            extension = document_name.split(\".\")[-1]\n            name = bare_document_name + \"_summary.\" + extension\n        else:\n            name = document_name + \"_summary\"\n\n        file_path = os.path.join(path, name)\n        with open(file_path, \"w\") as output:\n            output.write(summary)\n\n\ndef format_summary(translation):\n    \"\"\"Transforms the output of the `from_batch` function\n    into nicely formatted summaries.\n    \"\"\"\n    raw_summary, _, _ = translation\n    summary = (\n        raw_summary.replace(\"[unused0]\", \"\")\n        .replace(\"[unused3]\", \"\")\n        .replace(\"[PAD]\", \"\")\n        .replace(\"[unused1]\", \"\")\n        .replace(r\" +\", \" \")\n        .replace(\" [unused2] \", \". \")\n        .replace(\"[unused2]\", \"\")\n        .strip()\n    )\n\n    return summary\n\n\ndef format_rouge_scores(scores):\n    return \"\"\"\\n\n****** ROUGE SCORES ******\n\n** ROUGE 1\nF1        >> {:.3f}\nPrecision >> {:.3f}\nRecall    >> {:.3f}\n\n** ROUGE 2\nF1        >> {:.3f}\nPrecision >> {:.3f}\nRecall    >> {:.3f}\n\n** ROUGE L\nF1        >> {:.3f}\nPrecision >> {:.3f}\nRecall    >> {:.3f}\"\"\".format(\n        scores[\"rouge-1\"][\"f\"],\n        scores[\"rouge-1\"][\"p\"],\n        scores[\"rouge-1\"][\"r\"],\n        scores[\"rouge-2\"][\"f\"],\n        scores[\"rouge-2\"][\"p\"],\n        scores[\"rouge-2\"][\"r\"],\n        scores[\"rouge-l\"][\"f\"],\n        scores[\"rouge-l\"][\"p\"],\n        scores[\"rouge-l\"][\"r\"],\n    )\n\n\ndef save_rouge_scores(str_scores):\n    with open(\"rouge_scores.txt\", \"w\") as output:\n        output.write(str_scores)\n\n\n#\n# LOAD the dataset\n#\n\n\ndef build_data_iterator(args, tokenizer):\n    dataset = load_and_cache_examples(args, tokenizer)\n    sampler = SequentialSampler(dataset)\n\n    def collate_fn(data):\n        return collate(data, tokenizer, block_size=512, device=args.device)\n\n    iterator = DataLoader(\n        dataset,\n        sampler=sampler,\n        batch_size=args.batch_size,\n        collate_fn=collate_fn,\n    )\n\n    return iterator\n\n\ndef load_and_cache_examples(args, tokenizer):\n    dataset = CNNDMDataset(args.documents_dir)\n    return dataset\n\n\ndef collate(data, tokenizer, block_size, device):\n    \"\"\"Collate formats the data passed to the data loader.\n\n    In particular we tokenize the data batch after batch to avoid keeping them\n    all in memory. We output the data as a namedtuple to fit the original BertAbs's\n    API.\n    \"\"\"\n    data = [x for x in data if not len(x[1]) == 0]  # remove empty_files\n    names = [name for name, _, _ in data]\n    summaries = [\" \".join(summary_list) for _, _, summary_list in data]\n\n    encoded_text = [encode_for_summarization(story, summary, tokenizer) for _, story, summary in data]\n    encoded_stories = torch.tensor(\n        [truncate_or_pad(story, block_size, tokenizer.pad_token_id) for story, _ in encoded_text]\n    )\n    encoder_token_type_ids = compute_token_type_ids(encoded_stories, tokenizer.cls_token_id)\n    encoder_mask = build_mask(encoded_stories, tokenizer.pad_token_id)\n\n    batch = Batch(\n        document_names=names,\n        batch_size=len(encoded_stories),\n        src=encoded_stories.to(device),\n        segs=encoder_token_type_ids.to(device),\n        mask_src=encoder_mask.to(device),\n        tgt_str=summaries,\n    )\n\n    return batch\n\n\ndef decode_summary(summary_tokens, tokenizer):\n    \"\"\"Decode the summary and return it in a format\n    suitable for evaluation.\n    \"\"\"\n    summary_tokens = summary_tokens.to(\"cpu\").numpy()\n    summary = tokenizer.decode(summary_tokens)\n    sentences = summary.split(\".\")\n    sentences = [s + \".\" for s in sentences]\n    return sentences\n\n\ndef main():\n    \"\"\"The main function defines the interface with the users.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--documents_dir\",\n        default=None,\n        type=str,\n        required=True,\n        help=\"The folder where the documents to summarize are located.\",\n    )\n    parser.add_argument(\n        \"--summaries_output_dir\",\n        default=None,\n        type=str,\n        required=False,\n        help=\"The folder in wich the summaries should be written. Defaults to the folder where the documents are\",\n    )\n    parser.add_argument(\n        \"--compute_rouge\",\n        default=False,\n        type=bool,\n        required=False,\n        help=\"Compute the ROUGE metrics during evaluation. Only available for the CNN/DailyMail dataset.\",\n    )\n    # EVALUATION options\n    parser.add_argument(\n        \"--no_cuda\",\n        default=False,\n        type=bool,\n        help=\"Whether to force the execution on CPU.\",\n    )\n    parser.add_argument(\n        \"--batch_size\",\n        default=4,\n        type=int,\n        help=\"Batch size per GPU/CPU for training.\",\n    )\n    # BEAM SEARCH arguments\n    parser.add_argument(\n        \"--min_length\",\n        default=50,\n        type=int,\n        help=\"Minimum number of tokens for the summaries.\",\n    )\n    parser.add_argument(\n        \"--max_length\",\n        default=200,\n        type=int,\n        help=\"Maixmum number of tokens for the summaries.\",\n    )\n    parser.add_argument(\n        \"--beam_size\",\n        default=5,\n        type=int,\n        help=\"The number of beams to start with for each example.\",\n    )\n    parser.add_argument(\n        \"--alpha\",\n        default=0.95,\n        type=float,\n        help=\"The value of alpha for the length penalty in the beam search.\",\n    )\n    parser.add_argument(\n        \"--block_trigram\",\n        default=True,\n        type=bool,\n        help=\"Whether to block the existence of repeating trigrams in the text generated by beam search.\",\n    )\n    args = parser.parse_args()\n\n    # Select device (distibuted not available)\n    args.device = torch.device(\"cuda\" if torch.cuda.is_available() and not args.no_cuda else \"cpu\")\n\n    # Check the existence of directories\n    if not args.summaries_output_dir:\n        args.summaries_output_dir = args.documents_dir\n\n    if not documents_dir_is_valid(args.documents_dir):\n        raise FileNotFoundError(\n            \"We could not find the directory you specified for the documents to summarize, or it was empty. Please\"\n            \" specify a valid path.\"\n        )\n    os.makedirs(args.summaries_output_dir, exist_ok=True)\n\n    evaluate(args)\n\n\ndef documents_dir_is_valid(path):\n    if not os.path.exists(path):\n        return False\n\n    file_list = os.listdir(path)\n    if len(file_list) == 0:\n        return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    main()\n", "file_name": "884804.py", "cwe": ["CWE-676: Use of Potentially Dangerous Function"]}
{"source": "#!/usr/bin/env python3\n\nimport os\nimport shutil\nimport sys\nfrom pathlib import Path\nfrom subprocess import check_call\nfrom tempfile import TemporaryDirectory\nfrom typing import Optional\n\n\nSCRIPT_DIR = Path(__file__).parent\nREPO_DIR = SCRIPT_DIR.parent.parent\n\n\ndef read_triton_pin(device: str = \"cuda\") -> str:\n    triton_file = \"triton.txt\"\n    if device == \"rocm\":\n        triton_file = \"triton-rocm.txt\"\n    elif device == \"xpu\":\n        triton_file = \"triton-xpu.txt\"\n    with open(REPO_DIR / \".ci\" / \"docker\" / \"ci_commit_pins\" / triton_file) as f:\n        return f.read().strip()\n\n\ndef read_triton_version() -> str:\n    with open(REPO_DIR / \".ci\" / \"docker\" / \"triton_version.txt\") as f:\n        return f.read().strip()\n\n\ndef check_and_replace(inp: str, src: str, dst: str) -> str:\n    \"\"\"Checks that `src` can be found in `input` and replaces it with `dst`\"\"\"\n    if src not in inp:\n        raise RuntimeError(f\"Can't find ${src} in the input\")\n    return inp.replace(src, dst)\n\n\ndef patch_init_py(\n    path: Path, *, version: str, expected_version: Optional[str] = None\n) -> None:\n    if not expected_version:\n        expected_version = read_triton_version()\n    with open(path) as f:\n        orig = f.read()\n    # Replace version\n    orig = check_and_replace(\n        orig, f\"__version__ = '{expected_version}'\", f'__version__ = \"{version}\"'\n    )\n    with open(path, \"w\") as f:\n        f.write(orig)\n\n\n# TODO: remove patch_setup_py() once we have a proper fix for https://github.com/triton-lang/triton/issues/4527\ndef patch_setup_py(path: Path) -> None:\n    with open(path) as f:\n        orig = f.read()\n    orig = check_and_replace(\n        orig,\n        \"https://tritonlang.blob.core.windows.net/llvm-builds/\",\n        \"https://oaitriton.blob.core.windows.net/public/llvm-builds/\",\n    )\n    with open(path, \"w\") as f:\n        f.write(orig)\n\n\ndef build_triton(\n    *,\n    version: str,\n    commit_hash: str,\n    build_conda: bool = False,\n    device: str = \"cuda\",\n    py_version: Optional[str] = None,\n    release: bool = False,\n) -> Path:\n    env = os.environ.copy()\n    if \"MAX_JOBS\" not in env:\n        max_jobs = os.cpu_count() or 1\n        env[\"MAX_JOBS\"] = str(max_jobs)\n\n    version_suffix = \"\"\n    if not release:\n        # Nightly binaries include the triton commit hash, i.e. 2.1.0+e6216047b8\n        # while release build should only include the version, i.e. 2.1.0\n        version_suffix = f\"+{commit_hash[:10]}\"\n        version += version_suffix\n\n    with TemporaryDirectory() as tmpdir:\n        triton_basedir = Path(tmpdir) / \"triton\"\n        triton_pythondir = triton_basedir / \"python\"\n        triton_repo = \"https://github.com/openai/triton\"\n        if device == \"rocm\":\n            triton_pkg_name = \"pytorch-triton-rocm\"\n        elif device == \"xpu\":\n            triton_pkg_name = \"pytorch-triton-xpu\"\n            triton_repo = \"https://github.com/intel/intel-xpu-backend-for-triton\"\n        else:\n            triton_pkg_name = \"pytorch-triton\"\n        check_call([\"git\", \"clone\", triton_repo, \"triton\"], cwd=tmpdir)\n        if release:\n            ver, rev, patch = version.split(\".\")\n            check_call(\n                [\"git\", \"checkout\", f\"release/{ver}.{rev}.x\"], cwd=triton_basedir\n            )\n        else:\n            check_call([\"git\", \"checkout\", commit_hash], cwd=triton_basedir)\n\n        # TODO: remove this and patch_setup_py() once we have a proper fix for https://github.com/triton-lang/triton/issues/4527\n        patch_setup_py(triton_pythondir / \"setup.py\")\n\n        if build_conda:\n            with open(triton_basedir / \"meta.yaml\", \"w\") as meta:\n                print(\n                    f\"package:\\n  name: torchtriton\\n  version: {version}\\n\",\n                    file=meta,\n                )\n                print(\"source:\\n  path: .\\n\", file=meta)\n                print(\n                    \"build:\\n  string: py{{py}}\\n  number: 1\\n  script: cd python; \"\n                    \"python setup.py install --record=record.txt\\n\",\n                    \" script_env:\\n   - MAX_JOBS\\n\",\n                    file=meta,\n                )\n                print(\n                    \"requirements:\\n  host:\\n    - python\\n    - setuptools\\n  run:\\n    - python\\n\"\n                    \"    - filelock\\n    - pytorch\\n\",\n                    file=meta,\n                )\n                print(\n                    \"about:\\n  home: https://github.com/openai/triton\\n  license: MIT\\n  summary:\"\n                    \" 'A language and compiler for custom Deep Learning operation'\",\n                    file=meta,\n                )\n\n            patch_init_py(\n                triton_pythondir / \"triton\" / \"__init__.py\",\n                version=f\"{version}\",\n            )\n            if py_version is None:\n                py_version = f\"{sys.version_info.major}.{sys.version_info.minor}\"\n            check_call(\n                [\n                    \"conda\",\n                    \"build\",\n                    \"--python\",\n                    py_version,\n                    \"-c\",\n                    \"pytorch-nightly\",\n                    \"--output-folder\",\n                    tmpdir,\n                    \".\",\n                ],\n                cwd=triton_basedir,\n                env=env,\n            )\n            conda_path = next(iter(Path(tmpdir).glob(\"linux-64/torchtriton*.bz2\")))\n            shutil.copy(conda_path, Path.cwd())\n            return Path.cwd() / conda_path.name\n\n        # change built wheel name and version\n        env[\"TRITON_WHEEL_NAME\"] = triton_pkg_name\n        env[\"TRITON_WHEEL_VERSION_SUFFIX\"] = version_suffix\n        patch_init_py(\n            triton_pythondir / \"triton\" / \"__init__.py\",\n            version=f\"{version}\",\n            expected_version=None,\n        )\n\n        if device == \"rocm\":\n            check_call(\n                [f\"{SCRIPT_DIR}/amd/package_triton_wheel.sh\"],\n                cwd=triton_basedir,\n                shell=True,\n            )\n            print(\"ROCm libraries setup for triton installation...\")\n\n        check_call(\n            [sys.executable, \"setup.py\", \"bdist_wheel\"], cwd=triton_pythondir, env=env\n        )\n\n        whl_path = next(iter((triton_pythondir / \"dist\").glob(\"*.whl\")))\n        shutil.copy(whl_path, Path.cwd())\n\n        if device == \"rocm\":\n            check_call(\n                [f\"{SCRIPT_DIR}/amd/patch_triton_wheel.sh\", Path.cwd()],\n                cwd=triton_basedir,\n            )\n\n        return Path.cwd() / whl_path.name\n\n\ndef main() -> None:\n    from argparse import ArgumentParser\n\n    parser = ArgumentParser(\"Build Triton binaries\")\n    parser.add_argument(\"--release\", action=\"store_true\")\n    parser.add_argument(\"--build-conda\", action=\"store_true\")\n    parser.add_argument(\n        \"--device\", type=str, default=\"cuda\", choices=[\"cuda\", \"rocm\", \"xpu\"]\n    )\n    parser.add_argument(\"--py-version\", type=str)\n    parser.add_argument(\"--commit-hash\", type=str)\n    parser.add_argument(\"--triton-version\", type=str, default=read_triton_version())\n    args = parser.parse_args()\n\n    build_triton(\n        device=args.device,\n        commit_hash=args.commit_hash\n        if args.commit_hash\n        else read_triton_pin(args.device),\n        version=args.triton_version,\n        build_conda=args.build_conda,\n        py_version=args.py_version,\n        release=args.release,\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n", "file_name": "879024.py", "cwe": ["CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"]}
{"source": "#!/usr/bin/env python3\n\nimport os\nimport sys\nfrom dataclasses import asdict, dataclass, field\nfrom pathlib import Path\nfrom typing import Dict, Iterable, List, Literal, Set\nfrom typing_extensions import TypedDict  # Python 3.11+\n\nimport generate_binary_build_matrix  # type: ignore[import]\nimport jinja2\n\n\nArch = Literal[\"windows\", \"linux\", \"macos\"]\n\nGITHUB_DIR = Path(__file__).resolve().parent.parent\n\nLABEL_CIFLOW_TRUNK = \"ciflow/trunk\"\nLABEL_CIFLOW_UNSTABLE = \"ciflow/unstable\"\nLABEL_CIFLOW_BINARIES = \"ciflow/binaries\"\nLABEL_CIFLOW_PERIODIC = \"ciflow/periodic\"\nLABEL_CIFLOW_BINARIES_LIBTORCH = \"ciflow/binaries_libtorch\"\nLABEL_CIFLOW_BINARIES_CONDA = \"ciflow/binaries_conda\"\nLABEL_CIFLOW_BINARIES_WHEEL = \"ciflow/binaries_wheel\"\n\n\n@dataclass\nclass CIFlowConfig:\n    # For use to enable workflows to run on pytorch/pytorch-canary\n    run_on_canary: bool = False\n    labels: Set[str] = field(default_factory=set)\n    # Certain jobs might not want to be part of the ciflow/[all,trunk] workflow\n    isolated_workflow: bool = False\n    unstable: bool = False\n\n    def __post_init__(self) -> None:\n        if not self.isolated_workflow:\n            if LABEL_CIFLOW_PERIODIC not in self.labels:\n                self.labels.add(\n                    LABEL_CIFLOW_TRUNK if not self.unstable else LABEL_CIFLOW_UNSTABLE\n                )\n\n\nclass Config(TypedDict):\n    num_shards: int\n    runner: str\n\n\n@dataclass\nclass BinaryBuildWorkflow:\n    os: str\n    build_configs: List[Dict[str, str]]\n    package_type: str\n\n    # Optional fields\n    build_environment: str = \"\"\n    abi_version: str = \"\"\n    ciflow_config: CIFlowConfig = field(default_factory=CIFlowConfig)\n    is_scheduled: str = \"\"\n    branches: str = \"nightly\"\n    # Mainly for macos\n    cross_compile_arm64: bool = False\n    macos_runner: str = \"macos-14-xlarge\"\n\n    def __post_init__(self) -> None:\n        if self.abi_version:\n            self.build_environment = (\n                f\"{self.os}-binary-{self.package_type}-{self.abi_version}\"\n            )\n        else:\n            self.build_environment = f\"{self.os}-binary-{self.package_type}\"\n\n    def generate_workflow_file(self, workflow_template: jinja2.Template) -> None:\n        output_file_path = (\n            GITHUB_DIR\n            / f\"workflows/generated-{self.build_environment}-{self.branches}.yml\"\n        )\n        with open(output_file_path, \"w\") as output_file:\n            GENERATED = \"generated\"  # Note that please keep the variable GENERATED otherwise phabricator will hide the whole file\n            output_file.writelines([f\"# @{GENERATED} DO NOT EDIT MANUALLY\\n\"])\n            try:\n                content = workflow_template.render(asdict(self))\n            except Exception as e:\n                print(f\"Failed on template: {workflow_template}\", file=sys.stderr)\n                raise e\n            output_file.write(content)\n            if content[-1] != \"\\n\":\n                output_file.write(\"\\n\")\n        print(output_file_path)\n\n\nclass OperatingSystem:\n    LINUX = \"linux\"\n    WINDOWS = \"windows\"\n    MACOS = \"macos\"\n    MACOS_ARM64 = \"macos-arm64\"\n    LINUX_AARCH64 = \"linux-aarch64\"\n    LINUX_S390X = \"linux-s390x\"\n\n\nLINUX_BINARY_BUILD_WORFKLOWS = [\n    BinaryBuildWorkflow(\n        os=OperatingSystem.LINUX,\n        package_type=\"manywheel\",\n        build_configs=generate_binary_build_matrix.generate_wheels_matrix(\n            OperatingSystem.LINUX\n        ),\n        ciflow_config=CIFlowConfig(\n            labels={LABEL_CIFLOW_BINARIES, LABEL_CIFLOW_BINARIES_WHEEL},\n            isolated_workflow=True,\n        ),\n    ),\n    BinaryBuildWorkflow(\n        os=OperatingSystem.LINUX,\n        package_type=\"conda\",\n        build_configs=generate_binary_build_matrix.generate_conda_matrix(\n            OperatingSystem.LINUX\n        ),\n        ciflow_config=CIFlowConfig(\n            labels={LABEL_CIFLOW_BINARIES, LABEL_CIFLOW_BINARIES_CONDA},\n            isolated_workflow=True,\n        ),\n    ),\n    BinaryBuildWorkflow(\n        os=OperatingSystem.LINUX,\n        package_type=\"libtorch\",\n        abi_version=generate_binary_build_matrix.CXX11_ABI,\n        build_configs=generate_binary_build_matrix.generate_libtorch_matrix(\n            OperatingSystem.LINUX,\n            generate_binary_build_matrix.CXX11_ABI,\n            libtorch_variants=[\"shared-with-deps\"],\n        ),\n        ciflow_config=CIFlowConfig(\n            labels={LABEL_CIFLOW_BINARIES, LABEL_CIFLOW_BINARIES_LIBTORCH},\n            isolated_workflow=True,\n        ),\n    ),\n    BinaryBuildWorkflow(\n        os=OperatingSystem.LINUX,\n        package_type=\"libtorch\",\n        abi_version=generate_binary_build_matrix.PRE_CXX11_ABI,\n        build_configs=generate_binary_build_matrix.generate_libtorch_matrix(\n            OperatingSystem.LINUX,\n            generate_binary_build_matrix.PRE_CXX11_ABI,\n            libtorch_variants=[\"shared-with-deps\"],\n        ),\n        ciflow_config=CIFlowConfig(\n            labels={LABEL_CIFLOW_BINARIES, LABEL_CIFLOW_BINARIES_LIBTORCH},\n            isolated_workflow=True,\n        ),\n    ),\n]\n\nLINUX_BINARY_SMOKE_WORKFLOWS = [\n    BinaryBuildWorkflow(\n        os=OperatingSystem.LINUX,\n        package_type=\"manywheel\",\n        build_configs=generate_binary_build_matrix.generate_wheels_matrix(\n            OperatingSystem.LINUX,\n            arches=[\"11.8\", \"12.1\", \"12.4\"],\n            python_versions=[\"3.9\"],\n        ),\n        branches=\"main\",\n    ),\n    BinaryBuildWorkflow(\n        os=OperatingSystem.LINUX,\n        package_type=\"libtorch\",\n        abi_version=generate_binary_build_matrix.CXX11_ABI,\n        build_configs=generate_binary_build_matrix.generate_libtorch_matrix(\n            OperatingSystem.LINUX,\n            generate_binary_build_matrix.CXX11_ABI,\n            arches=[\"cpu\"],\n            libtorch_variants=[\"shared-with-deps\"],\n        ),\n        branches=\"main\",\n    ),\n    BinaryBuildWorkflow(\n        os=OperatingSystem.LINUX,\n        package_type=\"libtorch\",\n        abi_version=generate_binary_build_matrix.PRE_CXX11_ABI,\n        build_configs=generate_binary_build_matrix.generate_libtorch_matrix(\n            OperatingSystem.LINUX,\n            generate_binary_build_matrix.PRE_CXX11_ABI,\n            arches=[\"cpu\"],\n            libtorch_variants=[\"shared-with-deps\"],\n        ),\n        branches=\"main\",\n    ),\n]\n\nWINDOWS_BINARY_BUILD_WORKFLOWS = [\n    BinaryBuildWorkflow(\n        os=OperatingSystem.WINDOWS,\n        package_type=\"wheel\",\n        build_configs=generate_binary_build_matrix.generate_wheels_matrix(\n            OperatingSystem.WINDOWS\n        ),\n        ciflow_config=CIFlowConfig(\n            labels={LABEL_CIFLOW_BINARIES, LABEL_CIFLOW_BINARIES_WHEEL},\n            isolated_workflow=True,\n        ),\n    ),\n    BinaryBuildWorkflow(\n        os=OperatingSystem.WINDOWS,\n        package_type=\"conda\",\n        build_configs=generate_binary_build_matrix.generate_conda_matrix(\n            OperatingSystem.WINDOWS\n        ),\n        ciflow_config=CIFlowConfig(\n            labels={LABEL_CIFLOW_BINARIES, LABEL_CIFLOW_BINARIES_CONDA},\n            isolated_workflow=True,\n        ),\n    ),\n    BinaryBuildWorkflow(\n        os=OperatingSystem.WINDOWS,\n        package_type=\"libtorch\",\n        abi_version=generate_binary_build_matrix.RELEASE,\n        build_configs=generate_binary_build_matrix.generate_libtorch_matrix(\n            OperatingSystem.WINDOWS,\n            generate_binary_build_matrix.RELEASE,\n            libtorch_variants=[\"shared-with-deps\"],\n        ),\n        ciflow_config=CIFlowConfig(\n            labels={LABEL_CIFLOW_BINARIES, LABEL_CIFLOW_BINARIES_LIBTORCH},\n            isolated_workflow=True,\n        ),\n    ),\n    BinaryBuildWorkflow(\n        os=OperatingSystem.WINDOWS,\n        package_type=\"libtorch\",\n        abi_version=generate_binary_build_matrix.DEBUG,\n        build_configs=generate_binary_build_matrix.generate_libtorch_matrix(\n            OperatingSystem.WINDOWS,\n            generate_binary_build_matrix.DEBUG,\n            libtorch_variants=[\"shared-with-deps\"],\n        ),\n        ciflow_config=CIFlowConfig(\n            labels={LABEL_CIFLOW_BINARIES, LABEL_CIFLOW_BINARIES_LIBTORCH},\n            isolated_workflow=True,\n        ),\n    ),\n]\n\nWINDOWS_BINARY_SMOKE_WORKFLOWS = [\n    BinaryBuildWorkflow(\n        os=OperatingSystem.WINDOWS,\n        package_type=\"libtorch\",\n        abi_version=generate_binary_build_matrix.RELEASE,\n        build_configs=generate_binary_build_matrix.generate_libtorch_matrix(\n            OperatingSystem.WINDOWS,\n            generate_binary_build_matrix.RELEASE,\n            arches=[\"cpu\"],\n            libtorch_variants=[\"shared-with-deps\"],\n        ),\n        branches=\"main\",\n        ciflow_config=CIFlowConfig(\n            isolated_workflow=True,\n        ),\n    ),\n    BinaryBuildWorkflow(\n        os=OperatingSystem.WINDOWS,\n        package_type=\"libtorch\",\n        abi_version=generate_binary_build_matrix.DEBUG,\n        build_configs=generate_binary_build_matrix.generate_libtorch_matrix(\n            OperatingSystem.WINDOWS,\n            generate_binary_build_matrix.DEBUG,\n            arches=[\"cpu\"],\n            libtorch_variants=[\"shared-with-deps\"],\n        ),\n        branches=\"main\",\n        ciflow_config=CIFlowConfig(\n            isolated_workflow=True,\n        ),\n    ),\n]\n\nMACOS_BINARY_BUILD_WORKFLOWS = [\n    BinaryBuildWorkflow(\n        os=OperatingSystem.MACOS_ARM64,\n        package_type=\"libtorch\",\n        abi_version=generate_binary_build_matrix.CXX11_ABI,\n        build_configs=generate_binary_build_matrix.generate_libtorch_matrix(\n            OperatingSystem.MACOS,\n            generate_binary_build_matrix.CXX11_ABI,\n            libtorch_variants=[\"shared-with-deps\"],\n        ),\n        cross_compile_arm64=False,\n        macos_runner=\"macos-14-xlarge\",\n        ciflow_config=CIFlowConfig(\n            labels={LABEL_CIFLOW_BINARIES, LABEL_CIFLOW_BINARIES_LIBTORCH},\n            isolated_workflow=True,\n        ),\n    ),\n    BinaryBuildWorkflow(\n        os=OperatingSystem.MACOS_ARM64,\n        package_type=\"wheel\",\n        build_configs=generate_binary_build_matrix.generate_wheels_matrix(\n            OperatingSystem.MACOS_ARM64\n        ),\n        cross_compile_arm64=False,\n        macos_runner=\"macos-14-xlarge\",\n        ciflow_config=CIFlowConfig(\n            labels={LABEL_CIFLOW_BINARIES, LABEL_CIFLOW_BINARIES_WHEEL},\n            isolated_workflow=True,\n        ),\n    ),\n    BinaryBuildWorkflow(\n        os=OperatingSystem.MACOS_ARM64,\n        package_type=\"conda\",\n        cross_compile_arm64=False,\n        macos_runner=\"macos-14-xlarge\",\n        build_configs=generate_binary_build_matrix.generate_conda_matrix(\n            OperatingSystem.MACOS_ARM64\n        ),\n        ciflow_config=CIFlowConfig(\n            labels={LABEL_CIFLOW_BINARIES, LABEL_CIFLOW_BINARIES_CONDA},\n            isolated_workflow=True,\n        ),\n    ),\n]\n\nAARCH64_BINARY_BUILD_WORKFLOWS = [\n    BinaryBuildWorkflow(\n        os=OperatingSystem.LINUX_AARCH64,\n        package_type=\"manywheel\",\n        build_configs=generate_binary_build_matrix.generate_wheels_matrix(\n            OperatingSystem.LINUX_AARCH64\n        ),\n        ciflow_config=CIFlowConfig(\n            labels={LABEL_CIFLOW_BINARIES, LABEL_CIFLOW_BINARIES_WHEEL},\n            isolated_workflow=True,\n        ),\n    ),\n]\n\nS390X_BINARY_BUILD_WORKFLOWS = [\n    BinaryBuildWorkflow(\n        os=OperatingSystem.LINUX_S390X,\n        package_type=\"manywheel\",\n        build_configs=generate_binary_build_matrix.generate_wheels_matrix(\n            OperatingSystem.LINUX_S390X\n        ),\n        ciflow_config=CIFlowConfig(\n            labels={LABEL_CIFLOW_BINARIES, LABEL_CIFLOW_BINARIES_WHEEL},\n            isolated_workflow=True,\n        ),\n    ),\n]\n\n\ndef main() -> None:\n    jinja_env = jinja2.Environment(\n        variable_start_string=\"!{{\",\n        loader=jinja2.FileSystemLoader(str(GITHUB_DIR.joinpath(\"templates\"))),\n        undefined=jinja2.StrictUndefined,\n    )\n\n    # not ported yet\n    template_and_workflows = [\n        (\n            jinja_env.get_template(\"linux_binary_build_workflow.yml.j2\"),\n            LINUX_BINARY_BUILD_WORFKLOWS,\n        ),\n        (\n            jinja_env.get_template(\"linux_binary_build_workflow.yml.j2\"),\n            AARCH64_BINARY_BUILD_WORKFLOWS,\n        ),\n        (\n            jinja_env.get_template(\"linux_binary_build_workflow.yml.j2\"),\n            S390X_BINARY_BUILD_WORKFLOWS,\n        ),\n        (\n            jinja_env.get_template(\"linux_binary_build_workflow.yml.j2\"),\n            LINUX_BINARY_SMOKE_WORKFLOWS,\n        ),\n        (\n            jinja_env.get_template(\"windows_binary_build_workflow.yml.j2\"),\n            WINDOWS_BINARY_BUILD_WORKFLOWS,\n        ),\n        (\n            jinja_env.get_template(\"windows_binary_build_workflow.yml.j2\"),\n            WINDOWS_BINARY_SMOKE_WORKFLOWS,\n        ),\n        (\n            jinja_env.get_template(\"macos_binary_build_workflow.yml.j2\"),\n            MACOS_BINARY_BUILD_WORKFLOWS,\n        ),\n    ]\n    # Delete the existing generated files first, this should align with .gitattributes file description.\n    existing_workflows = GITHUB_DIR.glob(\"workflows/generated-*\")\n    for w in existing_workflows:\n        try:\n            os.remove(w)\n        except Exception as e:\n            print(f\"Error occurred when deleting file {w}: {e}\")\n\n    for template, workflows in template_and_workflows:\n        # added Iterable check to appease the mypy gods\n        if not isinstance(workflows, Iterable):\n            raise Exception(  # noqa: TRY002\n                f\"How is workflows not iterable? {workflows}\"\n            )  # noqa: TRY002\n        for workflow in workflows:\n            workflow.generate_workflow_file(workflow_template=template)\n\n\nif __name__ == \"__main__\":\n    main()\n", "file_name": "938702.py", "cwe": ["CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"]}
{"source": "# Helper to get the id of the currently running job in a GitHub Actions\n# workflow. GitHub does not provide this information to workflow runs, so we\n# need to figure it out based on what they *do* provide.\n\nimport argparse\nimport json\nimport operator\nimport os\nimport re\nimport sys\nimport time\nimport urllib\nimport urllib.parse\nfrom typing import Any, Callable, Dict, List, Optional, Tuple\nfrom urllib.request import Request, urlopen\n\n\ndef parse_json_and_links(conn: Any) -> Tuple[Any, Dict[str, Dict[str, str]]]:\n    links = {}\n    # Extract links which GH uses for pagination\n    # see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Link\n    if \"Link\" in conn.headers:\n        for elem in re.split(\", *<\", conn.headers[\"Link\"]):\n            try:\n                url, params_ = elem.split(\";\", 1)\n            except ValueError:\n                continue\n            url = urllib.parse.unquote(url.strip(\"<> \"))\n            qparams = urllib.parse.parse_qs(params_.strip(), separator=\";\")\n            params = {\n                k: v[0].strip('\"')\n                for k, v in qparams.items()\n                if type(v) is list and len(v) > 0\n            }\n            params[\"url\"] = url\n            if \"rel\" in params:\n                links[params[\"rel\"]] = params\n\n    return json.load(conn), links\n\n\ndef fetch_url(\n    url: str,\n    *,\n    headers: Optional[Dict[str, str]] = None,\n    reader: Callable[[Any], Any] = lambda x: x.read(),\n    retries: Optional[int] = 3,\n    backoff_timeout: float = 0.5,\n) -> Any:\n    if headers is None:\n        headers = {}\n    try:\n        with urlopen(Request(url, headers=headers)) as conn:\n            return reader(conn)\n    except urllib.error.HTTPError as err:\n        if isinstance(retries, (int, float)) and retries > 0:\n            time.sleep(backoff_timeout)\n            return fetch_url(\n                url,\n                headers=headers,\n                reader=reader,\n                retries=retries - 1,\n                backoff_timeout=backoff_timeout,\n            )\n        exception_message = (\n            \"Is github alright?\",\n            f\"Recieved status code '{err.code}' when attempting to retrieve {url}:\\n\",\n            f\"{err.reason}\\n\\nheaders={err.headers}\",\n        )\n        raise RuntimeError(exception_message) from err\n\n\ndef parse_args() -> Any:\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"workflow_run_id\", help=\"The id of the workflow run, should be GITHUB_RUN_ID\"\n    )\n    parser.add_argument(\n        \"runner_name\",\n        help=\"The name of the runner to retrieve the job id, should be RUNNER_NAME\",\n    )\n\n    return parser.parse_args()\n\n\ndef fetch_jobs(url: str, headers: Dict[str, str]) -> List[Dict[str, str]]:\n    response, links = fetch_url(url, headers=headers, reader=parse_json_and_links)\n    jobs = response[\"jobs\"]\n    assert type(jobs) is list\n    while \"next\" in links.keys():\n        response, links = fetch_url(\n            links[\"next\"][\"url\"], headers=headers, reader=parse_json_and_links\n        )\n        jobs.extend(response[\"jobs\"])\n\n    return jobs\n\n\n# Our strategy is to retrieve the parent workflow run, then filter its jobs on\n# RUNNER_NAME to figure out which job we're currently running.\n#\n# Why RUNNER_NAME? Because it's the only thing that uniquely identifies a job within a workflow.\n# GITHUB_JOB doesn't work, as it corresponds to the job yaml id\n# (https://bit.ly/37e78oI), which has two problems:\n# 1. It's not present in the workflow job JSON object, so we can't use it as a filter.\n# 2. It isn't unique; for matrix jobs the job yaml id is the same for all jobs in the matrix.\n#\n# RUNNER_NAME on the other hand is unique across the pool of runners. Also,\n# since only one job can be scheduled on a runner at a time, we know that\n# looking for RUNNER_NAME will uniquely identify the job we're currently\n# running.\n\n\ndef find_job_id_name(args: Any) -> Tuple[str, str]:\n    # From https://docs.github.com/en/actions/learn-github-actions/environment-variables\n    PYTORCH_REPO = os.environ.get(\"GITHUB_REPOSITORY\", \"pytorch/pytorch\")\n    PYTORCH_GITHUB_API = f\"https://api.github.com/repos/{PYTORCH_REPO}\"\n    GITHUB_TOKEN = os.environ[\"GITHUB_TOKEN\"]\n    REQUEST_HEADERS = {\n        \"Accept\": \"application/vnd.github.v3+json\",\n        \"Authorization\": \"token \" + GITHUB_TOKEN,\n    }\n\n    url = f\"{PYTORCH_GITHUB_API}/actions/runs/{args.workflow_run_id}/jobs?per_page=100\"\n    jobs = fetch_jobs(url, REQUEST_HEADERS)\n\n    # Sort the jobs list by start time, in descending order. We want to get the most\n    # recently scheduled job on the runner.\n    jobs.sort(key=operator.itemgetter(\"started_at\"), reverse=True)\n\n    for job in jobs:\n        if job[\"runner_name\"] == args.runner_name:\n            return (job[\"id\"], job[\"name\"])\n\n    raise RuntimeError(f\"Can't find job id for runner {args.runner_name}\")\n\n\ndef set_output(name: str, val: Any) -> None:\n    if os.getenv(\"GITHUB_OUTPUT\"):\n        with open(str(os.getenv(\"GITHUB_OUTPUT\")), \"a\") as env:\n            print(f\"{name}={val}\", file=env)\n        print(f\"setting {name}={val}\")\n    else:\n        print(f\"::set-output name={name}::{val}\")\n\n\ndef main() -> None:\n    args = parse_args()\n    try:\n        # Get both the job ID and job name because we have already spent a request\n        # here to get the job info\n        job_id, job_name = find_job_id_name(args)\n        set_output(\"job-id\", job_id)\n        set_output(\"job-name\", job_name)\n    except Exception as e:\n        print(repr(e), file=sys.stderr)\n        print(f\"workflow-{args.workflow_run_id}\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "file_name": "948858.py", "cwe": ["CWE-939: Improper Authorization in Handler for Custom URL Scheme"]}
{"source": "import hashlib\nimport time\nimport urllib\nimport uuid\n\nfrom .common import InfoExtractor\nfrom .openload import PhantomJSwrapper\nfrom ..utils import (\n    ExtractorError,\n    UserNotLive,\n    determine_ext,\n    int_or_none,\n    js_to_json,\n    parse_resolution,\n    str_or_none,\n    traverse_obj,\n    unescapeHTML,\n    url_or_none,\n    urlencode_postdata,\n    urljoin,\n)\n\n\nclass DouyuBaseIE(InfoExtractor):\n    def _download_cryptojs_md5(self, video_id):\n        for url in [\n            # XXX: Do NOT use cdn.bootcdn.net; ref: https://sansec.io/research/polyfill-supply-chain-attack\n            'https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/md5.js',\n            'https://unpkg.com/cryptojslib@3.1.2/rollups/md5.js',\n        ]:\n            js_code = self._download_webpage(\n                url, video_id, note='Downloading signing dependency', fatal=False)\n            if js_code:\n                self.cache.store('douyu', 'crypto-js-md5', js_code)\n                return js_code\n        raise ExtractorError('Unable to download JS dependency (crypto-js/md5)')\n\n    def _get_cryptojs_md5(self, video_id):\n        return self.cache.load(\n            'douyu', 'crypto-js-md5', min_ver='2024.07.04') or self._download_cryptojs_md5(video_id)\n\n    def _calc_sign(self, sign_func, video_id, a):\n        b = uuid.uuid4().hex\n        c = round(time.time())\n        js_script = f'{self._get_cryptojs_md5(video_id)};{sign_func};console.log(ub98484234(\"{a}\",\"{b}\",\"{c}\"))'\n        phantom = PhantomJSwrapper(self)\n        result = phantom.execute(js_script, video_id,\n                                 note='Executing JS signing script').strip()\n        return {i: v[0] for i, v in urllib.parse.parse_qs(result).items()}\n\n    def _search_js_sign_func(self, webpage, fatal=True):\n        # The greedy look-behind ensures last possible script tag is matched\n        return self._search_regex(\n            r'(?:<script.*)?<script[^>]*>(.*?ub98484234.*?)</script>', webpage, 'JS sign func', fatal=fatal)\n\n\nclass DouyuTVIE(DouyuBaseIE):\n    IE_DESC = '\u6597\u9c7c\u76f4\u64ad'\n    _VALID_URL = r'https?://(?:www\\.)?douyu(?:tv)?\\.com/(topic/\\w+\\?rid=|(?:[^/]+/))*(?P<id>[A-Za-z0-9]+)'\n    _TESTS = [{\n        'url': 'https://www.douyu.com/pigff',\n        'info_dict': {\n            'id': '24422',\n            'display_id': 'pigff',\n            'ext': 'mp4',\n            'title': 're:^\u3010PIGFF\u3011.* [0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}$',\n            'description': r'\u226515\u7ea7\u724c\u5b50\u770b\u9c7c\u5427\u7f6e\u9876\u5e16\u8fdb\u7c89\u4e1dvx\u7fa4',\n            'thumbnail': str,\n            'uploader': 'pigff',\n            'is_live': True,\n            'live_status': 'is_live',\n        },\n        'params': {\n            'skip_download': True,\n        },\n    }, {\n        'url': 'http://www.douyutv.com/85982',\n        'info_dict': {\n            'id': '85982',\n            'display_id': '85982',\n            'ext': 'flv',\n            'title': 're:^\u5c0f\u6f20\u4ece\u96f6\u5355\u6392\u8bb0\uff01\u2014\u2014CSOL2\u8eb2\u732b\u732b [0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}$',\n            'description': 'md5:746a2f7a253966a06755a912f0acc0d2',\n            'thumbnail': r're:^https?://.*\\.png',\n            'uploader': 'douyu\u5c0f\u6f20',\n            'is_live': True,\n        },\n        'params': {\n            'skip_download': True,\n        },\n        'skip': 'Room not found',\n    }, {\n        'url': 'http://www.douyutv.com/17732',\n        'info_dict': {\n            'id': '17732',\n            'display_id': '17732',\n            'ext': 'flv',\n            'title': 're:^\u6e05\u6668\u9192\u8111\uff01\u6839\u672c\u505c\u4e0d\u4e0b\u6765\uff01 [0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}$',\n            'description': r're:.*m7show@163\\.com.*',\n            'thumbnail': r're:^https?://.*\\.png',\n            'uploader': '7\u5e08\u5085',\n            'is_live': True,\n        },\n        'params': {\n            'skip_download': True,\n        },\n    }, {\n        'url': 'https://www.douyu.com/topic/ydxc?rid=6560603',\n        'info_dict': {\n            'id': '6560603',\n            'display_id': '6560603',\n            'ext': 'flv',\n            'title': 're:^\u963f\u4f59\uff1a\u65b0\u5e74\u5feb\u4e50\u606d\u559c\u53d1\u8d22\uff01 [0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}$',\n            'description': 're:.*\u76f4\u64ad\u65f6\u95f4.*',\n            'thumbnail': r're:^https?://.*\\.png',\n            'uploader': '\u963f\u6d9b\u768e\u6708Carry',\n            'live_status': 'is_live',\n        },\n        'params': {\n            'skip_download': True,\n        },\n    }, {\n        'url': 'http://www.douyu.com/xiaocang',\n        'only_matching': True,\n    }, {\n        # \\\"room_id\\\"\n        'url': 'http://www.douyu.com/t/lpl',\n        'only_matching': True,\n    }]\n\n    def _get_sign_func(self, room_id, video_id):\n        return self._download_json(\n            f'https://www.douyu.com/swf_api/homeH5Enc?rids={room_id}', video_id,\n            note='Getting signing script')['data'][f'room{room_id}']\n\n    def _extract_stream_formats(self, stream_formats):\n        formats = []\n        for stream_info in traverse_obj(stream_formats, (..., 'data')):\n            stream_url = urljoin(\n                traverse_obj(stream_info, 'rtmp_url'), traverse_obj(stream_info, 'rtmp_live'))\n            if stream_url:\n                rate_id = traverse_obj(stream_info, ('rate', {int_or_none}))\n                rate_info = traverse_obj(stream_info, ('multirates', lambda _, v: v['rate'] == rate_id), get_all=False)\n                ext = determine_ext(stream_url)\n                formats.append({\n                    'url': stream_url,\n                    'format_id': str_or_none(rate_id),\n                    'ext': 'mp4' if ext == 'm3u8' else ext,\n                    'protocol': 'm3u8_native' if ext == 'm3u8' else 'https',\n                    'quality': rate_id % -10000 if rate_id is not None else None,\n                    **traverse_obj(rate_info, {\n                        'format': ('name', {str_or_none}),\n                        'tbr': ('bit', {int_or_none}),\n                    }),\n                })\n        return formats\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id)\n        room_id = self._search_regex(r'\\$ROOM\\.room_id\\s*=\\s*(\\d+)', webpage, 'room id')\n\n        if self._search_regex(r'\"videoLoop\"\\s*:\\s*(\\d+)', webpage, 'loop', default='') == '1':\n            raise UserNotLive('The channel is auto-playing VODs', video_id=video_id)\n        if self._search_regex(r'\\$ROOM\\.show_status\\s*=\\s*(\\d+)', webpage, 'status', default='') == '2':\n            raise UserNotLive(video_id=video_id)\n\n        # Grab metadata from API\n        params = {\n            'aid': 'wp',\n            'client_sys': 'wp',\n            'time': int(time.time()),\n        }\n        params['auth'] = hashlib.md5(\n            f'room/{room_id}?{urllib.parse.urlencode(params)}zNzMV1y4EMxOHS6I5WKm'.encode()).hexdigest()\n        room = traverse_obj(self._download_json(\n            f'http://www.douyutv.com/api/v1/room/{room_id}', video_id,\n            note='Downloading room info', query=params, fatal=False), 'data')\n\n        # 1 = live, 2 = offline\n        if traverse_obj(room, 'show_status') == '2':\n            raise UserNotLive(video_id=video_id)\n\n        js_sign_func = self._search_js_sign_func(webpage, fatal=False) or self._get_sign_func(room_id, video_id)\n        form_data = {\n            'rate': 0,\n            **self._calc_sign(js_sign_func, video_id, room_id),\n        }\n        stream_formats = [self._download_json(\n            f'https://www.douyu.com/lapi/live/getH5Play/{room_id}',\n            video_id, note='Downloading livestream format',\n            data=urlencode_postdata(form_data))]\n\n        for rate_id in traverse_obj(stream_formats[0], ('data', 'multirates', ..., 'rate')):\n            if rate_id != traverse_obj(stream_formats[0], ('data', 'rate')):\n                form_data['rate'] = rate_id\n                stream_formats.append(self._download_json(\n                    f'https://www.douyu.com/lapi/live/getH5Play/{room_id}',\n                    video_id, note=f'Downloading livestream format {rate_id}',\n                    data=urlencode_postdata(form_data)))\n\n        return {\n            'id': room_id,\n            'formats': self._extract_stream_formats(stream_formats),\n            'is_live': True,\n            **traverse_obj(room, {\n                'display_id': ('url', {str}, {lambda i: i[1:]}),\n                'title': ('room_name', {unescapeHTML}),\n                'description': ('show_details', {str}),\n                'uploader': ('nickname', {str}),\n                'thumbnail': ('room_src', {url_or_none}),\n            }),\n        }\n\n\nclass DouyuShowIE(DouyuBaseIE):\n    _VALID_URL = r'https?://v(?:mobile)?\\.douyu\\.com/show/(?P<id>[0-9a-zA-Z]+)'\n\n    _TESTS = [{\n        'url': 'https://v.douyu.com/show/mPyq7oVNe5Yv1gLY',\n        'info_dict': {\n            'id': 'mPyq7oVNe5Yv1gLY',\n            'ext': 'mp4',\n            'title': '\u56db\u5ddd\u4eba\u5c0f\u65f6\u5019\u7684\u5473\u9053\u201c\u849c\u82d7\u56de\u9505\u8089\u201d\uff0c\u4f20\u7edf\u83dc\u4e0d\u80fd\u4e22\uff0c\u8981\u5e38\u505a\u6765\u5403',\n            'duration': 633,\n            'thumbnail': str,\n            'uploader': '\u7f8e\u98df\u4f5c\u5bb6\u738b\u521aV',\n            'uploader_id': 'OVAO4NVx1m7Q',\n            'timestamp': 1661850002,\n            'upload_date': '20220830',\n            'view_count': int,\n            'tags': ['\u7f8e\u98df', '\u7f8e\u98df\u7efc\u5408'],\n        },\n    }, {\n        'url': 'https://vmobile.douyu.com/show/rjNBdvnVXNzvE2yw',\n        'only_matching': True,\n    }]\n\n    _FORMATS = {\n        'super': '\u539f\u753b',\n        'high': '\u8d85\u6e05',\n        'normal': '\u9ad8\u6e05',\n    }\n\n    _QUALITIES = {\n        'super': -1,\n        'high': -2,\n        'normal': -3,\n    }\n\n    _RESOLUTIONS = {\n        'super': '1920x1080',\n        'high': '1280x720',\n        'normal': '852x480',\n    }\n\n    def _real_extract(self, url):\n        url = url.replace('vmobile.', 'v.')\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id)\n\n        video_info = self._search_json(\n            r'<script>\\s*window\\.\\$DATA\\s*=', webpage,\n            'video info', video_id, transform_source=js_to_json)\n\n        js_sign_func = self._search_js_sign_func(webpage)\n        form_data = {\n            'vid': video_id,\n            **self._calc_sign(js_sign_func, video_id, video_info['ROOM']['point_id']),\n        }\n        url_info = self._download_json(\n            'https://v.douyu.com/api/stream/getStreamUrl', video_id,\n            data=urlencode_postdata(form_data), note='Downloading video formats')\n\n        formats = []\n        for name, url in traverse_obj(url_info, ('data', 'thumb_video', {dict.items}, ...)):\n            video_url = traverse_obj(url, ('url', {url_or_none}))\n            if video_url:\n                ext = determine_ext(video_url)\n                formats.append({\n                    'format': self._FORMATS.get(name),\n                    'format_id': name,\n                    'url': video_url,\n                    'quality': self._QUALITIES.get(name),\n                    'ext': 'mp4' if ext == 'm3u8' else ext,\n                    'protocol': 'm3u8_native' if ext == 'm3u8' else 'https',\n                    **parse_resolution(self._RESOLUTIONS.get(name)),\n                })\n            else:\n                self.to_screen(\n                    f'\"{self._FORMATS.get(name, name)}\" format may require logging in. {self._login_hint()}')\n\n        return {\n            'id': video_id,\n            'formats': formats,\n            **traverse_obj(video_info, ('DATA', {\n                'title': ('content', 'title', {str}),\n                'uploader': ('content', 'author', {str}),\n                'uploader_id': ('content', 'up_id', {str_or_none}),\n                'duration': ('content', 'video_duration', {int_or_none}),\n                'thumbnail': ('content', 'video_pic', {url_or_none}),\n                'timestamp': ('content', 'create_time', {int_or_none}),\n                'view_count': ('content', 'view_num', {int_or_none}),\n                'tags': ('videoTag', ..., 'tagName', {str}),\n            })),\n        }\n", "file_name": "758317.py", "cwe": ["CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"]}
{"source": "import functools\nimport hashlib\nimport json\nimport time\nimport urllib.parse\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    ExtractorError,\n    OnDemandPagedList,\n    int_or_none,\n    jwt_decode_hs256,\n    mimetype2ext,\n    qualities,\n    traverse_obj,\n    try_call,\n    unified_timestamp,\n)\n\n\nclass IwaraBaseIE(InfoExtractor):\n    _NETRC_MACHINE = 'iwara'\n    _USERTOKEN = None\n    _MEDIATOKEN = None\n\n    def _is_token_expired(self, token, token_type):\n        # User token TTL == ~3 weeks, Media token TTL == ~1 hour\n        if (try_call(lambda: jwt_decode_hs256(token)['exp']) or 0) <= int(time.time() - 120):\n            self.to_screen(f'{token_type} token has expired')\n            return True\n\n    def _get_user_token(self):\n        username, password = self._get_login_info()\n        if not username or not password:\n            return\n\n        user_token = IwaraBaseIE._USERTOKEN or self.cache.load(self._NETRC_MACHINE, username)\n        if not user_token or self._is_token_expired(user_token, 'User'):\n            response = self._download_json(\n                'https://api.iwara.tv/user/login', None, note='Logging in',\n                headers={'Content-Type': 'application/json'}, data=json.dumps({\n                    'email': username,\n                    'password': password,\n                }).encode(), expected_status=lambda x: True)\n            user_token = traverse_obj(response, ('token', {str}))\n            if not user_token:\n                error = traverse_obj(response, ('message', {str}))\n                if 'invalidLogin' in error:\n                    raise ExtractorError('Invalid login credentials', expected=True)\n                else:\n                    raise ExtractorError(f'Iwara API said: {error or \"nothing\"}')\n\n            self.cache.store(self._NETRC_MACHINE, username, user_token)\n\n        IwaraBaseIE._USERTOKEN = user_token\n\n    def _get_media_token(self):\n        self._get_user_token()\n        if not IwaraBaseIE._USERTOKEN:\n            return  # user has not passed credentials\n\n        if not IwaraBaseIE._MEDIATOKEN or self._is_token_expired(IwaraBaseIE._MEDIATOKEN, 'Media'):\n            IwaraBaseIE._MEDIATOKEN = self._download_json(\n                'https://api.iwara.tv/user/token', None, note='Fetching media token',\n                data=b'', headers={\n                    'Authorization': f'Bearer {IwaraBaseIE._USERTOKEN}',\n                    'Content-Type': 'application/json',\n                })['accessToken']\n\n        return {'Authorization': f'Bearer {IwaraBaseIE._MEDIATOKEN}'}\n\n    def _perform_login(self, username, password):\n        self._get_media_token()\n\n\nclass IwaraIE(IwaraBaseIE):\n    IE_NAME = 'iwara'\n    _VALID_URL = r'https?://(?:www\\.|ecchi\\.)?iwara\\.tv/videos?/(?P<id>[a-zA-Z0-9]+)'\n    _TESTS = [{\n        'url': 'https://www.iwara.tv/video/k2ayoueezfkx6gvq',\n        'info_dict': {\n            'id': 'k2ayoueezfkx6gvq',\n            'ext': 'mp4',\n            'age_limit': 18,\n            'title': 'Defeat of Irybelda - \u30a2\u30a4\u30ea\u30d9\u30eb\u30c0\u306e\u6557\u5317',\n            'description': 'md5:70278abebe706647a8b4cb04cf23e0d3',\n            'uploader': 'Inwerwm',\n            'uploader_id': 'inwerwm',\n            'tags': 'count:1',\n            'like_count': 6133,\n            'view_count': 1050343,\n            'comment_count': 1,\n            'timestamp': 1677843869,\n            'modified_timestamp': 1679056362,\n        },\n        'skip': 'this video cannot be played because of migration',\n    }, {\n        'url': 'https://iwara.tv/video/1ywe1sbkqwumpdxz5/',\n        'md5': '7645f966f069b8ec9210efd9130c9aad',\n        'info_dict': {\n            'id': '1ywe1sbkqwumpdxz5',\n            'ext': 'mp4',\n            'age_limit': 18,\n            'title': 'Aponia \u30a2\u30dd\u30cb\u30a2 SEX  Party Tonight \u624b\u306e\u8131\u8863 \u5de8\u4e73 ',\n            'description': 'md5:3f60016fff22060eef1ef26d430b1f67',\n            'uploader': 'Lyu ya',\n            'uploader_id': 'user792540',\n            'tags': [\n                'uncategorized',\n            ],\n            'like_count': int,\n            'view_count': int,\n            'comment_count': int,\n            'timestamp': 1678732213,\n            'modified_timestamp': int,\n            'thumbnail': 'https://files.iwara.tv/image/thumbnail/581d12b5-46f4-4f15-beb2-cfe2cde5d13d/thumbnail-00.jpg',\n            'modified_date': '20230614',\n            'upload_date': '20230313',\n        },\n    }, {\n        'url': 'https://iwara.tv/video/blggmfno8ghl725bg',\n        'info_dict': {\n            'id': 'blggmfno8ghl725bg',\n            'ext': 'mp4',\n            'age_limit': 18,\n            'title': '\u304a\u5916\u3067\u304a\u3057\u3063\u3053\u3057\u3061\u3083\u3046\u732b\u8033\u30ed\u30ea\u30e1\u30a4\u30c9',\n            'description': 'md5:0342ba9bf6db09edbbb28729657c3611',\n            'uploader': 'Fe_Kurosabi',\n            'uploader_id': 'fekurosabi',\n            'tags': [\n                'pee',\n            ],\n            'like_count': int,\n            'view_count': int,\n            'comment_count': int,\n            'timestamp': 1598880567,\n            'modified_timestamp': int,\n            'upload_date': '20200831',\n            'modified_date': '20230605',\n            'thumbnail': 'https://files.iwara.tv/image/thumbnail/7693e881-d302-42a4-a780-f16d66b5dadd/thumbnail-00.jpg',\n            # 'availability': 'needs_auth',\n        },\n    }]\n\n    def _extract_formats(self, video_id, fileurl):\n        up = urllib.parse.urlparse(fileurl)\n        q = urllib.parse.parse_qs(up.query)\n        paths = up.path.rstrip('/').split('/')\n        # https://github.com/yt-dlp/yt-dlp/issues/6549#issuecomment-1473771047\n        x_version = hashlib.sha1('_'.join((paths[-1], q['expires'][0], '5nFp9kmbNnHdAFhaqMvt')).encode()).hexdigest()\n\n        preference = qualities(['preview', '360', '540', 'Source'])\n\n        files = self._download_json(fileurl, video_id, headers={'X-Version': x_version})\n        for fmt in files:\n            yield traverse_obj(fmt, {\n                'format_id': 'name',\n                'url': ('src', ('view', 'download'), {self._proto_relative_url}),\n                'ext': ('type', {mimetype2ext}),\n                'quality': ('name', {preference}),\n                'height': ('name', {int_or_none}),\n            }, get_all=False)\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        username, _ = self._get_login_info()\n        video_data = self._download_json(\n            f'https://api.iwara.tv/video/{video_id}', video_id,\n            expected_status=lambda x: True, headers=self._get_media_token())\n        errmsg = video_data.get('message')\n        # at this point we can actually get uploaded user info, but do we need it?\n        if errmsg == 'errors.privateVideo':\n            self.raise_login_required('Private video. Login if you have permissions to watch', method='password')\n        elif errmsg == 'errors.notFound' and not username:\n            self.raise_login_required('Video may need login to view', method='password')\n        elif errmsg:  # None if success\n            raise ExtractorError(f'Iwara says: {errmsg}')\n\n        if not video_data.get('fileUrl'):\n            if video_data.get('embedUrl'):\n                return self.url_result(video_data.get('embedUrl'))\n            raise ExtractorError('This video is unplayable', expected=True)\n\n        return {\n            'id': video_id,\n            'age_limit': 18 if video_data.get('rating') == 'ecchi' else 0,  # ecchi is 'sexy' in Japanese\n            **traverse_obj(video_data, {\n                'title': 'title',\n                'description': 'body',\n                'uploader': ('user', 'name'),\n                'uploader_id': ('user', 'username'),\n                'tags': ('tags', ..., 'id'),\n                'like_count': 'numLikes',\n                'view_count': 'numViews',\n                'comment_count': 'numComments',\n                'timestamp': ('createdAt', {unified_timestamp}),\n                'modified_timestamp': ('updatedAt', {unified_timestamp}),\n                'thumbnail': ('file', 'id', {str}, {\n                    lambda x: f'https://files.iwara.tv/image/thumbnail/{x}/thumbnail-00.jpg'}),\n            }),\n            'formats': list(self._extract_formats(video_id, video_data.get('fileUrl'))),\n        }\n\n\nclass IwaraUserIE(IwaraBaseIE):\n    _VALID_URL = r'https?://(?:www\\.)?iwara\\.tv/profile/(?P<id>[^/?#&]+)'\n    IE_NAME = 'iwara:user'\n    _PER_PAGE = 32\n\n    _TESTS = [{\n        'url': 'https://iwara.tv/profile/user792540/videos',\n        'info_dict': {\n            'id': 'user792540',\n            'title': 'Lyu ya',\n        },\n        'playlist_mincount': 70,\n    }, {\n        'url': 'https://iwara.tv/profile/theblackbirdcalls/videos',\n        'info_dict': {\n            'id': 'theblackbirdcalls',\n            'title': 'TheBlackbirdCalls',\n        },\n        'playlist_mincount': 723,\n    }, {\n        'url': 'https://iwara.tv/profile/user792540',\n        'only_matching': True,\n    }, {\n        'url': 'https://iwara.tv/profile/theblackbirdcalls',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.iwara.tv/profile/lumymmd',\n        'info_dict': {\n            'id': 'lumymmd',\n            'title': 'Lumy MMD',\n        },\n        'playlist_mincount': 1,\n    }]\n\n    def _entries(self, playlist_id, user_id, page):\n        videos = self._download_json(\n            'https://api.iwara.tv/videos', playlist_id,\n            note=f'Downloading page {page}',\n            query={\n                'page': page,\n                'sort': 'date',\n                'user': user_id,\n                'limit': self._PER_PAGE,\n            }, headers=self._get_media_token())\n        for x in traverse_obj(videos, ('results', ..., 'id')):\n            yield self.url_result(f'https://iwara.tv/video/{x}')\n\n    def _real_extract(self, url):\n        playlist_id = self._match_id(url)\n        user_info = self._download_json(\n            f'https://api.iwara.tv/profile/{playlist_id}', playlist_id,\n            note='Requesting user info')\n        user_id = traverse_obj(user_info, ('user', 'id'))\n\n        return self.playlist_result(\n            OnDemandPagedList(\n                functools.partial(self._entries, playlist_id, user_id),\n                self._PER_PAGE),\n            playlist_id, traverse_obj(user_info, ('user', 'name')))\n\n\nclass IwaraPlaylistIE(IwaraBaseIE):\n    _VALID_URL = r'https?://(?:www\\.)?iwara\\.tv/playlist/(?P<id>[0-9a-f-]+)'\n    IE_NAME = 'iwara:playlist'\n    _PER_PAGE = 32\n\n    _TESTS = [{\n        'url': 'https://iwara.tv/playlist/458e5486-36a4-4ac0-b233-7e9eef01025f',\n        'info_dict': {\n            'id': '458e5486-36a4-4ac0-b233-7e9eef01025f',\n        },\n        'playlist_mincount': 3,\n    }]\n\n    def _entries(self, playlist_id, first_page, page):\n        videos = self._download_json(\n            'https://api.iwara.tv/videos', playlist_id, f'Downloading page {page}',\n            query={'page': page, 'limit': self._PER_PAGE},\n            headers=self._get_media_token()) if page else first_page\n        for x in traverse_obj(videos, ('results', ..., 'id')):\n            yield self.url_result(f'https://iwara.tv/video/{x}')\n\n    def _real_extract(self, url):\n        playlist_id = self._match_id(url)\n        page_0 = self._download_json(\n            f'https://api.iwara.tv/playlist/{playlist_id}?page=0&limit={self._PER_PAGE}', playlist_id,\n            note='Requesting playlist info', headers=self._get_media_token())\n\n        return self.playlist_result(\n            OnDemandPagedList(\n                functools.partial(self._entries, playlist_id, page_0),\n                self._PER_PAGE),\n            playlist_id, traverse_obj(page_0, ('title', 'name')))\n", "file_name": "837764.py", "cwe": ["CWE-327: Use of a Broken or Risky Cryptographic Algorithm"]}
{"source": "import hashlib\nimport random\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    clean_html,\n    int_or_none,\n    try_get,\n)\n\n\nclass JamendoIE(InfoExtractor):\n    _VALID_URL = r'''(?x)\n                    https?://\n                        (?:\n                            licensing\\.jamendo\\.com/[^/]+|\n                            (?:www\\.)?jamendo\\.com\n                        )\n                        /track/(?P<id>[0-9]+)(?:/(?P<display_id>[^/?#&]+))?\n                    '''\n    _TESTS = [{\n        'url': 'https://www.jamendo.com/track/196219/stories-from-emona-i',\n        'md5': '6e9e82ed6db98678f171c25a8ed09ffd',\n        'info_dict': {\n            'id': '196219',\n            'display_id': 'stories-from-emona-i',\n            'ext': 'flac',\n            # 'title': 'Maya Filipi\u010d - Stories from Emona I',\n            'title': 'Stories from Emona I',\n            'artist': 'Maya Filipi\u010d',\n            'album': 'Between two worlds',\n            'track': 'Stories from Emona I',\n            'duration': 210,\n            'thumbnail': 'https://usercontent.jamendo.com?type=album&id=29279&width=300&trackid=196219',\n            'timestamp': 1217438117,\n            'upload_date': '20080730',\n            'license': 'by-nc-nd',\n            'view_count': int,\n            'like_count': int,\n            'average_rating': int,\n            'tags': ['piano', 'peaceful', 'newage', 'strings', 'upbeat'],\n        },\n    }, {\n        'url': 'https://licensing.jamendo.com/en/track/1496667/energetic-rock',\n        'only_matching': True,\n    }]\n\n    def _call_api(self, resource, resource_id, fatal=True):\n        path = f'/api/{resource}s'\n        rand = str(random.random())\n        return self._download_json(\n            'https://www.jamendo.com' + path, resource_id, fatal=fatal, query={\n                'id[]': resource_id,\n            }, headers={\n                'X-Jam-Call': f'${hashlib.sha1((path + rand).encode()).hexdigest()}*{rand}~',\n            })[0]\n\n    def _real_extract(self, url):\n        track_id, display_id = self._match_valid_url(url).groups()\n        # webpage = self._download_webpage(\n        #     'https://www.jamendo.com/track/' + track_id, track_id)\n        # models = self._parse_json(self._html_search_regex(\n        #     r\"data-bundled-models='([^']+)\",\n        #     webpage, 'bundled models'), track_id)\n        # track = models['track']['models'][0]\n        track = self._call_api('track', track_id)\n        title = track_name = track['name']\n        # get_model = lambda x: try_get(models, lambda y: y[x]['models'][0], dict) or {}\n        # artist = get_model('artist')\n        # artist_name = artist.get('name')\n        # if artist_name:\n        #     title = '%s - %s' % (artist_name, title)\n        # album = get_model('album')\n        artist = self._call_api('artist', track.get('artistId'), fatal=False)\n        album = self._call_api('album', track.get('albumId'), fatal=False)\n\n        formats = [{\n            'url': f'https://{sub_domain}.jamendo.com/?trackid={track_id}&format={format_id}&from=app-97dab294',\n            'format_id': format_id,\n            'ext': ext,\n            'quality': quality,\n        } for quality, (format_id, sub_domain, ext) in enumerate((\n            ('mp31', 'mp3l', 'mp3'),\n            ('mp32', 'mp3d', 'mp3'),\n            ('ogg1', 'ogg', 'ogg'),\n            ('flac', 'flac', 'flac'),\n        ))]\n\n        urls = []\n        thumbnails = []\n        for covers in (track.get('cover') or {}).values():\n            for cover_id, cover_url in covers.items():\n                if not cover_url or cover_url in urls:\n                    continue\n                urls.append(cover_url)\n                size = int_or_none(cover_id.lstrip('size'))\n                thumbnails.append({\n                    'id': cover_id,\n                    'url': cover_url,\n                    'width': size,\n                    'height': size,\n                })\n\n        tags = []\n        for tag in (track.get('tags') or []):\n            tag_name = tag.get('name')\n            if not tag_name:\n                continue\n            tags.append(tag_name)\n\n        stats = track.get('stats') or {}\n        video_license = track.get('licenseCC') or []\n\n        return {\n            'id': track_id,\n            'display_id': display_id,\n            'thumbnails': thumbnails,\n            'title': title,\n            'description': track.get('description'),\n            'duration': int_or_none(track.get('duration')),\n            'artist': artist.get('name'),\n            'track': track_name,\n            'album': album.get('name'),\n            'formats': formats,\n            'license': '-'.join(video_license) if video_license else None,\n            'timestamp': int_or_none(track.get('dateCreated')),\n            'view_count': int_or_none(stats.get('listenedAll')),\n            'like_count': int_or_none(stats.get('favorited')),\n            'average_rating': int_or_none(stats.get('averageNote')),\n            'tags': tags,\n        }\n\n\nclass JamendoAlbumIE(JamendoIE):  # XXX: Do not subclass from concrete IE\n    _VALID_URL = r'https?://(?:www\\.)?jamendo\\.com/album/(?P<id>[0-9]+)'\n    _TESTS = [{\n        'url': 'https://www.jamendo.com/album/121486/duck-on-cover',\n        'info_dict': {\n            'id': '121486',\n            'title': 'Duck On Cover',\n            'description': 'md5:c2920eaeef07d7af5b96d7c64daf1239',\n        },\n        'playlist': [{\n            'md5': 'e1a2fcb42bda30dfac990212924149a8',\n            'info_dict': {\n                'id': '1032333',\n                'ext': 'flac',\n                'title': 'Warmachine',\n                'artist': 'Shearer',\n                'track': 'Warmachine',\n                'timestamp': 1368089771,\n                'upload_date': '20130509',\n                'view_count': int,\n                'thumbnail': 'https://usercontent.jamendo.com?type=album&id=121486&width=300&trackid=1032333',\n                'duration': 190,\n                'license': 'by',\n                'album': 'Duck On Cover',\n                'average_rating': 4,\n                'tags': ['rock', 'drums', 'bass', 'world', 'punk', 'neutral'],\n                'like_count': int,\n            },\n        }, {\n            'md5': '1f358d7b2f98edfe90fd55dac0799d50',\n            'info_dict': {\n                'id': '1032330',\n                'ext': 'flac',\n                'title': 'Without Your Ghost',\n                'artist': 'Shearer',\n                'track': 'Without Your Ghost',\n                'timestamp': 1368089771,\n                'upload_date': '20130509',\n                'duration': 192,\n                'tags': ['rock', 'drums', 'bass', 'world', 'punk'],\n                'album': 'Duck On Cover',\n                'thumbnail': 'https://usercontent.jamendo.com?type=album&id=121486&width=300&trackid=1032330',\n                'view_count': int,\n                'average_rating': 4,\n                'license': 'by',\n                'like_count': int,\n            },\n        }],\n        'params': {\n            'playlistend': 2,\n        },\n    }]\n\n    def _real_extract(self, url):\n        album_id = self._match_id(url)\n        album = self._call_api('album', album_id)\n        album_name = album.get('name')\n\n        entries = []\n        for track in (album.get('tracks') or []):\n            track_id = track.get('id')\n            if not track_id:\n                continue\n            track_id = str(track_id)\n            entries.append({\n                '_type': 'url_transparent',\n                'url': 'https://www.jamendo.com/track/' + track_id,\n                'ie_key': JamendoIE.ie_key(),\n                'id': track_id,\n                'album': album_name,\n            })\n\n        return self.playlist_result(\n            entries, album_id, album_name,\n            clean_html(try_get(album, lambda x: x['description']['en'], str)))\n", "file_name": "530858.py", "cwe": ["CWE-327: Use of a Broken or Risky Cryptographic Algorithm"]}
{"source": "\"\"\"\nSettings and configuration for Django.\n\nRead values from the module specified by the DJANGO_SETTINGS_MODULE environment\nvariable, and then from django.conf.global_settings; see the global_settings.py\nfor a list of all possible variables.\n\"\"\"\n\nimport importlib\nimport os\nimport time\nimport traceback\nimport warnings\nfrom pathlib import Path\n\nimport django\nfrom django.conf import global_settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.utils.deprecation import RemovedInDjango60Warning\nfrom django.utils.functional import LazyObject, empty\n\nENVIRONMENT_VARIABLE = \"DJANGO_SETTINGS_MODULE\"\nDEFAULT_STORAGE_ALIAS = \"default\"\nSTATICFILES_STORAGE_ALIAS = \"staticfiles\"\n\n# RemovedInDjango60Warning.\nFORMS_URLFIELD_ASSUME_HTTPS_DEPRECATED_MSG = (\n    \"The FORMS_URLFIELD_ASSUME_HTTPS transitional setting is deprecated.\"\n)\n\n\nclass SettingsReference(str):\n    \"\"\"\n    String subclass which references a current settings value. It's treated as\n    the value in memory but serializes to a settings.NAME attribute reference.\n    \"\"\"\n\n    def __new__(self, value, setting_name):\n        return str.__new__(self, value)\n\n    def __init__(self, value, setting_name):\n        self.setting_name = setting_name\n\n\nclass LazySettings(LazyObject):\n    \"\"\"\n    A lazy proxy for either global Django settings or a custom settings object.\n    The user can manually configure settings prior to using them. Otherwise,\n    Django uses the settings module pointed to by DJANGO_SETTINGS_MODULE.\n    \"\"\"\n\n    def _setup(self, name=None):\n        \"\"\"\n        Load the settings module pointed to by the environment variable. This\n        is used the first time settings are needed, if the user hasn't\n        configured settings manually.\n        \"\"\"\n        settings_module = os.environ.get(ENVIRONMENT_VARIABLE)\n        if not settings_module:\n            desc = (\"setting %s\" % name) if name else \"settings\"\n            raise ImproperlyConfigured(\n                \"Requested %s, but settings are not configured. \"\n                \"You must either define the environment variable %s \"\n                \"or call settings.configure() before accessing settings.\"\n                % (desc, ENVIRONMENT_VARIABLE)\n            )\n\n        self._wrapped = Settings(settings_module)\n\n    def __repr__(self):\n        # Hardcode the class name as otherwise it yields 'Settings'.\n        if self._wrapped is empty:\n            return \"<LazySettings [Unevaluated]>\"\n        return '<LazySettings \"%(settings_module)s\">' % {\n            \"settings_module\": self._wrapped.SETTINGS_MODULE,\n        }\n\n    def __getattr__(self, name):\n        \"\"\"Return the value of a setting and cache it in self.__dict__.\"\"\"\n        if (_wrapped := self._wrapped) is empty:\n            self._setup(name)\n            _wrapped = self._wrapped\n        val = getattr(_wrapped, name)\n\n        # Special case some settings which require further modification.\n        # This is done here for performance reasons so the modified value is cached.\n        if name in {\"MEDIA_URL\", \"STATIC_URL\"} and val is not None:\n            val = self._add_script_prefix(val)\n        elif name == \"SECRET_KEY\" and not val:\n            raise ImproperlyConfigured(\"The SECRET_KEY setting must not be empty.\")\n\n        self.__dict__[name] = val\n        return val\n\n    def __setattr__(self, name, value):\n        \"\"\"\n        Set the value of setting. Clear all cached values if _wrapped changes\n        (@override_settings does this) or clear single values when set.\n        \"\"\"\n        if name == \"_wrapped\":\n            self.__dict__.clear()\n        else:\n            self.__dict__.pop(name, None)\n        super().__setattr__(name, value)\n\n    def __delattr__(self, name):\n        \"\"\"Delete a setting and clear it from cache if needed.\"\"\"\n        super().__delattr__(name)\n        self.__dict__.pop(name, None)\n\n    def configure(self, default_settings=global_settings, **options):\n        \"\"\"\n        Called to manually configure the settings. The 'default_settings'\n        parameter sets where to retrieve any unspecified values from (its\n        argument must support attribute access (__getattr__)).\n        \"\"\"\n        if self._wrapped is not empty:\n            raise RuntimeError(\"Settings already configured.\")\n        holder = UserSettingsHolder(default_settings)\n        for name, value in options.items():\n            if not name.isupper():\n                raise TypeError(\"Setting %r must be uppercase.\" % name)\n            setattr(holder, name, value)\n        self._wrapped = holder\n\n    @staticmethod\n    def _add_script_prefix(value):\n        \"\"\"\n        Add SCRIPT_NAME prefix to relative paths.\n\n        Useful when the app is being served at a subpath and manually prefixing\n        subpath to STATIC_URL and MEDIA_URL in settings is inconvenient.\n        \"\"\"\n        # Don't apply prefix to absolute paths and URLs.\n        if value.startswith((\"http://\", \"https://\", \"/\")):\n            return value\n        from django.urls import get_script_prefix\n\n        return \"%s%s\" % (get_script_prefix(), value)\n\n    @property\n    def configured(self):\n        \"\"\"Return True if the settings have already been configured.\"\"\"\n        return self._wrapped is not empty\n\n    def _show_deprecation_warning(self, message, category):\n        stack = traceback.extract_stack()\n        # Show a warning if the setting is used outside of Django.\n        # Stack index: -1 this line, -2 the property, -3 the\n        # LazyObject __getattribute__(), -4 the caller.\n        filename, _, _, _ = stack[-4]\n        if not filename.startswith(os.path.dirname(django.__file__)):\n            warnings.warn(message, category, stacklevel=2)\n\n\nclass Settings:\n    def __init__(self, settings_module):\n        # update this dict from global settings (but only for ALL_CAPS settings)\n        for setting in dir(global_settings):\n            if setting.isupper():\n                setattr(self, setting, getattr(global_settings, setting))\n\n        # store the settings module in case someone later cares\n        self.SETTINGS_MODULE = settings_module\n\n        mod = importlib.import_module(self.SETTINGS_MODULE)\n\n        tuple_settings = (\n            \"ALLOWED_HOSTS\",\n            \"INSTALLED_APPS\",\n            \"TEMPLATE_DIRS\",\n            \"LOCALE_PATHS\",\n            \"SECRET_KEY_FALLBACKS\",\n        )\n        self._explicit_settings = set()\n        for setting in dir(mod):\n            if setting.isupper():\n                setting_value = getattr(mod, setting)\n\n                if setting in tuple_settings and not isinstance(\n                    setting_value, (list, tuple)\n                ):\n                    raise ImproperlyConfigured(\n                        \"The %s setting must be a list or a tuple.\" % setting\n                    )\n                setattr(self, setting, setting_value)\n                self._explicit_settings.add(setting)\n\n        if self.is_overridden(\"FORMS_URLFIELD_ASSUME_HTTPS\"):\n            warnings.warn(\n                FORMS_URLFIELD_ASSUME_HTTPS_DEPRECATED_MSG,\n                RemovedInDjango60Warning,\n            )\n\n        if hasattr(time, \"tzset\") and self.TIME_ZONE:\n            # When we can, attempt to validate the timezone. If we can't find\n            # this file, no check happens and it's harmless.\n            zoneinfo_root = Path(\"/usr/share/zoneinfo\")\n            zone_info_file = zoneinfo_root.joinpath(*self.TIME_ZONE.split(\"/\"))\n            if zoneinfo_root.exists() and not zone_info_file.exists():\n                raise ValueError(\"Incorrect timezone setting: %s\" % self.TIME_ZONE)\n            # Move the time zone info into os.environ. See ticket #2315 for why\n            # we don't do this unconditionally (breaks Windows).\n            os.environ[\"TZ\"] = self.TIME_ZONE\n            time.tzset()\n\n    def is_overridden(self, setting):\n        return setting in self._explicit_settings\n\n    def __repr__(self):\n        return '<%(cls)s \"%(settings_module)s\">' % {\n            \"cls\": self.__class__.__name__,\n            \"settings_module\": self.SETTINGS_MODULE,\n        }\n\n\nclass UserSettingsHolder:\n    \"\"\"Holder for user configured settings.\"\"\"\n\n    # SETTINGS_MODULE doesn't make much sense in the manually configured\n    # (standalone) case.\n    SETTINGS_MODULE = None\n\n    def __init__(self, default_settings):\n        \"\"\"\n        Requests for configuration variables not in this class are satisfied\n        from the module specified in default_settings (if possible).\n        \"\"\"\n        self.__dict__[\"_deleted\"] = set()\n        self.default_settings = default_settings\n\n    def __getattr__(self, name):\n        if not name.isupper() or name in self._deleted:\n            raise AttributeError\n        return getattr(self.default_settings, name)\n\n    def __setattr__(self, name, value):\n        self._deleted.discard(name)\n        if name == \"FORMS_URLFIELD_ASSUME_HTTPS\":\n            warnings.warn(\n                FORMS_URLFIELD_ASSUME_HTTPS_DEPRECATED_MSG,\n                RemovedInDjango60Warning,\n            )\n        super().__setattr__(name, value)\n\n    def __delattr__(self, name):\n        self._deleted.add(name)\n        if hasattr(self, name):\n            super().__delattr__(name)\n\n    def __dir__(self):\n        return sorted(\n            s\n            for s in [*self.__dict__, *dir(self.default_settings)]\n            if s not in self._deleted\n        )\n\n    def is_overridden(self, setting):\n        deleted = setting in self._deleted\n        set_locally = setting in self.__dict__\n        set_on_default = getattr(\n            self.default_settings, \"is_overridden\", lambda s: False\n        )(setting)\n        return deleted or set_locally or set_on_default\n\n    def __repr__(self):\n        return \"<%(cls)s>\" % {\n            \"cls\": self.__class__.__name__,\n        }\n\n\nsettings = LazySettings()\n", "file_name": "359100.py", "cwe": ["CWE-706: Use of Incorrectly-Resolved Name or Reference"]}
{"source": "\"Misc. utility functions/classes for admin documentation generator.\"\n\nimport re\nfrom email.errors import HeaderParseError\nfrom email.parser import HeaderParser\nfrom inspect import cleandoc\n\nfrom django.urls import reverse\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.safestring import mark_safe\n\ntry:\n    import docutils.core\n    import docutils.nodes\n    import docutils.parsers.rst.roles\nexcept ImportError:\n    docutils_is_available = False\nelse:\n    docutils_is_available = True\n\n\ndef get_view_name(view_func):\n    if hasattr(view_func, \"view_class\"):\n        klass = view_func.view_class\n        return f\"{klass.__module__}.{klass.__qualname__}\"\n    mod_name = view_func.__module__\n    view_name = getattr(view_func, \"__qualname__\", view_func.__class__.__name__)\n    return mod_name + \".\" + view_name\n\n\ndef parse_docstring(docstring):\n    \"\"\"\n    Parse out the parts of a docstring.  Return (title, body, metadata).\n    \"\"\"\n    if not docstring:\n        return \"\", \"\", {}\n    docstring = cleandoc(docstring)\n    parts = re.split(r\"\\n{2,}\", docstring)\n    title = parts[0]\n    if len(parts) == 1:\n        body = \"\"\n        metadata = {}\n    else:\n        parser = HeaderParser()\n        try:\n            metadata = parser.parsestr(parts[-1])\n        except HeaderParseError:\n            metadata = {}\n            body = \"\\n\\n\".join(parts[1:])\n        else:\n            metadata = dict(metadata.items())\n            if metadata:\n                body = \"\\n\\n\".join(parts[1:-1])\n            else:\n                body = \"\\n\\n\".join(parts[1:])\n    return title, body, metadata\n\n\ndef parse_rst(text, default_reference_context, thing_being_parsed=None):\n    \"\"\"\n    Convert the string from reST to an XHTML fragment.\n    \"\"\"\n    overrides = {\n        \"doctitle_xform\": True,\n        \"initial_header_level\": 3,\n        \"default_reference_context\": default_reference_context,\n        \"link_base\": reverse(\"django-admindocs-docroot\").rstrip(\"/\"),\n        \"raw_enabled\": False,\n        \"file_insertion_enabled\": False,\n    }\n    thing_being_parsed = thing_being_parsed and \"<%s>\" % thing_being_parsed\n    # Wrap ``text`` in some reST that sets the default role to ``cmsreference``,\n    # then restores it.\n    source = \"\"\"\n.. default-role:: cmsreference\n\n%s\n\n.. default-role::\n\"\"\"\n    parts = docutils.core.publish_parts(\n        source % text,\n        source_path=thing_being_parsed,\n        destination_path=None,\n        writer_name=\"html\",\n        settings_overrides=overrides,\n    )\n    return mark_safe(parts[\"fragment\"])\n\n\n#\n# reST roles\n#\nROLES = {\n    \"model\": \"%s/models/%s/\",\n    \"view\": \"%s/views/%s/\",\n    \"template\": \"%s/templates/%s/\",\n    \"filter\": \"%s/filters/#%s\",\n    \"tag\": \"%s/tags/#%s\",\n}\n\n\ndef create_reference_role(rolename, urlbase):\n    # Views and template names are case-sensitive.\n    is_case_sensitive = rolename in [\"template\", \"view\"]\n\n    def _role(name, rawtext, text, lineno, inliner, options=None, content=None):\n        if options is None:\n            options = {}\n        node = docutils.nodes.reference(\n            rawtext,\n            text,\n            refuri=(\n                urlbase\n                % (\n                    inliner.document.settings.link_base,\n                    text if is_case_sensitive else text.lower(),\n                )\n            ),\n            **options,\n        )\n        return [node], []\n\n    docutils.parsers.rst.roles.register_canonical_role(rolename, _role)\n\n\ndef default_reference_role(\n    name, rawtext, text, lineno, inliner, options=None, content=None\n):\n    if options is None:\n        options = {}\n    context = inliner.document.settings.default_reference_context\n    node = docutils.nodes.reference(\n        rawtext,\n        text,\n        refuri=(\n            ROLES[context]\n            % (\n                inliner.document.settings.link_base,\n                text.lower(),\n            )\n        ),\n        **options,\n    )\n    return [node], []\n\n\nif docutils_is_available:\n    docutils.parsers.rst.roles.register_canonical_role(\n        \"cmsreference\", default_reference_role\n    )\n\n    for name, urlbase in ROLES.items():\n        create_reference_role(name, urlbase)\n\n# Match the beginning of a named, unnamed, or non-capturing groups.\nnamed_group_matcher = _lazy_re_compile(r\"\\(\\?P(<\\w+>)\")\nunnamed_group_matcher = _lazy_re_compile(r\"\\(\")\nnon_capturing_group_matcher = _lazy_re_compile(r\"\\(\\?\\:\")\n\n\ndef replace_metacharacters(pattern):\n    \"\"\"Remove unescaped metacharacters from the pattern.\"\"\"\n    return re.sub(\n        r\"((?:^|(?<!\\\\))(?:\\\\\\\\)*)(\\\\?)([?*+^$]|\\\\[bBAZ])\",\n        lambda m: m[1] + m[3] if m[2] else m[1],\n        pattern,\n    )\n\n\ndef _get_group_start_end(start, end, pattern):\n    # Handle nested parentheses, e.g. '^(?P<a>(x|y))/b' or '^b/((x|y)\\w+)$'.\n    unmatched_open_brackets, prev_char = 1, None\n    for idx, val in enumerate(pattern[end:]):\n        # Check for unescaped `(` and `)`. They mark the start and end of a\n        # nested group.\n        if val == \"(\" and prev_char != \"\\\\\":\n            unmatched_open_brackets += 1\n        elif val == \")\" and prev_char != \"\\\\\":\n            unmatched_open_brackets -= 1\n        prev_char = val\n        # If brackets are balanced, the end of the string for the current named\n        # capture group pattern has been reached.\n        if unmatched_open_brackets == 0:\n            return start, end + idx + 1\n\n\ndef _find_groups(pattern, group_matcher):\n    prev_end = None\n    for match in group_matcher.finditer(pattern):\n        if indices := _get_group_start_end(match.start(0), match.end(0), pattern):\n            start, end = indices\n            if prev_end and start > prev_end or not prev_end:\n                yield start, end, match\n            prev_end = end\n\n\ndef replace_named_groups(pattern):\n    r\"\"\"\n    Find named groups in `pattern` and replace them with the group name. E.g.,\n    1. ^(?P<a>\\w+)/b/(\\w+)$ ==> ^<a>/b/(\\w+)$\n    2. ^(?P<a>\\w+)/b/(?P<c>\\w+)/$ ==> ^<a>/b/<c>/$\n    3. ^(?P<a>\\w+)/b/(\\w+) ==> ^<a>/b/(\\w+)\n    4. ^(?P<a>\\w+)/b/(?P<c>\\w+) ==> ^<a>/b/<c>\n    \"\"\"\n    group_pattern_and_name = [\n        (pattern[start:end], match[1])\n        for start, end, match in _find_groups(pattern, named_group_matcher)\n    ]\n    for group_pattern, group_name in group_pattern_and_name:\n        pattern = pattern.replace(group_pattern, group_name)\n    return pattern\n\n\ndef replace_unnamed_groups(pattern):\n    r\"\"\"\n    Find unnamed groups in `pattern` and replace them with '<var>'. E.g.,\n    1. ^(?P<a>\\w+)/b/(\\w+)$ ==> ^(?P<a>\\w+)/b/<var>$\n    2. ^(?P<a>\\w+)/b/((x|y)\\w+)$ ==> ^(?P<a>\\w+)/b/<var>$\n    3. ^(?P<a>\\w+)/b/(\\w+) ==> ^(?P<a>\\w+)/b/<var>\n    4. ^(?P<a>\\w+)/b/((x|y)\\w+) ==> ^(?P<a>\\w+)/b/<var>\n    \"\"\"\n    final_pattern, prev_end = \"\", None\n    for start, end, _ in _find_groups(pattern, unnamed_group_matcher):\n        if prev_end:\n            final_pattern += pattern[prev_end:start]\n        final_pattern += pattern[:start] + \"<var>\"\n        prev_end = end\n    return final_pattern + pattern[prev_end:]\n\n\ndef remove_non_capturing_groups(pattern):\n    r\"\"\"\n    Find non-capturing groups in the given `pattern` and remove them, e.g.\n    1. (?P<a>\\w+)/b/(?:\\w+)c(?:\\w+) => (?P<a>\\\\w+)/b/c\n    2. ^(?:\\w+(?:\\w+))a => ^a\n    3. ^a(?:\\w+)/b(?:\\w+) => ^a/b\n    \"\"\"\n    group_start_end_indices = _find_groups(pattern, non_capturing_group_matcher)\n    final_pattern, prev_end = \"\", None\n    for start, end, _ in group_start_end_indices:\n        final_pattern += pattern[prev_end:start]\n        prev_end = end\n    return final_pattern + pattern[prev_end:]\n", "file_name": "429723.py", "cwe": ["CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"]}
{"source": "\"\"\"\n This module contains the spatial lookup types, and the `get_geo_where_clause`\n routine for Oracle Spatial.\n\n Please note that WKT support is broken on the XE version, and thus\n this backend will not work on such platforms.  Specifically, XE lacks\n support for an internal JVM, and Java libraries are required to use\n the WKT constructors.\n\"\"\"\n\nimport re\n\nfrom django.contrib.gis.db import models\nfrom django.contrib.gis.db.backends.base.operations import BaseSpatialOperations\nfrom django.contrib.gis.db.backends.oracle.adapter import OracleSpatialAdapter\nfrom django.contrib.gis.db.backends.utils import SpatialOperator\nfrom django.contrib.gis.geos.geometry import GEOSGeometry, GEOSGeometryBase\nfrom django.contrib.gis.geos.prototypes.io import wkb_r\nfrom django.contrib.gis.measure import Distance\nfrom django.db.backends.oracle.operations import DatabaseOperations\n\nDEFAULT_TOLERANCE = \"0.05\"\n\n\nclass SDOOperator(SpatialOperator):\n    sql_template = \"%(func)s(%(lhs)s, %(rhs)s) = 'TRUE'\"\n\n\nclass SDODWithin(SpatialOperator):\n    sql_template = \"SDO_WITHIN_DISTANCE(%(lhs)s, %(rhs)s, %%s) = 'TRUE'\"\n\n\nclass SDODisjoint(SpatialOperator):\n    sql_template = (\n        \"SDO_GEOM.RELATE(%%(lhs)s, 'DISJOINT', %%(rhs)s, %s) = 'DISJOINT'\"\n        % DEFAULT_TOLERANCE\n    )\n\n\nclass SDORelate(SpatialOperator):\n    sql_template = \"SDO_RELATE(%(lhs)s, %(rhs)s, 'mask=%(mask)s') = 'TRUE'\"\n\n    def check_relate_argument(self, arg):\n        masks = (\n            \"TOUCH|OVERLAPBDYDISJOINT|OVERLAPBDYINTERSECT|EQUAL|INSIDE|COVEREDBY|\"\n            \"CONTAINS|COVERS|ANYINTERACT|ON\"\n        )\n        mask_regex = re.compile(r\"^(%s)(\\+(%s))*$\" % (masks, masks), re.I)\n        if not isinstance(arg, str) or not mask_regex.match(arg):\n            raise ValueError('Invalid SDO_RELATE mask: \"%s\"' % arg)\n\n    def as_sql(self, connection, lookup, template_params, sql_params):\n        template_params[\"mask\"] = sql_params[-1]\n        return super().as_sql(connection, lookup, template_params, sql_params[:-1])\n\n\nclass OracleOperations(BaseSpatialOperations, DatabaseOperations):\n    name = \"oracle\"\n    oracle = True\n    disallowed_aggregates = (models.Collect, models.Extent3D, models.MakeLine)\n\n    Adapter = OracleSpatialAdapter\n\n    extent = \"SDO_AGGR_MBR\"\n    unionagg = \"SDO_AGGR_UNION\"\n\n    from_text = \"SDO_GEOMETRY\"\n\n    function_names = {\n        \"Area\": \"SDO_GEOM.SDO_AREA\",\n        \"AsGeoJSON\": \"SDO_UTIL.TO_GEOJSON\",\n        \"AsWKB\": \"SDO_UTIL.TO_WKBGEOMETRY\",\n        \"AsWKT\": \"SDO_UTIL.TO_WKTGEOMETRY\",\n        \"BoundingCircle\": \"SDO_GEOM.SDO_MBC\",\n        \"Centroid\": \"SDO_GEOM.SDO_CENTROID\",\n        \"Difference\": \"SDO_GEOM.SDO_DIFFERENCE\",\n        \"Distance\": \"SDO_GEOM.SDO_DISTANCE\",\n        \"Envelope\": \"SDO_GEOM_MBR\",\n        \"FromWKB\": \"SDO_UTIL.FROM_WKBGEOMETRY\",\n        \"FromWKT\": \"SDO_UTIL.FROM_WKTGEOMETRY\",\n        \"Intersection\": \"SDO_GEOM.SDO_INTERSECTION\",\n        \"IsValid\": \"SDO_GEOM.VALIDATE_GEOMETRY_WITH_CONTEXT\",\n        \"Length\": \"SDO_GEOM.SDO_LENGTH\",\n        \"NumGeometries\": \"SDO_UTIL.GETNUMELEM\",\n        \"NumPoints\": \"SDO_UTIL.GETNUMVERTICES\",\n        \"Perimeter\": \"SDO_GEOM.SDO_LENGTH\",\n        \"PointOnSurface\": \"SDO_GEOM.SDO_POINTONSURFACE\",\n        \"Reverse\": \"SDO_UTIL.REVERSE_LINESTRING\",\n        \"SymDifference\": \"SDO_GEOM.SDO_XOR\",\n        \"Transform\": \"SDO_CS.TRANSFORM\",\n        \"Union\": \"SDO_GEOM.SDO_UNION\",\n    }\n\n    # We want to get SDO Geometries as WKT because it is much easier to\n    # instantiate GEOS proxies from WKT than SDO_GEOMETRY(...) strings.\n    # However, this adversely affects performance (i.e., Java is called\n    # to convert to WKT on every query).  If someone wishes to write a\n    # SDO_GEOMETRY(...) parser in Python, let me know =)\n    select = \"SDO_UTIL.TO_WKBGEOMETRY(%s)\"\n\n    gis_operators = {\n        \"contains\": SDOOperator(func=\"SDO_CONTAINS\"),\n        \"coveredby\": SDOOperator(func=\"SDO_COVEREDBY\"),\n        \"covers\": SDOOperator(func=\"SDO_COVERS\"),\n        \"disjoint\": SDODisjoint(),\n        \"intersects\": SDOOperator(\n            func=\"SDO_OVERLAPBDYINTERSECT\"\n        ),  # TODO: Is this really the same as ST_Intersects()?\n        \"equals\": SDOOperator(func=\"SDO_EQUAL\"),\n        \"exact\": SDOOperator(func=\"SDO_EQUAL\"),\n        \"overlaps\": SDOOperator(func=\"SDO_OVERLAPS\"),\n        \"same_as\": SDOOperator(func=\"SDO_EQUAL\"),\n        # Oracle uses a different syntax, e.g., 'mask=inside+touch'\n        \"relate\": SDORelate(),\n        \"touches\": SDOOperator(func=\"SDO_TOUCH\"),\n        \"within\": SDOOperator(func=\"SDO_INSIDE\"),\n        \"dwithin\": SDODWithin(),\n    }\n\n    unsupported_functions = {\n        \"AsKML\",\n        \"AsSVG\",\n        \"Azimuth\",\n        \"ClosestPoint\",\n        \"ForcePolygonCW\",\n        \"GeoHash\",\n        \"GeometryDistance\",\n        \"IsEmpty\",\n        \"LineLocatePoint\",\n        \"MakeValid\",\n        \"MemSize\",\n        \"Scale\",\n        \"SnapToGrid\",\n        \"Translate\",\n    }\n\n    def geo_quote_name(self, name):\n        return super().geo_quote_name(name).upper()\n\n    def convert_extent(self, clob):\n        if clob:\n            # Generally, Oracle returns a polygon for the extent -- however,\n            # it can return a single point if there's only one Point in the\n            # table.\n            ext_geom = GEOSGeometry(memoryview(clob.read()))\n            gtype = str(ext_geom.geom_type)\n            if gtype == \"Polygon\":\n                # Construct the 4-tuple from the coordinates in the polygon.\n                shell = ext_geom.shell\n                ll, ur = shell[0][:2], shell[2][:2]\n            elif gtype == \"Point\":\n                ll = ext_geom.coords[:2]\n                ur = ll\n            else:\n                raise Exception(\n                    \"Unexpected geometry type returned for extent: %s\" % gtype\n                )\n            xmin, ymin = ll\n            xmax, ymax = ur\n            return (xmin, ymin, xmax, ymax)\n        else:\n            return None\n\n    def geo_db_type(self, f):\n        \"\"\"\n        Return the geometry database type for Oracle. Unlike other spatial\n        backends, no stored procedure is necessary and it's the same for all\n        geometry types.\n        \"\"\"\n        return \"MDSYS.SDO_GEOMETRY\"\n\n    def get_distance(self, f, value, lookup_type):\n        \"\"\"\n        Return the distance parameters given the value and the lookup type.\n        On Oracle, geometry columns with a geodetic coordinate system behave\n        implicitly like a geography column, and thus meters will be used as\n        the distance parameter on them.\n        \"\"\"\n        if not value:\n            return []\n        value = value[0]\n        if isinstance(value, Distance):\n            if f.geodetic(self.connection):\n                dist_param = value.m\n            else:\n                dist_param = getattr(\n                    value, Distance.unit_attname(f.units_name(self.connection))\n                )\n        else:\n            dist_param = value\n\n        # dwithin lookups on Oracle require a special string parameter\n        # that starts with \"distance=\".\n        if lookup_type == \"dwithin\":\n            dist_param = \"distance=%s\" % dist_param\n\n        return [dist_param]\n\n    def get_geom_placeholder(self, f, value, compiler):\n        if value is None:\n            return \"NULL\"\n        return super().get_geom_placeholder(f, value, compiler)\n\n    def spatial_aggregate_name(self, agg_name):\n        \"\"\"\n        Return the spatial aggregate SQL name.\n        \"\"\"\n        agg_name = \"unionagg\" if agg_name.lower() == \"union\" else agg_name.lower()\n        return getattr(self, agg_name)\n\n    # Routines for getting the OGC-compliant models.\n    def geometry_columns(self):\n        from django.contrib.gis.db.backends.oracle.models import OracleGeometryColumns\n\n        return OracleGeometryColumns\n\n    def spatial_ref_sys(self):\n        from django.contrib.gis.db.backends.oracle.models import OracleSpatialRefSys\n\n        return OracleSpatialRefSys\n\n    def modify_insert_params(self, placeholder, params):\n        \"\"\"Drop out insert parameters for NULL placeholder. Needed for Oracle Spatial\n        backend due to #10888.\n        \"\"\"\n        if placeholder == \"NULL\":\n            return []\n        return super().modify_insert_params(placeholder, params)\n\n    def get_geometry_converter(self, expression):\n        read = wkb_r().read\n        srid = expression.output_field.srid\n        if srid == -1:\n            srid = None\n        geom_class = expression.output_field.geom_class\n\n        def converter(value, expression, connection):\n            if value is not None:\n                geom = GEOSGeometryBase(read(memoryview(value.read())), geom_class)\n                if srid:\n                    geom.srid = srid\n                return geom\n\n        return converter\n\n    def get_area_att_for_field(self, field):\n        return \"sq_m\"\n", "file_name": "783587.py", "cwe": ["CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"]}
{"source": "# Copyright 2024 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"XLNet SQUAD finetuning runner in tf2.0.\"\"\"\n\nimport functools\nimport json\nimport os\nimport pickle\n\n# Import libraries\nfrom absl import app\nfrom absl import flags\nfrom absl import logging\n\nimport tensorflow as tf, tf_keras\n# pylint: disable=unused-import\nimport sentencepiece as spm\nfrom official.common import distribute_utils\nfrom official.legacy.xlnet import common_flags\nfrom official.legacy.xlnet import data_utils\nfrom official.legacy.xlnet import optimization\nfrom official.legacy.xlnet import squad_utils\nfrom official.legacy.xlnet import training_utils\nfrom official.legacy.xlnet import xlnet_config\nfrom official.legacy.xlnet import xlnet_modeling as modeling\n\nflags.DEFINE_string(\n    \"test_feature_path\", default=None, help=\"Path to feature of test set.\")\nflags.DEFINE_integer(\"query_len\", default=64, help=\"Max query length.\")\nflags.DEFINE_integer(\"start_n_top\", default=5, help=\"Beam size for span start.\")\nflags.DEFINE_integer(\"end_n_top\", default=5, help=\"Beam size for span end.\")\nflags.DEFINE_string(\n    \"predict_dir\", default=None, help=\"Path to write predictions.\")\nflags.DEFINE_string(\n    \"predict_file\", default=None, help=\"Path to json file of test set.\")\nflags.DEFINE_integer(\n    \"n_best_size\", default=5, help=\"n best size for predictions.\")\nflags.DEFINE_integer(\"max_answer_length\", default=64, help=\"Max answer length.\")\n# Data preprocessing config\nflags.DEFINE_string(\n    \"spiece_model_file\", default=None, help=\"Sentence Piece model path.\")\nflags.DEFINE_integer(\"max_seq_length\", default=512, help=\"Max sequence length.\")\nflags.DEFINE_integer(\"max_query_length\", default=64, help=\"Max query length.\")\nflags.DEFINE_integer(\"doc_stride\", default=128, help=\"Doc stride.\")\n\nFLAGS = flags.FLAGS\n\n\nclass InputFeatures(object):\n  \"\"\"A single set of features of data.\"\"\"\n\n  def __init__(self,\n               unique_id,\n               example_index,\n               doc_span_index,\n               tok_start_to_orig_index,\n               tok_end_to_orig_index,\n               token_is_max_context,\n               input_ids,\n               input_mask,\n               p_mask,\n               segment_ids,\n               paragraph_len,\n               cls_index,\n               start_position=None,\n               end_position=None,\n               is_impossible=None):\n    self.unique_id = unique_id\n    self.example_index = example_index\n    self.doc_span_index = doc_span_index\n    self.tok_start_to_orig_index = tok_start_to_orig_index\n    self.tok_end_to_orig_index = tok_end_to_orig_index\n    self.token_is_max_context = token_is_max_context\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.p_mask = p_mask\n    self.segment_ids = segment_ids\n    self.paragraph_len = paragraph_len\n    self.cls_index = cls_index\n    self.start_position = start_position\n    self.end_position = end_position\n    self.is_impossible = is_impossible\n\n\n# pylint: disable=unused-argument\ndef run_evaluation(strategy, test_input_fn, eval_examples, eval_features,\n                   original_data, eval_steps, input_meta_data, model,\n                   current_step, eval_summary_writer):\n  \"\"\"Run evaluation for SQUAD task.\n\n  Args:\n    strategy: distribution strategy.\n    test_input_fn: input function for evaluation data.\n    eval_examples: tf.Examples of the evaluation set.\n    eval_features: Feature objects of the evaluation set.\n    original_data: The original json data for the evaluation set.\n    eval_steps: total number of evaluation steps.\n    input_meta_data: input meta data.\n    model: keras model object.\n    current_step: current training step.\n    eval_summary_writer: summary writer used to record evaluation metrics.\n\n  Returns:\n    A float metric, F1 score.\n  \"\"\"\n\n  def _test_step_fn(inputs):\n    \"\"\"Replicated validation step.\"\"\"\n\n    inputs[\"mems\"] = None\n    res = model(inputs, training=False)\n    return res, inputs[\"unique_ids\"]\n\n  @tf.function\n  def _run_evaluation(test_iterator):\n    \"\"\"Runs validation steps.\"\"\"\n    res, unique_ids = strategy.run(\n        _test_step_fn, args=(next(test_iterator),))\n    return res, unique_ids\n\n  test_iterator = data_utils.get_input_iterator(test_input_fn, strategy)\n  cur_results = []\n  for _ in range(eval_steps):\n    results, unique_ids = _run_evaluation(test_iterator)\n    unique_ids = strategy.experimental_local_results(unique_ids)\n\n    for result_key in results:\n      results[result_key] = (\n          strategy.experimental_local_results(results[result_key]))\n    for core_i in range(strategy.num_replicas_in_sync):\n      bsz = int(input_meta_data[\"test_batch_size\"] /\n                strategy.num_replicas_in_sync)\n      for j in range(bsz):\n        result = {}\n        for result_key in results:\n          result[result_key] = results[result_key][core_i].numpy()[j]\n        result[\"unique_ids\"] = unique_ids[core_i].numpy()[j]\n        # We appended a fake example into dev set to make data size can be\n        # divided by test_batch_size. Ignores this fake example during\n        # evaluation.\n        if result[\"unique_ids\"] == 1000012047:\n          continue\n        unique_id = int(result[\"unique_ids\"])\n\n        start_top_log_probs = ([\n            float(x) for x in result[\"start_top_log_probs\"].flat\n        ])\n        start_top_index = [int(x) for x in result[\"start_top_index\"].flat]\n        end_top_log_probs = ([\n            float(x) for x in result[\"end_top_log_probs\"].flat\n        ])\n        end_top_index = [int(x) for x in result[\"end_top_index\"].flat]\n\n        cls_logits = float(result[\"cls_logits\"].flat[0])\n        cur_results.append(\n            squad_utils.RawResult(\n                unique_id=unique_id,\n                start_top_log_probs=start_top_log_probs,\n                start_top_index=start_top_index,\n                end_top_log_probs=end_top_log_probs,\n                end_top_index=end_top_index,\n                cls_logits=cls_logits))\n        if len(cur_results) % 1000 == 0:\n          logging.info(\"Processing example: %d\", len(cur_results))\n\n  output_prediction_file = os.path.join(input_meta_data[\"predict_dir\"],\n                                        \"predictions.json\")\n  output_nbest_file = os.path.join(input_meta_data[\"predict_dir\"],\n                                   \"nbest_predictions.json\")\n  output_null_log_odds_file = os.path.join(input_meta_data[\"predict_dir\"],\n                                           \"null_odds.json\")\n\n  results = squad_utils.write_predictions(\n      eval_examples, eval_features, cur_results, input_meta_data[\"n_best_size\"],\n      input_meta_data[\"max_answer_length\"], output_prediction_file,\n      output_nbest_file, output_null_log_odds_file, original_data,\n      input_meta_data[\"start_n_top\"], input_meta_data[\"end_n_top\"])\n\n  # Log current results.\n  log_str = \"Result | \"\n  for key, val in results.items():\n    log_str += \"{} {} | \".format(key, val)\n  logging.info(log_str)\n  with eval_summary_writer.as_default():\n    tf.summary.scalar(\"best_f1\", results[\"best_f1\"], step=current_step)\n    tf.summary.scalar(\"best_exact\", results[\"best_exact\"], step=current_step)\n    eval_summary_writer.flush()\n  return results[\"best_f1\"]\n\n\ndef get_qaxlnet_model(model_config, run_config, start_n_top, end_n_top):\n  model = modeling.QAXLNetModel(\n      model_config,\n      run_config,\n      start_n_top=start_n_top,\n      end_n_top=end_n_top,\n      name=\"model\")\n  return model\n\n\ndef main(unused_argv):\n  del unused_argv\n  strategy = distribute_utils.get_distribution_strategy(\n      distribution_strategy=FLAGS.strategy_type,\n      tpu_address=FLAGS.tpu)\n  if strategy:\n    logging.info(\"***** Number of cores used : %d\",\n                 strategy.num_replicas_in_sync)\n  train_input_fn = functools.partial(data_utils.get_squad_input_data,\n                                     FLAGS.train_batch_size, FLAGS.seq_len,\n                                     FLAGS.query_len, strategy, True,\n                                     FLAGS.train_tfrecord_path)\n\n  test_input_fn = functools.partial(data_utils.get_squad_input_data,\n                                    FLAGS.test_batch_size, FLAGS.seq_len,\n                                    FLAGS.query_len, strategy, False,\n                                    FLAGS.test_tfrecord_path)\n\n  total_training_steps = FLAGS.train_steps\n  steps_per_loop = FLAGS.iterations\n  eval_steps = int(FLAGS.test_data_size / FLAGS.test_batch_size)\n\n  optimizer, learning_rate_fn = optimization.create_optimizer(\n      FLAGS.learning_rate,\n      total_training_steps,\n      FLAGS.warmup_steps,\n      adam_epsilon=FLAGS.adam_epsilon)\n  model_config = xlnet_config.XLNetConfig(FLAGS)\n  run_config = xlnet_config.create_run_config(True, False, FLAGS)\n  input_meta_data = {}\n  input_meta_data[\"start_n_top\"] = FLAGS.start_n_top\n  input_meta_data[\"end_n_top\"] = FLAGS.end_n_top\n  input_meta_data[\"lr_layer_decay_rate\"] = FLAGS.lr_layer_decay_rate\n  input_meta_data[\"predict_dir\"] = FLAGS.predict_dir\n  input_meta_data[\"n_best_size\"] = FLAGS.n_best_size\n  input_meta_data[\"max_answer_length\"] = FLAGS.max_answer_length\n  input_meta_data[\"test_batch_size\"] = FLAGS.test_batch_size\n  input_meta_data[\"batch_size_per_core\"] = int(FLAGS.train_batch_size /\n                                               strategy.num_replicas_in_sync)\n  input_meta_data[\"mem_len\"] = FLAGS.mem_len\n  model_fn = functools.partial(get_qaxlnet_model, model_config, run_config,\n                               FLAGS.start_n_top, FLAGS.end_n_top)\n  eval_examples = squad_utils.read_squad_examples(\n      FLAGS.predict_file, is_training=False)\n  if FLAGS.test_feature_path:\n    logging.info(\"start reading pickle file...\")\n    with tf.io.gfile.GFile(FLAGS.test_feature_path, \"rb\") as f:\n      eval_features = pickle.load(f)\n    logging.info(\"finishing reading pickle file...\")\n  else:\n    sp_model = spm.SentencePieceProcessor()\n    sp_model.LoadFromSerializedProto(\n        tf.io.gfile.GFile(FLAGS.spiece_model_file, \"rb\").read())\n    spm_basename = os.path.basename(FLAGS.spiece_model_file)\n    eval_features = squad_utils.create_eval_data(\n        spm_basename, sp_model, eval_examples, FLAGS.max_seq_length,\n        FLAGS.max_query_length, FLAGS.doc_stride, FLAGS.uncased)\n\n  with tf.io.gfile.GFile(FLAGS.predict_file) as f:\n    original_data = json.load(f)[\"data\"]\n  eval_fn = functools.partial(run_evaluation, strategy, test_input_fn,\n                              eval_examples, eval_features, original_data,\n                              eval_steps, input_meta_data)\n\n  training_utils.train(\n      strategy=strategy,\n      model_fn=model_fn,\n      input_meta_data=input_meta_data,\n      eval_fn=eval_fn,\n      metric_fn=None,\n      train_input_fn=train_input_fn,\n      init_checkpoint=FLAGS.init_checkpoint,\n      init_from_transformerxl=FLAGS.init_from_transformerxl,\n      total_training_steps=total_training_steps,\n      steps_per_loop=steps_per_loop,\n      optimizer=optimizer,\n      learning_rate_fn=learning_rate_fn,\n      model_dir=FLAGS.model_dir,\n      save_steps=FLAGS.save_steps)\n\n\nif __name__ == \"__main__\":\n  app.run(main)\n", "file_name": "778047.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "# Copyright 2024 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Customized checkpoint loader.\"\"\"\nimport re\nfrom typing import List, Tuple\n\nfrom absl import logging\nimport numpy as np\nimport tensorflow as tf, tf_keras\n\n\n# pylint:disable=line-too-long\n_VMAE_CKPT_MAPPING = [\n    (r'encoder/transformer_encoder_block_(.*?)/self_attention/query/kernel:0',\n     r'blocks.\\1.attn.q.weight'),\n    (r'encoder/transformer_encoder_block_(.*?)/self_attention/query/bias:0',\n     r'blocks.\\1.attn.q.bias'),\n    (r'encoder/transformer_encoder_block_(.*?)/self_attention/value/kernel:0',\n     r'blocks.\\1.attn.v.weight'),\n    (r'encoder/transformer_encoder_block_(.*?)/self_attention/value/bias:0',\n     r'blocks.\\1.attn.v.bias'),\n    (r'encoder/transformer_encoder_block_(.*?)/self_attention/key/kernel:0',\n     r'blocks.\\1.attn.k.weight'),\n    (r'encoder/transformer_encoder_block_(.*?)/self_attention/key/bias:0',\n     r'blocks.\\1.attn.k.bias'),\n    (r'encoder/transformer_encoder_block_(.*?)/self_attention/attention_output/kernel:0',\n     r'blocks.\\1.attn.proj.weight'),\n    (r'encoder/transformer_encoder_block_(.*?)/self_attention/attention_output/bias:0',\n     r'blocks.\\1.attn.proj.bias'),\n    (r'encoder/transformer_encoder_block_(.*?)/self_attention_layer_norm/gamma:0',\n     r'blocks.\\1.norm1.weight'),\n    (r'encoder/transformer_encoder_block_(.*?)/self_attention_layer_norm/beta:0',\n     r'blocks.\\1.norm1.bias'),\n    (r'encoder/transformer_encoder_block_(.*?)/intermediate/kernel:0',\n     r'blocks.\\1.mlp.fc1.weight'),\n    (r'encoder/transformer_encoder_block_(.*?)/intermediate/bias:0',\n     r'blocks.\\1.mlp.fc1.bias'),\n    (r'encoder/transformer_encoder_block_(.*?)/output/kernel:0',\n     r'blocks.\\1.mlp.fc2.weight'),\n    (r'encoder/transformer_encoder_block_(.*?)/output/bias:0',\n     r'blocks.\\1.mlp.fc2.bias'),\n    (r'encoder/transformer_encoder_block_(.*?)/output_layer_norm/gamma:0',\n     r'blocks.\\1.norm2.weight'),\n    (r'encoder/transformer_encoder_block_(.*?)/output_layer_norm/beta:0',\n     r'blocks.\\1.norm2.bias'),\n\n    # ======= final layer norm\n    (r'encoder/layer_normalization/gamma:0', r'norm.weight'),\n    (r'encoder/layer_normalization/beta:0', r'norm.bias'),\n\n    # ======= input projection layer\n    (r'conv3d/kernel:0', r'patch_embed.proj.weight'),\n    (r'conv3d/bias:0', r'patch_embed.proj.bias'),\n\n    # ======= agg embedding.\n    (r'token_layer/cls:0', r'cls_token'),\n\n    # ======= positional embedding.\n    (r'add_separable_position_embs/pos_embedding_time:0',\n     r'pos_embed_temporal'),\n    (r'add_separable_position_embs/pos_embedding_space:0',\n     r'pos_embed_spatial'),\n]\n# pylint:enable=line-too-long\n\n\nclass CheckpointLoaderBase(object):\n  \"\"\"Checkpoint loader object.\"\"\"\n\n  def __init__(self, model: tf_keras.Model,\n               init_checkpoint: str,\n               init_checkpoint_type: str):\n    self._init_checkpoint = init_checkpoint\n    self._init_checkpoint_type = init_checkpoint_type\n\n    ckpt_dir_or_file = self._init_checkpoint\n    if tf.io.gfile.isdir(ckpt_dir_or_file):\n      ckpt_dir_or_file = tf.train.latest_checkpoint(ckpt_dir_or_file)\n\n    self._load_checkpoint(model, ckpt_dir_or_file)\n    logging.info('Finished loading pretrained checkpoint from %s',\n                 ckpt_dir_or_file)\n\n  def _load_checkpoint(self, model: tf_keras.Model, ckpt_dir_or_file: str):\n    \"\"\"Loads checkpoint.\"\"\"\n    if self._init_checkpoint_type == 'all':\n      ckpt = tf.train.Checkpoint(model=model)\n      status = ckpt.read(ckpt_dir_or_file)\n      status.expect_partial().assert_existing_objects_matched()\n    elif self._init_checkpoint_type == 'backbone':\n      ckpt = tf.train.Checkpoint(backbone=model.backbone)\n      status = ckpt.read(ckpt_dir_or_file)\n      status.expect_partial().assert_existing_objects_matched()\n    else:\n      raise ValueError(\n          'Unrecognized init_checkpoint_type: %s' % self._init_checkpoint_type)\n\n  def _remap_variable_name(self,\n                           variable_name: str,\n                           name_mapping: List[Tuple[str, str]]):\n    \"\"\"Remaps variable name given the mapping.\"\"\"\n    for source, dest in name_mapping:\n      variable_name = re.sub(source, dest, variable_name)\n    return variable_name\n\n\nclass CheckpointLoaderVMAE(CheckpointLoaderBase):\n  \"\"\"Checkpoint loader for Video MAE.\"\"\"\n\n  def _maybe_transpose_pytorch_weight(self, ckpt_weight):\n    \"\"\"Transposes pytorch weight to macth with the Tensorflow convention.\"\"\"\n    if len(ckpt_weight.shape) == 2:\n      # fc kernel\n      ckpt_weight = np.transpose(ckpt_weight, [1, 0])\n    elif len(ckpt_weight.shape) == 4:\n      # conv2d kernel\n      ckpt_weight = np.transpose(ckpt_weight, [2, 3, 1, 0])\n    elif len(ckpt_weight.shape) == 5:\n      # conv3d kernel\n      ckpt_weight = np.transpose(ckpt_weight, [2, 3, 4, 1, 0])\n    return ckpt_weight\n\n  def _customized_vmae_initialize(self,\n                                  model: tf_keras.Model,\n                                  ckpt_dir_or_file: str):\n    \"\"\"Loads pretrained Video MAE checkpoint.\"\"\"\n    with tf.io.gfile.GFile(ckpt_dir_or_file, 'rb') as ckpt:\n      weights = np.load(ckpt, allow_pickle=True)\n\n    ckpt_names = list(weights[()].keys())\n    ckpt_names = [n for n in ckpt_names if 'pred_head' not in n]\n\n    skipped = []\n    loaded = []\n    for krs_w in model.weights:\n      krs_name = krs_w.name\n      # Handle the first block naming.\n      krs_name = krs_name.replace('encoder/transformer_encoder_block/',\n                                  'encoder/transformer_encoder_block_0/')\n      ckpt_name = self._remap_variable_name(krs_name, _VMAE_CKPT_MAPPING)\n      if ckpt_name in ckpt_names:\n        ckpt_weight = weights[()][ckpt_name]\n        ckpt_weight = self._maybe_transpose_pytorch_weight(ckpt_weight)\n\n        if ckpt_weight.shape == krs_w.shape:\n          krs_w.assign(ckpt_weight)\n          loaded.append(ckpt_name)\n        elif 'kernel' in krs_name and any(\n            [keyword in krs_name for keyword in ['key', 'query', 'value']]):\n          cin, cout = ckpt_weight.shape\n          num_heads = krs_w.shape[1]\n          ckpt_weight = tf.reshape(\n              ckpt_weight, [cin, num_heads, cout // num_heads])\n          krs_w.assign(ckpt_weight)\n          loaded.append(ckpt_name)\n        elif 'bias' in krs_name and any(\n            [keyword in krs_name for keyword in ['key', 'query', 'value']]):\n          cout = ckpt_weight.shape[0]\n          num_heads = krs_w.shape[0]\n          ckpt_weight = tf.reshape(ckpt_weight, [num_heads, cout // num_heads])\n          krs_w.assign(ckpt_weight)\n          loaded.append(ckpt_name)\n        elif 'kernel' in krs_name and 'attention_output' in krs_name:\n          cin, cout = ckpt_weight.shape\n          num_heads = krs_w.shape[0]\n          ckpt_weight = tf.reshape(ckpt_weight,\n                                   [num_heads, cin // num_heads, cout])\n          krs_w.assign(ckpt_weight)\n          loaded.append(ckpt_name)\n        else:\n          skipped.append(krs_name)\n      else:\n        skipped.append(krs_name)\n\n    leftover = set(ckpt_names) - set(loaded)\n    logging.info('skipped: %s', skipped)\n    logging.info('leftover: %s', leftover)\n\n    if any([('encoder' in v or 'conv3d' in v or 'pos_embedding' in v)\n            for v in skipped]):\n      raise ValueError('ViT backbone is only partially loaded.')\n    logging.info('Finished loading pretrained checkpoint from %s',\n                 ckpt_dir_or_file)\n\n  def _load_checkpoint(self, model: tf_keras.Model, ckpt_dir_or_file: str):\n    \"\"\"Loads checkpoint.\"\"\"\n    self._customized_vmae_initialize(\n        model=model, ckpt_dir_or_file=ckpt_dir_or_file)\n\n\ndef get_checkpoint_loader(\n    model: tf_keras.Model, init_checkpoint: str, init_checkpoint_type: str):\n  \"\"\"Gets the corresponding checkpoint loader.\"\"\"\n\n  if init_checkpoint_type == 'customized_vmae':\n    return CheckpointLoaderVMAE(\n        model=model,\n        init_checkpoint=init_checkpoint,\n        init_checkpoint_type=init_checkpoint_type)\n\n  else:\n    return CheckpointLoaderBase(\n        model=model,\n        init_checkpoint=init_checkpoint,\n        init_checkpoint_type=init_checkpoint_type)\n", "file_name": "036289.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "# Copyright 2018 The TensorFlow Authors All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Data utils for CIFAR-10 and CIFAR-100.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport copy\nimport cPickle\nimport os\nimport augmentation_transforms\nimport numpy as np\nimport policies as found_policies\nimport tensorflow as tf\n\n\n# pylint:disable=logging-format-interpolation\n\n\nclass DataSet(object):\n  \"\"\"Dataset object that produces augmented training and eval data.\"\"\"\n\n  def __init__(self, hparams):\n    self.hparams = hparams\n    self.epochs = 0\n    self.curr_train_index = 0\n\n    all_labels = []\n\n    self.good_policies = found_policies.good_policies()\n\n    # Determine how many databatched to load\n    num_data_batches_to_load = 5\n    total_batches_to_load = num_data_batches_to_load\n    train_batches_to_load = total_batches_to_load\n    assert hparams.train_size + hparams.validation_size <= 50000\n    if hparams.eval_test:\n      total_batches_to_load += 1\n    # Determine how many images we have loaded\n    total_dataset_size = 10000 * num_data_batches_to_load\n    train_dataset_size = total_dataset_size\n    if hparams.eval_test:\n      total_dataset_size += 10000\n\n    if hparams.dataset == 'cifar10':\n      all_data = np.empty((total_batches_to_load, 10000, 3072), dtype=np.uint8)\n    elif hparams.dataset == 'cifar100':\n      assert num_data_batches_to_load == 5\n      all_data = np.empty((1, 50000, 3072), dtype=np.uint8)\n      if hparams.eval_test:\n        test_data = np.empty((1, 10000, 3072), dtype=np.uint8)\n    if hparams.dataset == 'cifar10':\n      tf.logging.info('Cifar10')\n      datafiles = [\n          'data_batch_1', 'data_batch_2', 'data_batch_3', 'data_batch_4',\n          'data_batch_5']\n\n      datafiles = datafiles[:train_batches_to_load]\n      if hparams.eval_test:\n        datafiles.append('test_batch')\n      num_classes = 10\n    elif hparams.dataset == 'cifar100':\n      datafiles = ['train']\n      if hparams.eval_test:\n        datafiles.append('test')\n      num_classes = 100\n    else:\n      raise NotImplementedError('Unimplemented dataset: ', hparams.dataset)\n    if hparams.dataset != 'test':\n      for file_num, f in enumerate(datafiles):\n        d = unpickle(os.path.join(hparams.data_path, f))\n        if f == 'test':\n          test_data[0] = copy.deepcopy(d['data'])\n          all_data = np.concatenate([all_data, test_data], axis=1)\n        else:\n          all_data[file_num] = copy.deepcopy(d['data'])\n        if hparams.dataset == 'cifar10':\n          labels = np.array(d['labels'])\n        else:\n          labels = np.array(d['fine_labels'])\n        nsamples = len(labels)\n        for idx in range(nsamples):\n          all_labels.append(labels[idx])\n\n    all_data = all_data.reshape(total_dataset_size, 3072)\n    all_data = all_data.reshape(-1, 3, 32, 32)\n    all_data = all_data.transpose(0, 2, 3, 1).copy()\n    all_data = all_data / 255.0\n    mean = augmentation_transforms.MEANS\n    std = augmentation_transforms.STDS\n    tf.logging.info('mean:{}    std: {}'.format(mean, std))\n\n    all_data = (all_data - mean) / std\n    all_labels = np.eye(num_classes)[np.array(all_labels, dtype=np.int32)]\n    assert len(all_data) == len(all_labels)\n    tf.logging.info(\n        'In CIFAR10 loader, number of images: {}'.format(len(all_data)))\n\n    # Break off test data\n    if hparams.eval_test:\n      self.test_images = all_data[train_dataset_size:]\n      self.test_labels = all_labels[train_dataset_size:]\n\n    # Shuffle the rest of the data\n    all_data = all_data[:train_dataset_size]\n    all_labels = all_labels[:train_dataset_size]\n    np.random.seed(0)\n    perm = np.arange(len(all_data))\n    np.random.shuffle(perm)\n    all_data = all_data[perm]\n    all_labels = all_labels[perm]\n\n    # Break into train and val\n    train_size, val_size = hparams.train_size, hparams.validation_size\n    assert 50000 >= train_size + val_size\n    self.train_images = all_data[:train_size]\n    self.train_labels = all_labels[:train_size]\n    self.val_images = all_data[train_size:train_size + val_size]\n    self.val_labels = all_labels[train_size:train_size + val_size]\n    self.num_train = self.train_images.shape[0]\n\n  def next_batch(self):\n    \"\"\"Return the next minibatch of augmented data.\"\"\"\n    next_train_index = self.curr_train_index + self.hparams.batch_size\n    if next_train_index > self.num_train:\n      # Increase epoch number\n      epoch = self.epochs + 1\n      self.reset()\n      self.epochs = epoch\n    batched_data = (\n        self.train_images[self.curr_train_index:\n                          self.curr_train_index + self.hparams.batch_size],\n        self.train_labels[self.curr_train_index:\n                          self.curr_train_index + self.hparams.batch_size])\n    final_imgs = []\n\n    images, labels = batched_data\n    for data in images:\n      epoch_policy = self.good_policies[np.random.choice(\n          len(self.good_policies))]\n      final_img = augmentation_transforms.apply_policy(\n          epoch_policy, data)\n      final_img = augmentation_transforms.random_flip(\n          augmentation_transforms.zero_pad_and_crop(final_img, 4))\n      # Apply cutout\n      final_img = augmentation_transforms.cutout_numpy(final_img)\n      final_imgs.append(final_img)\n    batched_data = (np.array(final_imgs, np.float32), labels)\n    self.curr_train_index += self.hparams.batch_size\n    return batched_data\n\n  def reset(self):\n    \"\"\"Reset training data and index into the training data.\"\"\"\n    self.epochs = 0\n    # Shuffle the training data\n    perm = np.arange(self.num_train)\n    np.random.shuffle(perm)\n    assert self.num_train == self.train_images.shape[\n        0], 'Error incorrect shuffling mask'\n    self.train_images = self.train_images[perm]\n    self.train_labels = self.train_labels[perm]\n    self.curr_train_index = 0\n\n\ndef unpickle(f):\n  tf.logging.info('loading file: {}'.format(f))\n  fo = tf.gfile.Open(f, 'r')\n  d = cPickle.load(fo)\n  fo.close()\n  return d\n", "file_name": "102308.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "from dirty_equals import IsDict, IsOneOf\nfrom fastapi.testclient import TestClient\n\nfrom docs_src.security.tutorial005 import (\n    app,\n    create_access_token,\n    fake_users_db,\n    get_password_hash,\n    verify_password,\n)\n\nclient = TestClient(app)\n\n\ndef get_access_token(username=\"johndoe\", password=\"secret\", scope=None):\n    data = {\"username\": username, \"password\": password}\n    if scope:\n        data[\"scope\"] = scope\n    response = client.post(\"/token\", data=data)\n    content = response.json()\n    access_token = content.get(\"access_token\")\n    return access_token\n\n\ndef test_login():\n    response = client.post(\"/token\", data={\"username\": \"johndoe\", \"password\": \"secret\"})\n    assert response.status_code == 200, response.text\n    content = response.json()\n    assert \"access_token\" in content\n    assert content[\"token_type\"] == \"bearer\"\n\n\ndef test_login_incorrect_password():\n    response = client.post(\n        \"/token\", data={\"username\": \"johndoe\", \"password\": \"incorrect\"}\n    )\n    assert response.status_code == 400, response.text\n    assert response.json() == {\"detail\": \"Incorrect username or password\"}\n\n\ndef test_login_incorrect_username():\n    response = client.post(\"/token\", data={\"username\": \"foo\", \"password\": \"secret\"})\n    assert response.status_code == 400, response.text\n    assert response.json() == {\"detail\": \"Incorrect username or password\"}\n\n\ndef test_no_token():\n    response = client.get(\"/users/me\")\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not authenticated\"}\n    assert response.headers[\"WWW-Authenticate\"] == \"Bearer\"\n\n\ndef test_token():\n    access_token = get_access_token(scope=\"me\")\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"disabled\": False,\n    }\n\n\ndef test_incorrect_token():\n    response = client.get(\"/users/me\", headers={\"Authorization\": \"Bearer nonexistent\"})\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Could not validate credentials\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'\n\n\ndef test_incorrect_token_type():\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": \"Notexistent testtoken\"}\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not authenticated\"}\n    assert response.headers[\"WWW-Authenticate\"] == \"Bearer\"\n\n\ndef test_verify_password():\n    assert verify_password(\"secret\", fake_users_db[\"johndoe\"][\"hashed_password\"])\n\n\ndef test_get_password_hash():\n    assert get_password_hash(\"secretalice\")\n\n\ndef test_create_access_token():\n    access_token = create_access_token(data={\"data\": \"foo\"})\n    assert access_token\n\n\ndef test_token_no_sub():\n    response = client.get(\n        \"/users/me\",\n        headers={\n            \"Authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjoiZm9vIn0.9ynBhuYb4e6aW3oJr_K_TBgwcMTDpRToQIE25L57rOE\"\n        },\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Could not validate credentials\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'\n\n\ndef test_token_no_username():\n    response = client.get(\n        \"/users/me\",\n        headers={\n            \"Authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJmb28ifQ.NnExK_dlNAYyzACrXtXDrcWOgGY2JuPbI4eDaHdfK5Y\"\n        },\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Could not validate credentials\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'\n\n\ndef test_token_no_scope():\n    access_token = get_access_token()\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not enough permissions\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'\n\n\ndef test_token_nonexistent_user():\n    response = client.get(\n        \"/users/me\",\n        headers={\n            \"Authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VybmFtZTpib2IifQ.HcfCW67Uda-0gz54ZWTqmtgJnZeNem0Q757eTa9EZuw\"\n        },\n    )\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Could not validate credentials\"}\n    assert response.headers[\"WWW-Authenticate\"] == 'Bearer scope=\"me\"'\n\n\ndef test_token_inactive_user():\n    access_token = get_access_token(\n        username=\"alice\", password=\"secretalice\", scope=\"me\"\n    )\n    response = client.get(\n        \"/users/me\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 400, response.text\n    assert response.json() == {\"detail\": \"Inactive user\"}\n\n\ndef test_read_items():\n    access_token = get_access_token(scope=\"me items\")\n    response = client.get(\n        \"/users/me/items/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == [{\"item_id\": \"Foo\", \"owner\": \"johndoe\"}]\n\n\ndef test_read_system_status():\n    access_token = get_access_token()\n    response = client.get(\n        \"/status/\", headers={\"Authorization\": f\"Bearer {access_token}\"}\n    )\n    assert response.status_code == 200, response.text\n    assert response.json() == {\"status\": \"ok\"}\n\n\ndef test_read_system_status_no_token():\n    response = client.get(\"/status/\")\n    assert response.status_code == 401, response.text\n    assert response.json() == {\"detail\": \"Not authenticated\"}\n    assert response.headers[\"WWW-Authenticate\"] == \"Bearer\"\n\n\ndef test_openapi_schema():\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 200, response.text\n    assert response.json() == {\n        \"openapi\": \"3.1.0\",\n        \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n        \"paths\": {\n            \"/token\": {\n                \"post\": {\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\"$ref\": \"#/components/schemas/Token\"}\n                                }\n                            },\n                        },\n                        \"422\": {\n                            \"description\": \"Validation Error\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                    }\n                                }\n                            },\n                        },\n                    },\n                    \"summary\": \"Login For Access Token\",\n                    \"operationId\": \"login_for_access_token_token_post\",\n                    \"requestBody\": {\n                        \"content\": {\n                            \"application/x-www-form-urlencoded\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Body_login_for_access_token_token_post\"\n                                }\n                            }\n                        },\n                        \"required\": True,\n                    },\n                }\n            },\n            \"/users/me/\": {\n                \"get\": {\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\"$ref\": \"#/components/schemas/User\"}\n                                }\n                            },\n                        }\n                    },\n                    \"summary\": \"Read Users Me\",\n                    \"operationId\": \"read_users_me_users_me__get\",\n                    \"security\": [{\"OAuth2PasswordBearer\": [\"me\"]}],\n                }\n            },\n            \"/users/me/items/\": {\n                \"get\": {\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        }\n                    },\n                    \"summary\": \"Read Own Items\",\n                    \"operationId\": \"read_own_items_users_me_items__get\",\n                    \"security\": [{\"OAuth2PasswordBearer\": [\"items\", \"me\"]}],\n                }\n            },\n            \"/status/\": {\n                \"get\": {\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Successful Response\",\n                            \"content\": {\"application/json\": {\"schema\": {}}},\n                        }\n                    },\n                    \"summary\": \"Read System Status\",\n                    \"operationId\": \"read_system_status_status__get\",\n                    \"security\": [{\"OAuth2PasswordBearer\": []}],\n                }\n            },\n        },\n        \"components\": {\n            \"schemas\": {\n                \"User\": {\n                    \"title\": \"User\",\n                    \"required\": IsOneOf(\n                        [\"username\", \"email\", \"full_name\", \"disabled\"],\n                        # TODO: remove when deprecating Pydantic v1\n                        [\"username\"],\n                    ),\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"username\": {\"title\": \"Username\", \"type\": \"string\"},\n                        \"email\": IsDict(\n                            {\n                                \"title\": \"Email\",\n                                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            }\n                        )\n                        | IsDict(\n                            # TODO: remove when deprecating Pydantic v1\n                            {\"title\": \"Email\", \"type\": \"string\"}\n                        ),\n                        \"full_name\": IsDict(\n                            {\n                                \"title\": \"Full Name\",\n                                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            }\n                        )\n                        | IsDict(\n                            # TODO: remove when deprecating Pydantic v1\n                            {\"title\": \"Full Name\", \"type\": \"string\"}\n                        ),\n                        \"disabled\": IsDict(\n                            {\n                                \"title\": \"Disabled\",\n                                \"anyOf\": [{\"type\": \"boolean\"}, {\"type\": \"null\"}],\n                            }\n                        )\n                        | IsDict(\n                            # TODO: remove when deprecating Pydantic v1\n                            {\"title\": \"Disabled\", \"type\": \"boolean\"}\n                        ),\n                    },\n                },\n                \"Token\": {\n                    \"title\": \"Token\",\n                    \"required\": [\"access_token\", \"token_type\"],\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"access_token\": {\"title\": \"Access Token\", \"type\": \"string\"},\n                        \"token_type\": {\"title\": \"Token Type\", \"type\": \"string\"},\n                    },\n                },\n                \"Body_login_for_access_token_token_post\": {\n                    \"title\": \"Body_login_for_access_token_token_post\",\n                    \"required\": [\"username\", \"password\"],\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"grant_type\": IsDict(\n                            {\n                                \"title\": \"Grant Type\",\n                                \"anyOf\": [\n                                    {\"pattern\": \"password\", \"type\": \"string\"},\n                                    {\"type\": \"null\"},\n                                ],\n                            }\n                        )\n                        | IsDict(\n                            # TODO: remove when deprecating Pydantic v1\n                            {\n                                \"title\": \"Grant Type\",\n                                \"pattern\": \"password\",\n                                \"type\": \"string\",\n                            }\n                        ),\n                        \"username\": {\"title\": \"Username\", \"type\": \"string\"},\n                        \"password\": {\"title\": \"Password\", \"type\": \"string\"},\n                        \"scope\": {\"title\": \"Scope\", \"type\": \"string\", \"default\": \"\"},\n                        \"client_id\": IsDict(\n                            {\n                                \"title\": \"Client Id\",\n                                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            }\n                        )\n                        | IsDict(\n                            # TODO: remove when deprecating Pydantic v1\n                            {\"title\": \"Client Id\", \"type\": \"string\"}\n                        ),\n                        \"client_secret\": IsDict(\n                            {\n                                \"title\": \"Client Secret\",\n                                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n                            }\n                        )\n                        | IsDict(\n                            # TODO: remove when deprecating Pydantic v1\n                            {\"title\": \"Client Secret\", \"type\": \"string\"}\n                        ),\n                    },\n                },\n                \"ValidationError\": {\n                    \"title\": \"ValidationError\",\n                    \"required\": [\"loc\", \"msg\", \"type\"],\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"loc\": {\n                            \"title\": \"Location\",\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]\n                            },\n                        },\n                        \"msg\": {\"title\": \"Message\", \"type\": \"string\"},\n                        \"type\": {\"title\": \"Error Type\", \"type\": \"string\"},\n                    },\n                },\n                \"HTTPValidationError\": {\n                    \"title\": \"HTTPValidationError\",\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"detail\": {\n                            \"title\": \"Detail\",\n                            \"type\": \"array\",\n                            \"items\": {\"$ref\": \"#/components/schemas/ValidationError\"},\n                        }\n                    },\n                },\n            },\n            \"securitySchemes\": {\n                \"OAuth2PasswordBearer\": {\n                    \"type\": \"oauth2\",\n                    \"flows\": {\n                        \"password\": {\n                            \"scopes\": {\n                                \"me\": \"Read information about the current user.\",\n                                \"items\": \"Read items.\",\n                            },\n                            \"tokenUrl\": \"token\",\n                        }\n                    },\n                }\n            },\n        },\n    }\n", "file_name": "545558.py", "cwe": ["CWE-798: Use of Hard-coded Credentials"]}
{"source": "\"\"\"Support for Alexa skill auth.\"\"\"\n\nimport asyncio\nfrom asyncio import timeout\nfrom datetime import datetime, timedelta\nfrom http import HTTPStatus\nimport json\nimport logging\nfrom typing import Any\n\nimport aiohttp\n\nfrom homeassistant.const import CONF_CLIENT_ID, CONF_CLIENT_SECRET\nfrom homeassistant.core import HomeAssistant, callback\nfrom homeassistant.helpers import aiohttp_client\nfrom homeassistant.helpers.storage import Store\nfrom homeassistant.util import dt as dt_util\n\nfrom .const import STORAGE_ACCESS_TOKEN, STORAGE_REFRESH_TOKEN\nfrom .diagnostics import async_redact_lwa_params\n\n_LOGGER = logging.getLogger(__name__)\n\nLWA_TOKEN_URI = \"https://api.amazon.com/auth/o2/token\"\nLWA_HEADERS = {\"Content-Type\": \"application/x-www-form-urlencoded;charset=UTF-8\"}\n\nPREEMPTIVE_REFRESH_TTL_IN_SECONDS = 300\nSTORAGE_KEY = \"alexa_auth\"\nSTORAGE_VERSION = 1\nSTORAGE_EXPIRE_TIME = \"expire_time\"\n\n\nclass Auth:\n    \"\"\"Handle authentication to send events to Alexa.\"\"\"\n\n    def __init__(self, hass: HomeAssistant, client_id: str, client_secret: str) -> None:\n        \"\"\"Initialize the Auth class.\"\"\"\n        self.hass = hass\n\n        self.client_id = client_id\n        self.client_secret = client_secret\n\n        self._prefs: dict[str, Any] | None = None\n        self._store: Store = Store(hass, STORAGE_VERSION, STORAGE_KEY)\n\n        self._get_token_lock = asyncio.Lock()\n\n    async def async_do_auth(self, accept_grant_code: str) -> str | None:\n        \"\"\"Do authentication with an AcceptGrant code.\"\"\"\n        # access token not retrieved yet for the first time, so this should\n        # be an access token request\n\n        lwa_params: dict[str, str] = {\n            \"grant_type\": \"authorization_code\",\n            \"code\": accept_grant_code,\n            CONF_CLIENT_ID: self.client_id,\n            CONF_CLIENT_SECRET: self.client_secret,\n        }\n        _LOGGER.debug(\n            \"Calling LWA to get the access token (first time), with: %s\",\n            json.dumps(async_redact_lwa_params(lwa_params)),\n        )\n\n        return await self._async_request_new_token(lwa_params)\n\n    @callback\n    def async_invalidate_access_token(self) -> None:\n        \"\"\"Invalidate access token.\"\"\"\n        assert self._prefs is not None\n        self._prefs[STORAGE_ACCESS_TOKEN] = None\n\n    async def async_get_access_token(self) -> str | None:\n        \"\"\"Perform access token or token refresh request.\"\"\"\n        async with self._get_token_lock:\n            if self._prefs is None:\n                await self.async_load_preferences()\n\n            assert self._prefs is not None\n            if self.is_token_valid():\n                _LOGGER.debug(\"Token still valid, using it\")\n                token: str = self._prefs[STORAGE_ACCESS_TOKEN]\n                return token\n\n            if self._prefs[STORAGE_REFRESH_TOKEN] is None:\n                _LOGGER.debug(\"Token invalid and no refresh token available\")\n                return None\n\n            lwa_params: dict[str, str] = {\n                \"grant_type\": \"refresh_token\",\n                \"refresh_token\": self._prefs[STORAGE_REFRESH_TOKEN],\n                CONF_CLIENT_ID: self.client_id,\n                CONF_CLIENT_SECRET: self.client_secret,\n            }\n\n            _LOGGER.debug(\"Calling LWA to refresh the access token\")\n            return await self._async_request_new_token(lwa_params)\n\n    @callback\n    def is_token_valid(self) -> bool:\n        \"\"\"Check if a token is already loaded and if it is still valid.\"\"\"\n        assert self._prefs is not None\n        if not self._prefs[STORAGE_ACCESS_TOKEN]:\n            return False\n\n        expire_time: datetime | None = dt_util.parse_datetime(\n            self._prefs[STORAGE_EXPIRE_TIME]\n        )\n        assert expire_time is not None\n        preemptive_expire_time = expire_time - timedelta(\n            seconds=PREEMPTIVE_REFRESH_TTL_IN_SECONDS\n        )\n\n        return dt_util.utcnow() < preemptive_expire_time\n\n    async def _async_request_new_token(self, lwa_params: dict[str, str]) -> str | None:\n        try:\n            session = aiohttp_client.async_get_clientsession(self.hass)\n            async with timeout(10):\n                response = await session.post(\n                    LWA_TOKEN_URI,\n                    headers=LWA_HEADERS,\n                    data=lwa_params,\n                    allow_redirects=True,\n                )\n\n        except (TimeoutError, aiohttp.ClientError):\n            _LOGGER.error(\"Timeout calling LWA to get auth token\")\n            return None\n\n        _LOGGER.debug(\"LWA response header: %s\", response.headers)\n        _LOGGER.debug(\"LWA response status: %s\", response.status)\n\n        if response.status != HTTPStatus.OK:\n            _LOGGER.error(\"Error calling LWA to get auth token\")\n            return None\n\n        response_json = await response.json()\n        _LOGGER.debug(\"LWA response body  : %s\", async_redact_lwa_params(response_json))\n\n        access_token: str = response_json[\"access_token\"]\n        refresh_token: str = response_json[\"refresh_token\"]\n        expires_in: int = response_json[\"expires_in\"]\n        expire_time = dt_util.utcnow() + timedelta(seconds=expires_in)\n\n        await self._async_update_preferences(\n            access_token, refresh_token, expire_time.isoformat()\n        )\n\n        return access_token\n\n    async def async_load_preferences(self) -> None:\n        \"\"\"Load preferences with stored tokens.\"\"\"\n        self._prefs = await self._store.async_load()\n\n        if self._prefs is None:\n            self._prefs = {\n                STORAGE_ACCESS_TOKEN: None,\n                STORAGE_REFRESH_TOKEN: None,\n                STORAGE_EXPIRE_TIME: None,\n            }\n\n    async def _async_update_preferences(\n        self, access_token: str, refresh_token: str, expire_time: str\n    ) -> None:\n        \"\"\"Update user preferences.\"\"\"\n        if self._prefs is None:\n            await self.async_load_preferences()\n            assert self._prefs is not None\n\n        if access_token is not None:\n            self._prefs[STORAGE_ACCESS_TOKEN] = access_token\n        if refresh_token is not None:\n            self._prefs[STORAGE_REFRESH_TOKEN] = refresh_token\n        if expire_time is not None:\n            self._prefs[STORAGE_EXPIRE_TIME] = expire_time\n        await self._store.async_save(self._prefs)\n", "file_name": "695407.py", "cwe": ["CWE-532: Insertion of Sensitive Information into Log File"]}
{"source": "\"\"\"The Application Credentials integration.\n\nThis integration provides APIs for managing local OAuth credentials on behalf\nof other integrations. Integrations register an authorization server, and then\nthe APIs are used to add one or more client credentials. Integrations may also\nprovide credentials from yaml for backwards compatibility.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nimport logging\nfrom typing import Any, Protocol\n\nimport voluptuous as vol\n\nfrom homeassistant.components import websocket_api\nfrom homeassistant.components.websocket_api.connection import ActiveConnection\nfrom homeassistant.config_entries import ConfigEntry\nfrom homeassistant.const import (\n    CONF_CLIENT_ID,\n    CONF_CLIENT_SECRET,\n    CONF_DOMAIN,\n    CONF_ID,\n    CONF_NAME,\n)\nfrom homeassistant.core import HomeAssistant, callback\nfrom homeassistant.exceptions import HomeAssistantError\nfrom homeassistant.helpers import collection, config_entry_oauth2_flow\nimport homeassistant.helpers.config_validation as cv\nfrom homeassistant.helpers.storage import Store\nfrom homeassistant.helpers.typing import ConfigType, VolDictType\nfrom homeassistant.loader import (\n    IntegrationNotFound,\n    async_get_application_credentials,\n    async_get_integration,\n)\nfrom homeassistant.util import slugify\n\n__all__ = [\"ClientCredential\", \"AuthorizationServer\", \"async_import_client_credential\"]\n\n_LOGGER = logging.getLogger(__name__)\n\nDOMAIN = \"application_credentials\"\n\nSTORAGE_KEY = DOMAIN\nSTORAGE_VERSION = 1\nDATA_STORAGE = \"storage\"\nCONF_AUTH_DOMAIN = \"auth_domain\"\nDEFAULT_IMPORT_NAME = \"Import from configuration.yaml\"\n\nCREATE_FIELDS: VolDictType = {\n    vol.Required(CONF_DOMAIN): cv.string,\n    vol.Required(CONF_CLIENT_ID): vol.All(cv.string, vol.Strip),\n    vol.Required(CONF_CLIENT_SECRET): vol.All(cv.string, vol.Strip),\n    vol.Optional(CONF_AUTH_DOMAIN): cv.string,\n    vol.Optional(CONF_NAME): cv.string,\n}\nUPDATE_FIELDS: VolDictType = {}  # Not supported\n\nCONFIG_SCHEMA = cv.empty_config_schema(DOMAIN)\n\n\n@dataclass\nclass ClientCredential:\n    \"\"\"Represent an OAuth client credential.\"\"\"\n\n    client_id: str\n    client_secret: str\n    name: str | None = None\n\n\n@dataclass\nclass AuthorizationServer:\n    \"\"\"Represent an OAuth2 Authorization Server.\"\"\"\n\n    authorize_url: str\n    token_url: str\n\n\nclass ApplicationCredentialsStorageCollection(collection.DictStorageCollection):\n    \"\"\"Application credential collection stored in storage.\"\"\"\n\n    CREATE_SCHEMA = vol.Schema(CREATE_FIELDS)\n\n    async def _process_create_data(self, data: dict[str, str]) -> dict[str, str]:\n        \"\"\"Validate the config is valid.\"\"\"\n        result = self.CREATE_SCHEMA(data)\n        domain = result[CONF_DOMAIN]\n        if not await _get_platform(self.hass, domain):\n            raise ValueError(f\"No application_credentials platform for {domain}\")\n        return result\n\n    @callback\n    def _get_suggested_id(self, info: dict[str, str]) -> str:\n        \"\"\"Suggest an ID based on the config.\"\"\"\n        return f\"{info[CONF_DOMAIN]}.{info[CONF_CLIENT_ID]}\"\n\n    async def _update_data(\n        self, item: dict[str, str], update_data: dict[str, str]\n    ) -> dict[str, str]:\n        \"\"\"Return a new updated data object.\"\"\"\n        raise ValueError(\"Updates not supported\")\n\n    async def async_delete_item(self, item_id: str) -> None:\n        \"\"\"Delete item, verifying credential is not in use.\"\"\"\n        if item_id not in self.data:\n            raise collection.ItemNotFound(item_id)\n\n        # Cannot delete a credential currently in use by a ConfigEntry\n        current = self.data[item_id]\n        entries = self.hass.config_entries.async_entries(current[CONF_DOMAIN])\n        for entry in entries:\n            if entry.data.get(\"auth_implementation\") == item_id:\n                raise HomeAssistantError(\n                    f\"Cannot delete credential in use by integration {entry.domain}\"\n                )\n\n        await super().async_delete_item(item_id)\n\n    async def async_import_item(self, info: dict[str, str]) -> None:\n        \"\"\"Import an yaml credential if it does not already exist.\"\"\"\n        suggested_id = self._get_suggested_id(info)\n        if self.id_manager.has_id(slugify(suggested_id)):\n            return\n        await self.async_create_item(info)\n\n    def async_client_credentials(self, domain: str) -> dict[str, ClientCredential]:\n        \"\"\"Return ClientCredentials in storage for the specified domain.\"\"\"\n        credentials = {}\n        for item in self.async_items():\n            if item[CONF_DOMAIN] != domain:\n                continue\n            auth_domain = item.get(CONF_AUTH_DOMAIN, item[CONF_ID])\n            credentials[auth_domain] = ClientCredential(\n                client_id=item[CONF_CLIENT_ID],\n                client_secret=item[CONF_CLIENT_SECRET],\n                name=item.get(CONF_NAME),\n            )\n        return credentials\n\n\nasync def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:\n    \"\"\"Set up Application Credentials.\"\"\"\n    hass.data[DOMAIN] = {}\n\n    id_manager = collection.IDManager()\n    storage_collection = ApplicationCredentialsStorageCollection(\n        Store(hass, STORAGE_VERSION, STORAGE_KEY),\n        id_manager,\n    )\n    await storage_collection.async_load()\n    hass.data[DOMAIN][DATA_STORAGE] = storage_collection\n\n    collection.DictStorageCollectionWebsocket(\n        storage_collection, DOMAIN, DOMAIN, CREATE_FIELDS, UPDATE_FIELDS\n    ).async_setup(hass)\n\n    websocket_api.async_register_command(hass, handle_integration_list)\n    websocket_api.async_register_command(hass, handle_config_entry)\n\n    config_entry_oauth2_flow.async_add_implementation_provider(\n        hass, DOMAIN, _async_provide_implementation\n    )\n\n    return True\n\n\nasync def async_import_client_credential(\n    hass: HomeAssistant,\n    domain: str,\n    credential: ClientCredential,\n    auth_domain: str | None = None,\n) -> None:\n    \"\"\"Import an existing credential from configuration.yaml.\"\"\"\n    if DOMAIN not in hass.data:\n        raise ValueError(\"Integration 'application_credentials' not setup\")\n    storage_collection = hass.data[DOMAIN][DATA_STORAGE]\n    item = {\n        CONF_DOMAIN: domain,\n        CONF_CLIENT_ID: credential.client_id,\n        CONF_CLIENT_SECRET: credential.client_secret,\n        CONF_AUTH_DOMAIN: auth_domain if auth_domain else domain,\n    }\n    item[CONF_NAME] = credential.name if credential.name else DEFAULT_IMPORT_NAME\n    await storage_collection.async_import_item(item)\n\n\nclass AuthImplementation(config_entry_oauth2_flow.LocalOAuth2Implementation):\n    \"\"\"Application Credentials local oauth2 implementation.\"\"\"\n\n    def __init__(\n        self,\n        hass: HomeAssistant,\n        auth_domain: str,\n        credential: ClientCredential,\n        authorization_server: AuthorizationServer,\n    ) -> None:\n        \"\"\"Initialize AuthImplementation.\"\"\"\n        super().__init__(\n            hass,\n            auth_domain,\n            credential.client_id,\n            credential.client_secret,\n            authorization_server.authorize_url,\n            authorization_server.token_url,\n        )\n        self._name = credential.name\n\n    @property\n    def name(self) -> str:\n        \"\"\"Name of the implementation.\"\"\"\n        return self._name or self.client_id\n\n\nasync def _async_provide_implementation(\n    hass: HomeAssistant, domain: str\n) -> list[config_entry_oauth2_flow.AbstractOAuth2Implementation]:\n    \"\"\"Return registered OAuth implementations.\"\"\"\n\n    platform = await _get_platform(hass, domain)\n    if not platform:\n        return []\n\n    storage_collection = hass.data[DOMAIN][DATA_STORAGE]\n    credentials = storage_collection.async_client_credentials(domain)\n    if hasattr(platform, \"async_get_auth_implementation\"):\n        return [\n            await platform.async_get_auth_implementation(hass, auth_domain, credential)\n            for auth_domain, credential in credentials.items()\n        ]\n    authorization_server = await platform.async_get_authorization_server(hass)\n    return [\n        AuthImplementation(hass, auth_domain, credential, authorization_server)\n        for auth_domain, credential in credentials.items()\n    ]\n\n\nasync def _async_config_entry_app_credentials(\n    hass: HomeAssistant,\n    config_entry: ConfigEntry,\n) -> str | None:\n    \"\"\"Return the item id of an application credential for an existing ConfigEntry.\"\"\"\n    if not await _get_platform(hass, config_entry.domain) or not (\n        auth_domain := config_entry.data.get(\"auth_implementation\")\n    ):\n        return None\n\n    storage_collection = hass.data[DOMAIN][DATA_STORAGE]\n    for item in storage_collection.async_items():\n        item_id = item[CONF_ID]\n        if (\n            item[CONF_DOMAIN] == config_entry.domain\n            and item.get(CONF_AUTH_DOMAIN, item_id) == auth_domain\n        ):\n            return item_id\n    return None\n\n\nclass ApplicationCredentialsProtocol(Protocol):\n    \"\"\"Define the format that application_credentials platforms may have.\n\n    Most platforms typically just implement async_get_authorization_server, and\n    the default oauth implementation will be used. Otherwise a platform may\n    implement async_get_auth_implementation to give their use a custom\n    AbstractOAuth2Implementation.\n    \"\"\"\n\n    async def async_get_authorization_server(\n        self, hass: HomeAssistant\n    ) -> AuthorizationServer:\n        \"\"\"Return authorization server, for the default auth implementation.\"\"\"\n\n    async def async_get_auth_implementation(\n        self, hass: HomeAssistant, auth_domain: str, credential: ClientCredential\n    ) -> config_entry_oauth2_flow.AbstractOAuth2Implementation:\n        \"\"\"Return a custom auth implementation.\"\"\"\n\n    async def async_get_description_placeholders(\n        self, hass: HomeAssistant\n    ) -> dict[str, str]:\n        \"\"\"Return description placeholders for the credentials dialog.\"\"\"\n\n\nasync def _get_platform(\n    hass: HomeAssistant, integration_domain: str\n) -> ApplicationCredentialsProtocol | None:\n    \"\"\"Register an application_credentials platform.\"\"\"\n    try:\n        integration = await async_get_integration(hass, integration_domain)\n    except IntegrationNotFound as err:\n        _LOGGER.debug(\"Integration '%s' does not exist: %s\", integration_domain, err)\n        return None\n    try:\n        platform = await integration.async_get_platform(\"application_credentials\")\n    except ImportError as err:\n        _LOGGER.debug(\n            \"Integration '%s' does not provide application_credentials: %s\",\n            integration_domain,\n            err,\n        )\n        return None\n    if not hasattr(platform, \"async_get_authorization_server\") and not hasattr(\n        platform, \"async_get_auth_implementation\"\n    ):\n        raise ValueError(\n            f\"Integration '{integration_domain}' platform {DOMAIN} did not implement\"\n            \" 'async_get_authorization_server' or 'async_get_auth_implementation'\"\n        )\n    return platform\n\n\nasync def _async_integration_config(hass: HomeAssistant, domain: str) -> dict[str, Any]:\n    platform = await _get_platform(hass, domain)\n    if platform and hasattr(platform, \"async_get_description_placeholders\"):\n        placeholders = await platform.async_get_description_placeholders(hass)\n        return {\"description_placeholders\": placeholders}\n    return {}\n\n\n@websocket_api.websocket_command(\n    {vol.Required(\"type\"): \"application_credentials/config\"}\n)\n@websocket_api.async_response\nasync def handle_integration_list(\n    hass: HomeAssistant, connection: ActiveConnection, msg: dict[str, Any]\n) -> None:\n    \"\"\"Handle integrations command.\"\"\"\n    domains = await async_get_application_credentials(hass)\n    result = {\n        \"domains\": domains,\n        \"integrations\": {\n            domain: await _async_integration_config(hass, domain) for domain in domains\n        },\n    }\n    connection.send_result(msg[\"id\"], result)\n\n\n@websocket_api.websocket_command(\n    {\n        vol.Required(\"type\"): \"application_credentials/config_entry\",\n        vol.Required(\"config_entry_id\"): str,\n    }\n)\n@websocket_api.async_response\nasync def handle_config_entry(\n    hass: HomeAssistant, connection: ActiveConnection, msg: dict[str, Any]\n) -> None:\n    \"\"\"Return application credentials information for a config entry.\"\"\"\n    entry_id = msg[\"config_entry_id\"]\n    config_entry = hass.config_entries.async_get_entry(entry_id)\n    if not config_entry:\n        connection.send_error(\n            msg[\"id\"],\n            \"invalid_config_entry_id\",\n            f\"Config entry not found: {entry_id}\",\n        )\n        return\n    result = {}\n    if application_credentials_id := await _async_config_entry_app_credentials(\n        hass, config_entry\n    ):\n        result[\"application_credentials_id\"] = application_credentials_id\n    connection.send_result(msg[\"id\"], result)\n", "file_name": "549500.py", "cwe": ["CWE-532: Insertion of Sensitive Information into Log File"]}
{"source": "\"\"\"AWS platform for notify component.\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport base64\nimport json\nimport logging\nfrom typing import Any\n\nfrom aiobotocore.session import AioSession\n\nfrom homeassistant.components.notify import (\n    ATTR_DATA,\n    ATTR_TARGET,\n    ATTR_TITLE,\n    ATTR_TITLE_DEFAULT,\n    BaseNotificationService,\n)\nfrom homeassistant.const import (\n    CONF_NAME,\n    CONF_PLATFORM,\n    CONF_PROFILE_NAME,\n    CONF_SERVICE,\n)\nfrom homeassistant.core import HomeAssistant\nfrom homeassistant.helpers.json import JSONEncoder\nfrom homeassistant.helpers.typing import ConfigType, DiscoveryInfoType\n\nfrom .const import CONF_CONTEXT, CONF_CREDENTIAL_NAME, CONF_REGION, DATA_SESSIONS\n\n_LOGGER = logging.getLogger(__name__)\n\n\nasync def get_available_regions(hass, service):\n    \"\"\"Get available regions for a service.\"\"\"\n    session = AioSession()\n    return await session.get_available_regions(service)\n\n\nasync def async_get_service(\n    hass: HomeAssistant,\n    config: ConfigType,\n    discovery_info: DiscoveryInfoType | None = None,\n) -> AWSNotify | None:\n    \"\"\"Get the AWS notification service.\"\"\"\n    if discovery_info is None:\n        _LOGGER.error(\"Please config aws notify platform in aws component\")\n        return None\n\n    session = None\n\n    conf = discovery_info\n\n    service = conf[CONF_SERVICE]\n    region_name = conf[CONF_REGION]\n\n    available_regions = await get_available_regions(hass, service)\n    if region_name not in available_regions:\n        _LOGGER.error(\n            \"Region %s is not available for %s service, must in %s\",\n            region_name,\n            service,\n            available_regions,\n        )\n        return None\n\n    aws_config = conf.copy()\n\n    del aws_config[CONF_SERVICE]\n    del aws_config[CONF_REGION]\n    if CONF_PLATFORM in aws_config:\n        del aws_config[CONF_PLATFORM]\n    if CONF_NAME in aws_config:\n        del aws_config[CONF_NAME]\n    if CONF_CONTEXT in aws_config:\n        del aws_config[CONF_CONTEXT]\n\n    if not aws_config:\n        # no platform config, use the first aws component credential instead\n        if hass.data[DATA_SESSIONS]:\n            session = next(iter(hass.data[DATA_SESSIONS].values()))\n        else:\n            _LOGGER.error(\"Missing aws credential for %s\", config[CONF_NAME])\n            return None\n\n    if session is None:\n        credential_name = aws_config.get(CONF_CREDENTIAL_NAME)\n        if credential_name is not None:\n            session = hass.data[DATA_SESSIONS].get(credential_name)\n            if session is None:\n                _LOGGER.warning(\"No available aws session for %s\", credential_name)\n            del aws_config[CONF_CREDENTIAL_NAME]\n\n    if session is None:\n        if (profile := aws_config.get(CONF_PROFILE_NAME)) is not None:\n            session = AioSession(profile=profile)\n            del aws_config[CONF_PROFILE_NAME]\n        else:\n            session = AioSession()\n\n    aws_config[CONF_REGION] = region_name\n\n    if service == \"lambda\":\n        context_str = json.dumps(\n            {\"custom\": conf.get(CONF_CONTEXT, {})}, cls=JSONEncoder\n        )\n        context_b64 = base64.b64encode(context_str.encode(\"utf-8\"))\n        context = context_b64.decode(\"utf-8\")\n        return AWSLambda(session, aws_config, context)\n\n    if service == \"sns\":\n        return AWSSNS(session, aws_config)\n\n    if service == \"sqs\":\n        return AWSSQS(session, aws_config)\n\n    if service == \"events\":\n        return AWSEventBridge(session, aws_config)\n\n    # should not reach here since service was checked in schema\n    return None\n\n\nclass AWSNotify(BaseNotificationService):\n    \"\"\"Implement the notification service for the AWS service.\"\"\"\n\n    def __init__(self, session, aws_config):\n        \"\"\"Initialize the service.\"\"\"\n        self.session = session\n        self.aws_config = aws_config\n\n\nclass AWSLambda(AWSNotify):\n    \"\"\"Implement the notification service for the AWS Lambda service.\"\"\"\n\n    service = \"lambda\"\n\n    def __init__(self, session, aws_config, context):\n        \"\"\"Initialize the service.\"\"\"\n        super().__init__(session, aws_config)\n        self.context = context\n\n    async def async_send_message(self, message: str = \"\", **kwargs: Any) -> None:\n        \"\"\"Send notification to specified LAMBDA ARN.\"\"\"\n        if not kwargs.get(ATTR_TARGET):\n            _LOGGER.error(\"At least one target is required\")\n            return\n\n        cleaned_kwargs = {k: v for k, v in kwargs.items() if v is not None}\n        payload = {\"message\": message}\n        payload.update(cleaned_kwargs)\n        json_payload = json.dumps(payload)\n\n        async with self.session.create_client(\n            self.service, **self.aws_config\n        ) as client:\n            tasks = [\n                client.invoke(\n                    FunctionName=target,\n                    Payload=json_payload,\n                    ClientContext=self.context,\n                )\n                for target in kwargs.get(ATTR_TARGET, [])\n            ]\n\n            if tasks:\n                await asyncio.gather(*tasks)\n\n\nclass AWSSNS(AWSNotify):\n    \"\"\"Implement the notification service for the AWS SNS service.\"\"\"\n\n    service = \"sns\"\n\n    async def async_send_message(self, message: str = \"\", **kwargs: Any) -> None:\n        \"\"\"Send notification to specified SNS ARN.\"\"\"\n        if not kwargs.get(ATTR_TARGET):\n            _LOGGER.error(\"At least one target is required\")\n            return\n\n        message_attributes = {}\n        if data := kwargs.get(ATTR_DATA):\n            message_attributes = {\n                k: {\"StringValue\": v, \"DataType\": \"String\"}\n                for k, v in data.items()\n                if v is not None\n            }\n        subject = kwargs.get(ATTR_TITLE, ATTR_TITLE_DEFAULT)\n\n        async with self.session.create_client(\n            self.service, **self.aws_config\n        ) as client:\n            tasks = [\n                client.publish(\n                    TargetArn=target,\n                    Message=message,\n                    Subject=subject,\n                    MessageAttributes=message_attributes,\n                )\n                for target in kwargs.get(ATTR_TARGET, [])\n            ]\n\n            if tasks:\n                await asyncio.gather(*tasks)\n\n\nclass AWSSQS(AWSNotify):\n    \"\"\"Implement the notification service for the AWS SQS service.\"\"\"\n\n    service = \"sqs\"\n\n    async def async_send_message(self, message: str = \"\", **kwargs: Any) -> None:\n        \"\"\"Send notification to specified SQS ARN.\"\"\"\n        if not kwargs.get(ATTR_TARGET):\n            _LOGGER.error(\"At least one target is required\")\n            return\n\n        cleaned_kwargs = {k: v for k, v in kwargs.items() if v is not None}\n        message_body = {\"message\": message}\n        message_body.update(cleaned_kwargs)\n        json_body = json.dumps(message_body)\n        message_attributes = {}\n        for key, val in cleaned_kwargs.items():\n            message_attributes[key] = {\n                \"StringValue\": json.dumps(val),\n                \"DataType\": \"String\",\n            }\n\n        async with self.session.create_client(\n            self.service, **self.aws_config\n        ) as client:\n            tasks = [\n                client.send_message(\n                    QueueUrl=target,\n                    MessageBody=json_body,\n                    MessageAttributes=message_attributes,\n                )\n                for target in kwargs.get(ATTR_TARGET, [])\n            ]\n\n            if tasks:\n                await asyncio.gather(*tasks)\n\n\nclass AWSEventBridge(AWSNotify):\n    \"\"\"Implement the notification service for the AWS EventBridge service.\"\"\"\n\n    service = \"events\"\n\n    async def async_send_message(self, message: str = \"\", **kwargs: Any) -> None:\n        \"\"\"Send notification to specified EventBus.\"\"\"\n\n        cleaned_kwargs = {k: v for k, v in kwargs.items() if v is not None}\n        data = cleaned_kwargs.get(ATTR_DATA, {})\n        detail = (\n            json.dumps(data[\"detail\"])\n            if \"detail\" in data\n            else json.dumps({\"message\": message})\n        )\n\n        async with self.session.create_client(\n            self.service, **self.aws_config\n        ) as client:\n            entries = []\n            for target in kwargs.get(ATTR_TARGET, [None]):\n                entry = {\n                    \"Source\": data.get(\"source\", \"homeassistant\"),\n                    \"Resources\": data.get(\"resources\", []),\n                    \"Detail\": detail,\n                    \"DetailType\": data.get(\"detail_type\", \"\"),\n                }\n                if target:\n                    entry[\"EventBusName\"] = target\n\n                entries.append(entry)\n            tasks = [\n                client.put_events(Entries=entries[i : min(i + 10, len(entries))])\n                for i in range(0, len(entries), 10)\n            ]\n\n            if tasks:\n                results = await asyncio.gather(*tasks)\n                for result in results:\n                    for entry in result[\"Entries\"]:\n                        if len(entry.get(\"EventId\", \"\")) == 0:\n                            _LOGGER.error(\n                                \"Failed to send event: ErrorCode=%s ErrorMessage=%s\",\n                                entry[\"ErrorCode\"],\n                                entry[\"ErrorMessage\"],\n                            )\n", "file_name": "804802.py", "cwe": ["CWE-532: Insertion of Sensitive Information into Log File"]}
{"source": "\nfrom transformers import AutoModel, AutoTokenizer\nimport time\nimport os\nimport json\nimport threading\nimport importlib\nfrom toolbox import update_ui, get_conf\nfrom multiprocessing import Process, Pipe\n\nload_message = \"ChatGLMFT\u5c1a\u672a\u52a0\u8f7d\uff0c\u52a0\u8f7d\u9700\u8981\u4e00\u6bb5\u65f6\u95f4\u3002\u6ce8\u610f\uff0c\u53d6\u51b3\u4e8e`config.py`\u7684\u914d\u7f6e\uff0cChatGLMFT\u6d88\u8017\u5927\u91cf\u7684\u5185\u5b58\uff08CPU\uff09\u6216\u663e\u5b58\uff08GPU\uff09\uff0c\u4e5f\u8bb8\u4f1a\u5bfc\u81f4\u4f4e\u914d\u8ba1\u7b97\u673a\u5361\u6b7b \u2026\u2026\"\n\ndef string_to_options(arguments):\n    import argparse\n    import shlex\n    # Create an argparse.ArgumentParser instance\n    parser = argparse.ArgumentParser()\n    # Add command-line arguments\n    parser.add_argument(\"--llm_to_learn\", type=str, help=\"LLM model to learn\", default=\"gpt-3.5-turbo\")\n    parser.add_argument(\"--prompt_prefix\", type=str, help=\"Prompt prefix\", default='')\n    parser.add_argument(\"--system_prompt\", type=str, help=\"System prompt\", default='')\n    parser.add_argument(\"--batch\", type=int, help=\"System prompt\", default=50)\n    # Parse the arguments\n    args = parser.parse_args(shlex.split(arguments))\n    return args\n\n\n#################################################################################\nclass GetGLMFTHandle(Process):\n    def __init__(self):\n        super().__init__(daemon=True)\n        self.parent, self.child = Pipe()\n        self.chatglmft_model = None\n        self.chatglmft_tokenizer = None\n        self.info = \"\"\n        self.success = True\n        self.check_dependency()\n        self.start()\n        self.threadLock = threading.Lock()\n\n    def check_dependency(self):\n        try:\n            import sentencepiece\n            self.info = \"\u4f9d\u8d56\u68c0\u6d4b\u901a\u8fc7\"\n            self.success = True\n        except:\n            self.info = \"\u7f3a\u5c11ChatGLMFT\u7684\u4f9d\u8d56\uff0c\u5982\u679c\u8981\u4f7f\u7528ChatGLMFT\uff0c\u9664\u4e86\u57fa\u7840\u7684pip\u4f9d\u8d56\u4ee5\u5916\uff0c\u60a8\u8fd8\u9700\u8981\u8fd0\u884c`pip install -r request_llms/requirements_chatglm.txt`\u5b89\u88c5ChatGLM\u7684\u4f9d\u8d56\u3002\"\n            self.success = False\n\n    def ready(self):\n        return self.chatglmft_model is not None\n\n    def run(self):\n        # \u5b50\u8fdb\u7a0b\u6267\u884c\n        # \u7b2c\u4e00\u6b21\u8fd0\u884c\uff0c\u52a0\u8f7d\u53c2\u6570\n        retry = 0\n        while True:\n            try:\n                if self.chatglmft_model is None:\n                    from transformers import AutoConfig\n                    import torch\n                    # conf = 'request_llms/current_ptune_model.json'\n                    # if not os.path.exists(conf): raise RuntimeError('\u627e\u4e0d\u5230\u5fae\u8c03\u6a21\u578b\u4fe1\u606f')\n                    # with open(conf, 'r', encoding='utf8') as f:\n                    #     model_args = json.loads(f.read())\n                    CHATGLM_PTUNING_CHECKPOINT = get_conf('CHATGLM_PTUNING_CHECKPOINT')\n                    assert os.path.exists(CHATGLM_PTUNING_CHECKPOINT), \"\u627e\u4e0d\u5230\u5fae\u8c03\u6a21\u578b\u68c0\u67e5\u70b9\"\n                    conf = os.path.join(CHATGLM_PTUNING_CHECKPOINT, \"config.json\")\n                    with open(conf, 'r', encoding='utf8') as f:\n                        model_args = json.loads(f.read())\n                    if 'model_name_or_path' not in model_args:\n                        model_args['model_name_or_path'] = model_args['_name_or_path']\n                    self.chatglmft_tokenizer = AutoTokenizer.from_pretrained(\n                        model_args['model_name_or_path'], trust_remote_code=True)\n                    config = AutoConfig.from_pretrained(\n                        model_args['model_name_or_path'], trust_remote_code=True)\n\n                    config.pre_seq_len = model_args['pre_seq_len']\n                    config.prefix_projection = model_args['prefix_projection']\n\n                    print(f\"Loading prefix_encoder weight from {CHATGLM_PTUNING_CHECKPOINT}\")\n                    model = AutoModel.from_pretrained(model_args['model_name_or_path'], config=config, trust_remote_code=True)\n                    prefix_state_dict = torch.load(os.path.join(CHATGLM_PTUNING_CHECKPOINT, \"pytorch_model.bin\"))\n                    new_prefix_state_dict = {}\n                    for k, v in prefix_state_dict.items():\n                        if k.startswith(\"transformer.prefix_encoder.\"):\n                            new_prefix_state_dict[k[len(\"transformer.prefix_encoder.\"):]] = v\n                    model.transformer.prefix_encoder.load_state_dict(new_prefix_state_dict)\n\n                    if model_args['quantization_bit'] is not None and model_args['quantization_bit'] != 0:\n                        print(f\"Quantized to {model_args['quantization_bit']} bit\")\n                        model = model.quantize(model_args['quantization_bit'])\n                    model = model.cuda()\n                    if model_args['pre_seq_len'] is not None:\n                        # P-tuning v2\n                        model.transformer.prefix_encoder.float()\n                    self.chatglmft_model = model.eval()\n\n                    break\n                else:\n                    break\n            except Exception as e:\n                retry += 1\n                if retry > 3:\n                    self.child.send('[Local Message] Call ChatGLMFT fail \u4e0d\u80fd\u6b63\u5e38\u52a0\u8f7dChatGLMFT\u7684\u53c2\u6570\u3002')\n                    raise RuntimeError(\"\u4e0d\u80fd\u6b63\u5e38\u52a0\u8f7dChatGLMFT\u7684\u53c2\u6570\uff01\")\n\n        while True:\n            # \u8fdb\u5165\u4efb\u52a1\u7b49\u5f85\u72b6\u6001\n            kwargs = self.child.recv()\n            # \u6536\u5230\u6d88\u606f\uff0c\u5f00\u59cb\u8bf7\u6c42\n            try:\n                for response, history in self.chatglmft_model.stream_chat(self.chatglmft_tokenizer, **kwargs):\n                    self.child.send(response)\n                    # # \u4e2d\u9014\u63a5\u6536\u53ef\u80fd\u7684\u7ec8\u6b62\u6307\u4ee4\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\n                    # if self.child.poll():\n                    #     command = self.child.recv()\n                    #     if command == '[Terminate]': break\n            except:\n                from toolbox import trimmed_format_exc\n                self.child.send('[Local Message] Call ChatGLMFT fail.' + '\\n```\\n' + trimmed_format_exc() + '\\n```\\n')\n            # \u8bf7\u6c42\u5904\u7406\u7ed3\u675f\uff0c\u5f00\u59cb\u4e0b\u4e00\u4e2a\u5faa\u73af\n            self.child.send('[Finish]')\n\n    def stream_chat(self, **kwargs):\n        # \u4e3b\u8fdb\u7a0b\u6267\u884c\n        self.threadLock.acquire()\n        self.parent.send(kwargs)\n        while True:\n            res = self.parent.recv()\n            if res != '[Finish]':\n                yield res\n            else:\n                break\n        self.threadLock.release()\n\nglobal glmft_handle\nglmft_handle = None\n#################################################################################\ndef predict_no_ui_long_connection(inputs:str, llm_kwargs:dict, history:list=[], sys_prompt:str=\"\",\n                                  observe_window:list=[], console_slience:bool=False):\n    \"\"\"\n        \u591a\u7ebf\u7a0b\u65b9\u6cd5\n        \u51fd\u6570\u7684\u8bf4\u660e\u8bf7\u89c1 request_llms/bridge_all.py\n    \"\"\"\n    global glmft_handle\n    if glmft_handle is None:\n        glmft_handle = GetGLMFTHandle()\n        if len(observe_window) >= 1: observe_window[0] = load_message + \"\\n\\n\" + glmft_handle.info\n        if not glmft_handle.success:\n            error = glmft_handle.info\n            glmft_handle = None\n            raise RuntimeError(error)\n\n    # chatglmft \u6ca1\u6709 sys_prompt \u63a5\u53e3\uff0c\u56e0\u6b64\u628aprompt\u52a0\u5165 history\n    history_feedin = []\n    history_feedin.append([\"What can I do?\", sys_prompt])\n    for i in range(len(history)//2):\n        history_feedin.append([history[2*i], history[2*i+1]] )\n\n    watch_dog_patience = 5 # \u770b\u95e8\u72d7 (watchdog) \u7684\u8010\u5fc3, \u8bbe\u7f6e5\u79d2\u5373\u53ef\n    response = \"\"\n    for response in glmft_handle.stream_chat(query=inputs, history=history_feedin, max_length=llm_kwargs['max_length'], top_p=llm_kwargs['top_p'], temperature=llm_kwargs['temperature']):\n        if len(observe_window) >= 1:  observe_window[0] = response\n        if len(observe_window) >= 2:\n            if (time.time()-observe_window[1]) > watch_dog_patience:\n                raise RuntimeError(\"\u7a0b\u5e8f\u7ec8\u6b62\u3002\")\n    return response\n\n\n\ndef predict(inputs, llm_kwargs, plugin_kwargs, chatbot, history=[], system_prompt='', stream = True, additional_fn=None):\n    \"\"\"\n        \u5355\u7ebf\u7a0b\u65b9\u6cd5\n        \u51fd\u6570\u7684\u8bf4\u660e\u8bf7\u89c1 request_llms/bridge_all.py\n    \"\"\"\n    chatbot.append((inputs, \"\"))\n\n    global glmft_handle\n    if glmft_handle is None:\n        glmft_handle = GetGLMFTHandle()\n        chatbot[-1] = (inputs, load_message + \"\\n\\n\" + glmft_handle.info)\n        yield from update_ui(chatbot=chatbot, history=[])\n        if not glmft_handle.success:\n            glmft_handle = None\n            return\n\n    if additional_fn is not None:\n        from core_functional import handle_core_functionality\n        inputs, history = handle_core_functionality(additional_fn, inputs, history, chatbot)\n\n    # \u5904\u7406\u5386\u53f2\u4fe1\u606f\n    history_feedin = []\n    history_feedin.append([\"What can I do?\", system_prompt] )\n    for i in range(len(history)//2):\n        history_feedin.append([history[2*i], history[2*i+1]] )\n\n    # \u5f00\u59cb\u63a5\u6536chatglmft\u7684\u56de\u590d\n    response = \"[Local Message] \u7b49\u5f85ChatGLMFT\u54cd\u5e94\u4e2d ...\"\n    for response in glmft_handle.stream_chat(query=inputs, history=history_feedin, max_length=llm_kwargs['max_length'], top_p=llm_kwargs['top_p'], temperature=llm_kwargs['temperature']):\n        chatbot[-1] = (inputs, response)\n        yield from update_ui(chatbot=chatbot, history=history)\n\n    # \u603b\u7ed3\u8f93\u51fa\n    if response == \"[Local Message] \u7b49\u5f85ChatGLMFT\u54cd\u5e94\u4e2d ...\":\n        response = \"[Local Message] ChatGLMFT\u54cd\u5e94\u5f02\u5e38 ...\"\n    history.extend([inputs, response])\n    yield from update_ui(chatbot=chatbot, history=history)\n", "file_name": "458056.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "# -*- coding: utf-8 -*-\n# Copyright: (c) 2022, Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\"\"\"Signature verification helpers.\"\"\"\nfrom __future__ import annotations\n\nfrom ansible.errors import AnsibleError\nfrom ansible.galaxy.user_agent import user_agent\nfrom ansible.module_utils.urls import open_url\n\nimport contextlib\nimport inspect\nimport os\nimport subprocess\nimport typing as t\n\nfrom dataclasses import dataclass, fields as dc_fields\nfrom urllib.error import HTTPError, URLError\n\nif t.TYPE_CHECKING:\n    from ansible.utils.display import Display\n\n\ndef get_signature_from_source(source, display=None):  # type: (str, t.Optional[Display]) -> str\n    if display is not None:\n        display.vvvv(f\"Using signature at {source}\")\n    try:\n        with open_url(\n            source,\n            http_agent=user_agent(),\n            validate_certs=True,\n            follow_redirects='safe'\n        ) as resp:\n            signature = resp.read()\n    except (HTTPError, URLError) as e:\n        raise AnsibleError(\n            f\"Failed to get signature for collection verification from '{source}': {e}\"\n        ) from e\n\n    return signature\n\n\ndef run_gpg_verify(\n    manifest_file,  # type: str\n    signature,  # type: str\n    keyring,  # type: str\n    display,  # type: Display\n):  # type: (...) -> tuple[str, int]\n    status_fd_read, status_fd_write = os.pipe()\n\n    # running the gpg command will create the keyring if it does not exist\n    remove_keybox = not os.path.exists(keyring)\n\n    cmd = [\n        'gpg',\n        f'--status-fd={status_fd_write}',\n        '--verify',\n        '--batch',\n        '--no-tty',\n        '--no-default-keyring',\n        f'--keyring={keyring}',\n        '-',\n        manifest_file,\n    ]\n    cmd_str = ' '.join(cmd)\n    display.vvvv(f\"Running command '{cmd}'\")\n\n    try:\n        p = subprocess.Popen(\n            cmd,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            pass_fds=(status_fd_write,),\n            encoding='utf8',\n        )\n    except (FileNotFoundError, subprocess.SubprocessError) as err:\n        raise AnsibleError(\n            f\"Failed during GnuPG verification with command '{cmd_str}': {err}\"\n        ) from err\n    else:\n        stdout, stderr = p.communicate(input=signature)\n    finally:\n        os.close(status_fd_write)\n\n    if remove_keybox:\n        with contextlib.suppress(OSError):\n            os.remove(keyring)\n\n    with os.fdopen(status_fd_read) as f:\n        stdout = f.read()\n        display.vvvv(\n            f\"stdout: \\n{stdout}\\nstderr: \\n{stderr}\\n(exit code {p.returncode})\"\n        )\n        return stdout, p.returncode\n\n\ndef parse_gpg_errors(status_out):  # type: (str) -> t.Iterator[GpgBaseError]\n    for line in status_out.splitlines():\n        if not line:\n            continue\n        try:\n            _dummy, status, remainder = line.split(maxsplit=2)\n        except ValueError:\n            _dummy, status = line.split(maxsplit=1)\n            remainder = None\n\n        try:\n            cls = GPG_ERROR_MAP[status]\n        except KeyError:\n            continue\n\n        fields = [status]\n        if remainder:\n            fields.extend(\n                remainder.split(\n                    None,\n                    len(dc_fields(cls)) - 2\n                )\n            )\n\n        yield cls(*fields)\n\n\n@dataclass(frozen=True, slots=True)\nclass GpgBaseError(Exception):\n    status: str\n\n    @classmethod\n    def get_gpg_error_description(cls) -> str:\n        \"\"\"Return the current class description.\"\"\"\n        return ' '.join(cls.__doc__.split())\n\n    def __post_init__(self):\n        for field_name, field_type in inspect.get_annotations(type(self), eval_str=True).items():\n            super(GpgBaseError, self).__setattr__(field_name, field_type(getattr(self, field_name)))\n\n\n@dataclass(frozen=True, slots=True)\nclass GpgExpSig(GpgBaseError):\n    \"\"\"The signature with the keyid is good, but the signature is expired.\"\"\"\n    keyid: str\n    username: str\n\n\n@dataclass(frozen=True, slots=True)\nclass GpgExpKeySig(GpgBaseError):\n    \"\"\"The signature with the keyid is good, but the signature was made by an expired key.\"\"\"\n    keyid: str\n    username: str\n\n\n@dataclass(frozen=True, slots=True)\nclass GpgRevKeySig(GpgBaseError):\n    \"\"\"The signature with the keyid is good, but the signature was made by a revoked key.\"\"\"\n    keyid: str\n    username: str\n\n\n@dataclass(frozen=True, slots=True)\nclass GpgBadSig(GpgBaseError):\n    \"\"\"The signature with the keyid has not been verified okay.\"\"\"\n    keyid: str\n    username: str\n\n\n@dataclass(frozen=True, slots=True)\nclass GpgErrSig(GpgBaseError):\n    \"\"\"\"It was not possible to check the signature.  This may be caused by\n    a missing public key or an unsupported algorithm.  A RC of 4\n    indicates unknown algorithm, a 9 indicates a missing public\n    key.\n    \"\"\"\n    keyid: str\n    pkalgo: int\n    hashalgo: int\n    sig_class: str\n    time: int\n    rc: int\n    fpr: str\n\n\n@dataclass(frozen=True, slots=True)\nclass GpgNoPubkey(GpgBaseError):\n    \"\"\"The public key is not available.\"\"\"\n    keyid: str\n\n\n@dataclass(frozen=True, slots=True)\nclass GpgMissingPassPhrase(GpgBaseError):\n    \"\"\"No passphrase was supplied.\"\"\"\n\n\n@dataclass(frozen=True, slots=True)\nclass GpgBadPassphrase(GpgBaseError):\n    \"\"\"The supplied passphrase was wrong or not given.\"\"\"\n    keyid: str\n\n\n@dataclass(frozen=True, slots=True)\nclass GpgNoData(GpgBaseError):\n    \"\"\"No data has been found.  Codes for WHAT are:\n    - 1 :: No armored data.\n    - 2 :: Expected a packet but did not find one.\n    - 3 :: Invalid packet found, this may indicate a non OpenPGP\n           message.\n    - 4 :: Signature expected but not found.\n    \"\"\"\n    what: str\n\n\n@dataclass(frozen=True, slots=True)\nclass GpgUnexpected(GpgBaseError):\n    \"\"\"No data has been found.  Codes for WHAT are:\n    - 1 :: No armored data.\n    - 2 :: Expected a packet but did not find one.\n    - 3 :: Invalid packet found, this may indicate a non OpenPGP\n           message.\n    - 4 :: Signature expected but not found.\n    \"\"\"\n    what: str\n\n\n@dataclass(frozen=True, slots=True)\nclass GpgError(GpgBaseError):\n    \"\"\"This is a generic error status message, it might be followed by error location specific data.\"\"\"\n    location: str\n    code: int\n    more: str = \"\"\n\n\n@dataclass(frozen=True, slots=True)\nclass GpgFailure(GpgBaseError):\n    \"\"\"This is the counterpart to SUCCESS and used to indicate a program failure.\"\"\"\n    location: str\n    code: int\n\n\n@dataclass(frozen=True, slots=True)\nclass GpgBadArmor(GpgBaseError):\n    \"\"\"The ASCII armor is corrupted.\"\"\"\n\n\n@dataclass(frozen=True, slots=True)\nclass GpgKeyExpired(GpgBaseError):\n    \"\"\"The key has expired.\"\"\"\n    timestamp: int\n\n\n@dataclass(frozen=True, slots=True)\nclass GpgKeyRevoked(GpgBaseError):\n    \"\"\"The used key has been revoked by its owner.\"\"\"\n\n\n@dataclass(frozen=True, slots=True)\nclass GpgNoSecKey(GpgBaseError):\n    \"\"\"The secret key is not available.\"\"\"\n    keyid: str\n\n\nGPG_ERROR_MAP = {\n    'EXPSIG': GpgExpSig,\n    'EXPKEYSIG': GpgExpKeySig,\n    'REVKEYSIG': GpgRevKeySig,\n    'BADSIG': GpgBadSig,\n    'ERRSIG': GpgErrSig,\n    'NO_PUBKEY': GpgNoPubkey,\n    'MISSING_PASSPHRASE': GpgMissingPassPhrase,\n    'BAD_PASSPHRASE': GpgBadPassphrase,\n    'NODATA': GpgNoData,\n    'UNEXPECTED': GpgUnexpected,\n    'ERROR': GpgError,\n    'FAILURE': GpgFailure,\n    'BADARMOR': GpgBadArmor,\n    'KEYEXPIRED': GpgKeyExpired,\n    'KEYREVOKED': GpgKeyRevoked,\n    'NO_SECKEY': GpgNoSecKey,\n}\n", "file_name": "539416.py", "cwe": ["Unknown"]}
{"source": "# (c) 2013, Jayson Vantuyl <jayson@aggressive.ly>\n# (c) 2012-17 Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\nfrom __future__ import annotations\n\nDOCUMENTATION = \"\"\"\n    name: sequence\n    author: Jayson Vantuyl (!UNKNOWN) <jayson@aggressive.ly>\n    version_added: \"1.0\"\n    short_description: generate a list based on a number sequence\n    description:\n      - generates a sequence of items. You can specify a start value, an end value, an optional \"stride\" value that specifies the number of steps\n        to increment the sequence, and an optional printf-style format string.\n      - 'Arguments can be specified as key=value pair strings or as a shortcut form of the arguments string is also accepted: [start-]end[/stride][:format].'\n      - 'Numerical values can be specified in decimal, hexadecimal (0x3f8) or octal (0600).'\n      - Starting at version 1.9.2, negative strides are allowed.\n      - Generated items are strings. Use Jinja2 filters to convert items to preferred type, e.g. C({{ 1 + item|int }}).\n      - See also Jinja2 C(range) filter as an alternative.\n    options:\n      start:\n        description: number at which to start the sequence\n        default: 1\n        type: integer\n      end:\n        description: number at which to end the sequence, dont use this with count\n        type: integer\n      count:\n        description: number of elements in the sequence, this is not to be used with end\n        type: integer\n      stride:\n        description: increments between sequence numbers, the default is 1 unless the end is less than the start, then it is -1.\n        type: integer\n        default: 1\n      format:\n        description: return a string with the generated number formatted in\n        default: \"%d\"\n\"\"\"\n\nEXAMPLES = \"\"\"\n- name: create some test users\n  ansible.builtin.user:\n    name: \"{{ item }}\"\n    state: present\n    groups: \"evens\"\n  with_sequence: start=0 end=32 format=testuser%02x\n\n- name: create a series of directories with even numbers for some reason\n  ansible.builtin.file:\n    dest: \"/var/stuff/{{ item }}\"\n    state: directory\n  with_sequence: start=4 end=16 stride=2\n\n- name: a simpler way to use the sequence plugin create 4 groups\n  ansible.builtin.group:\n    name: \"group{{ item }}\"\n    state: present\n  with_sequence: count=4\n\n- name: the final countdown\n  ansible.builtin.debug:\n    msg: \"{{item}} seconds to detonation\"\n  with_sequence: start=10 end=0 stride=-1\n\n- name: Use of variable\n  ansible.builtin.debug:\n    msg: \"{{ item }}\"\n  with_sequence: start=1 end=\"{{ end_at }}\"\n  vars:\n    - end_at: 10\n\"\"\"\n\nRETURN = \"\"\"\n  _list:\n    description:\n      - A list containing generated sequence of items\n    type: list\n    elements: str\n\"\"\"\n\nfrom re import compile as re_compile, IGNORECASE\n\nfrom ansible.errors import AnsibleError\nfrom ansible.parsing.splitter import parse_kv\nfrom ansible.plugins.lookup import LookupBase\n\n\n# shortcut format\nNUM = \"(0?x?[0-9a-f]+)\"\nSHORTCUT = re_compile(\n    \"^(\" +        # Group 0\n    NUM +         # Group 1: Start\n    \"-)?\" +\n    NUM +         # Group 2: End\n    \"(/\" +        # Group 3\n    NUM +         # Group 4: Stride\n    \")?\" +\n    \"(:(.+))?$\",  # Group 5, Group 6: Format String\n    IGNORECASE\n)\nFIELDS = frozenset(('start', 'end', 'stride', 'count', 'format'))\n\n\nclass LookupModule(LookupBase):\n    \"\"\"\n    sequence lookup module\n\n    Used to generate some sequence of items. Takes arguments in two forms.\n\n    The simple / shortcut form is:\n\n      [start-]end[/stride][:format]\n\n    As indicated by the brackets: start, stride, and format string are all\n    optional.  The format string is in the style of printf.  This can be used\n    to pad with zeros, format in hexadecimal, etc.  All of the numerical values\n    can be specified in octal (i.e. 0664) or hexadecimal (i.e. 0x3f8).\n    Negative numbers are not supported.\n\n    Some examples:\n\n      5 -> [\"1\",\"2\",\"3\",\"4\",\"5\"]\n      5-8 -> [\"5\", \"6\", \"7\", \"8\"]\n      2-10/2 -> [\"2\", \"4\", \"6\", \"8\", \"10\"]\n      4:host%02d -> [\"host01\",\"host02\",\"host03\",\"host04\"]\n\n    The standard Ansible key-value form is accepted as well.  For example:\n\n      start=5 end=11 stride=2 format=0x%02x -> [\"0x05\",\"0x07\",\"0x09\",\"0x0a\"]\n\n    This format takes an alternate form of \"end\" called \"count\", which counts\n    some number from the starting value.  For example:\n\n      count=5 -> [\"1\", \"2\", \"3\", \"4\", \"5\"]\n      start=0x0f00 count=4 format=%04x -> [\"0f00\", \"0f01\", \"0f02\", \"0f03\"]\n      start=0 count=5 stride=2 -> [\"0\", \"2\", \"4\", \"6\", \"8\"]\n      start=1 count=5 stride=2 -> [\"1\", \"3\", \"5\", \"7\", \"9\"]\n\n    The count option is mostly useful for avoiding off-by-one errors and errors\n    calculating the number of entries in a sequence when a stride is specified.\n    \"\"\"\n\n    def parse_kv_args(self, args):\n        \"\"\"parse key-value style arguments\"\"\"\n        for arg in FIELDS:\n            value = args.pop(arg, None)\n            if value is not None:\n                self.set_option(arg, value)\n        if args:\n            raise AnsibleError(\n                \"unrecognized arguments to with_sequence: %s\"\n                % list(args.keys())\n            )\n\n    def parse_simple_args(self, term):\n        \"\"\"parse the shortcut forms, return True/False\"\"\"\n        match = SHORTCUT.match(term)\n        if not match:\n            return False\n\n        dummy, start, end, dummy, stride, dummy, format = match.groups()\n\n        for key in FIELDS:\n            value = locals().get(key, None)\n            if value is not None:\n                self.set_option(key, value)\n\n        return True\n\n    def set_fields(self):\n        for f in FIELDS:\n            setattr(self, f, self.get_option(f))\n\n    def sanity_check(self):\n        if self.count is None and self.end is None:\n            raise AnsibleError(\"must specify count or end in with_sequence\")\n        elif self.count is not None and self.end is not None:\n            raise AnsibleError(\"can't specify both count and end in with_sequence\")\n        elif self.count is not None:\n            # convert count to end\n            if self.count != 0:\n                self.end = self.start + self.count * self.stride - 1\n            else:\n                self.start = 0\n                self.end = 0\n                self.stride = 0\n            del self.count\n        if self.stride > 0 and self.end < self.start:\n            raise AnsibleError(\"to count backwards make stride negative\")\n        if self.stride < 0 and self.end > self.start:\n            raise AnsibleError(\"to count forward don't make stride negative\")\n        if self.format.count('%') != 1:\n            raise AnsibleError(\"bad formatting string: %s\" % self.format)\n\n    def generate_sequence(self):\n        if self.stride >= 0:\n            adjust = 1\n        else:\n            adjust = -1\n        numbers = range(self.start, self.end + adjust, self.stride)\n\n        for i in numbers:\n            try:\n                formatted = self.format % i\n                yield formatted\n            except (ValueError, TypeError):\n                raise AnsibleError(\n                    \"problem formatting %r with %r\" % (i, self.format)\n                )\n\n    def run(self, terms, variables, **kwargs):\n        results = []\n\n        for term in terms:\n            try:\n                # set defaults/global\n                self.set_options(direct=kwargs)\n                try:\n                    if not self.parse_simple_args(term):\n                        self.parse_kv_args(parse_kv(term))\n                except AnsibleError:\n                    raise\n                except Exception as e:\n                    raise AnsibleError(\"unknown error parsing with_sequence arguments: %r. Error was: %s\" % (term, e))\n\n                self.set_fields()\n                self.sanity_check()\n\n                if self.stride != 0:\n                    results.extend(self.generate_sequence())\n            except AnsibleError:\n                raise\n            except Exception as e:\n                raise AnsibleError(\n                    \"unknown error generating sequence: %s\" % e\n                )\n\n        return results\n", "file_name": "763767.py", "cwe": ["CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')"]}
{"source": "\"\"\"Sanity test using validate-modules.\"\"\"\nfrom __future__ import annotations\n\nimport collections\nimport contextlib\nimport json\nimport os\nimport tarfile\nimport typing as t\n\nfrom . import (\n    DOCUMENTABLE_PLUGINS,\n    MULTI_FILE_PLUGINS,\n    SanitySingleVersion,\n    SanityMessage,\n    SanityFailure,\n    SanitySuccess,\n    SanityTargets,\n    SANITY_ROOT,\n)\n\nfrom ...io import (\n    make_dirs,\n)\n\nfrom ...test import (\n    TestResult,\n)\n\nfrom ...target import (\n    TestTarget,\n)\n\nfrom ...util import (\n    SubprocessError,\n    display,\n)\n\nfrom ...util_common import (\n    ExitHandler,\n    process_scoped_temporary_directory,\n    run_command,\n    ResultType,\n)\n\nfrom ...ansible_util import (\n    ansible_environment,\n    get_collection_detail,\n    CollectionDetailError,\n)\n\nfrom ...config import (\n    SanityConfig,\n)\n\nfrom ...ci import (\n    get_ci_provider,\n)\n\nfrom ...data import (\n    data_context,\n    PayloadConfig,\n)\n\nfrom ...host_configs import (\n    PythonConfig,\n)\n\nfrom ...git import (\n    Git,\n)\n\nfrom ...provider.source import (\n    SourceProvider as GitSourceProvider,\n)\n\n\nclass ValidateModulesTest(SanitySingleVersion):\n    \"\"\"Sanity test using validate-modules.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.optional_error_codes.update([\n            'deprecated-date',\n        ])\n\n        self._prefixes = {\n            plugin_type: plugin_path + '/'\n            for plugin_type, plugin_path in data_context().content.plugin_paths.items()\n            if plugin_type in DOCUMENTABLE_PLUGINS\n        }\n\n        self._exclusions = set()\n\n        if not data_context().content.collection:\n            self._exclusions.add('lib/ansible/plugins/cache/base.py')\n\n    @property\n    def error_code(self) -> t.Optional[str]:\n        \"\"\"Error code for ansible-test matching the format used by the underlying test program, or None if the program does not use error codes.\"\"\"\n        return 'A100'\n\n    def get_plugin_type(self, target: TestTarget) -> t.Optional[str]:\n        \"\"\"Return the plugin type of the given target, or None if it is not a plugin or module.\"\"\"\n        if target.path.endswith('/__init__.py'):\n            return None\n\n        if target.path in self._exclusions:\n            return None\n\n        for plugin_type, prefix in self._prefixes.items():\n            if target.path.startswith(prefix):\n                return plugin_type\n\n        return None\n\n    def filter_targets(self, targets: list[TestTarget]) -> list[TestTarget]:\n        \"\"\"Return the given list of test targets, filtered to include only those relevant for the test.\"\"\"\n        return [target for target in targets if self.get_plugin_type(target) is not None]\n\n    def test(self, args: SanityConfig, targets: SanityTargets, python: PythonConfig) -> TestResult:\n        env = ansible_environment(args, color=False)\n\n        settings = self.load_processor(args)\n\n        target_per_type = collections.defaultdict(list)\n\n        for target in targets.include:\n            target_per_type[self.get_plugin_type(target)].append(target)\n\n        # Remove plugins that cannot be associated to a single file (test and filter plugins).\n        for plugin_type in MULTI_FILE_PLUGINS:\n            target_per_type.pop(plugin_type, None)\n\n        cmd = [\n            python.path,\n            os.path.join(SANITY_ROOT, 'validate-modules', 'validate.py'),\n            '--format', 'json',\n            '--arg-spec',\n        ]  # fmt: skip\n\n        if data_context().content.collection:\n            cmd.extend(['--collection', data_context().content.collection.directory])\n\n            try:\n                collection_detail = get_collection_detail(python)\n\n                if collection_detail.version:\n                    cmd.extend(['--collection-version', collection_detail.version])\n                else:\n                    display.warning('Skipping validate-modules collection version checks since no collection version was found.')\n            except CollectionDetailError as ex:\n                display.warning('Skipping validate-modules collection version checks since collection detail loading failed: %s' % ex.reason)\n        else:\n            path = self.get_archive_path(args)\n\n            if os.path.exists(path):\n                temp_dir = process_scoped_temporary_directory(args)\n\n                with tarfile.open(path) as file:\n                    # deprecated: description='extractall fallback without filter' python_version='3.11'\n                    if hasattr(tarfile, 'data_filter'):\n                        file.extractall(temp_dir, filter='data')  # type: ignore[call-arg]\n                    else:\n                        file.extractall(temp_dir)\n\n                cmd.extend([\n                    '--original-plugins', temp_dir,\n                ])\n\n        errors = []\n\n        for plugin_type, plugin_targets in sorted(target_per_type.items()):\n            paths = [target.path for target in plugin_targets]\n            plugin_cmd = list(cmd)\n\n            if plugin_type != 'modules':\n                plugin_cmd += ['--plugin-type', plugin_type]\n\n            plugin_cmd += paths\n\n            try:\n                stdout, stderr = run_command(args, plugin_cmd, env=env, capture=True)\n                status = 0\n            except SubprocessError as ex:\n                stdout = ex.stdout\n                stderr = ex.stderr\n                status = ex.status\n\n            if stderr or status not in (0, 3):\n                raise SubprocessError(cmd=plugin_cmd, status=status, stderr=stderr, stdout=stdout)\n\n            if args.explain:\n                continue\n\n            messages = json.loads(stdout)\n\n            for filename in messages:\n                output = messages[filename]\n\n                for item in output['errors']:\n                    errors.append(SanityMessage(\n                        path=filename,\n                        line=int(item['line']) if 'line' in item else 0,\n                        column=int(item['column']) if 'column' in item else 0,\n                        code='%s' % item['code'],\n                        message=item['msg'],\n                    ))\n\n        all_paths = [target.path for target in targets.include]\n        all_errors = settings.process_errors(errors, all_paths)\n\n        if args.explain:\n            return SanitySuccess(self.name)\n\n        if all_errors:\n            return SanityFailure(self.name, messages=all_errors)\n\n        return SanitySuccess(self.name)\n\n    def origin_hook(self, args: SanityConfig) -> None:\n        \"\"\"This method is called on the origin, before the test runs or delegation occurs.\"\"\"\n        if not data_context().content.is_ansible:\n            return\n\n        if not isinstance(data_context().source_provider, GitSourceProvider):\n            display.warning('The validate-modules sanity test cannot compare against the base commit because git is not being used.')\n            return\n\n        base_commit = args.base_branch or get_ci_provider().get_base_commit(args)\n\n        if not base_commit:\n            display.warning('The validate-modules sanity test cannot compare against the base commit because it was not detected.')\n            return\n\n        path = self.get_archive_path(args)\n\n        def cleanup() -> None:\n            \"\"\"Cleanup callback called when the process exits.\"\"\"\n            with contextlib.suppress(FileNotFoundError):\n                os.unlink(path)\n\n        def git_callback(payload_config: PayloadConfig) -> None:\n            \"\"\"Include the previous plugin content archive in the payload.\"\"\"\n            files = payload_config.files\n            files.append((path, os.path.relpath(path, data_context().content.root)))\n\n        ExitHandler.register(cleanup)\n        data_context().register_payload_callback(git_callback)\n\n        make_dirs(os.path.dirname(path))\n\n        git = Git()\n        git.run_git(['archive', '--output', path, base_commit, 'lib/ansible/modules/', 'lib/ansible/plugins/'])\n\n    @staticmethod\n    def get_archive_path(args: SanityConfig) -> str:\n        \"\"\"Return the path to the original plugin content archive.\"\"\"\n        return os.path.join(ResultType.TMP.path, f'validate-modules-{args.metadata.session_id}.tar')\n", "file_name": "589414.py", "cwe": ["CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"]}
{"source": "import os\nimport subprocess\nimport sys\nimport sysconfig\nimport tempfile\nfrom contextlib import nullcontext\nfrom importlib import resources\nfrom pathlib import Path\nfrom shutil import copy2\n\n\n__all__ = [\"version\", \"bootstrap\"]\n_PIP_VERSION = \"24.2\"\n\n# Directory of system wheel packages. Some Linux distribution packaging\n# policies recommend against bundling dependencies. For example, Fedora\n# installs wheel packages in the /usr/share/python-wheels/ directory and don't\n# install the ensurepip._bundled package.\nif (_pkg_dir := sysconfig.get_config_var('WHEEL_PKG_DIR')) is not None:\n    _WHEEL_PKG_DIR = Path(_pkg_dir).resolve()\nelse:\n    _WHEEL_PKG_DIR = None\n\n\ndef _find_wheel_pkg_dir_pip():\n    if _WHEEL_PKG_DIR is None:\n        # NOTE: The compile-time `WHEEL_PKG_DIR` is unset so there is no place\n        # NOTE: for looking up the wheels.\n        return None\n\n    dist_matching_wheels = _WHEEL_PKG_DIR.glob('pip-*.whl')\n    try:\n        last_matching_dist_wheel = sorted(dist_matching_wheels)[-1]\n    except IndexError:\n        # NOTE: `WHEEL_PKG_DIR` does not contain any wheel files for `pip`.\n        return None\n\n    return nullcontext(last_matching_dist_wheel)\n\n\ndef _get_pip_whl_path_ctx():\n    # Prefer pip from the wheel package directory, if present.\n    if (alternative_pip_wheel_path := _find_wheel_pkg_dir_pip()) is not None:\n        return alternative_pip_wheel_path\n\n    return resources.as_file(\n        resources.files('ensurepip')\n        / '_bundled'\n        / f'pip-{_PIP_VERSION}-py3-none-any.whl'\n    )\n\n\ndef _get_pip_version():\n    with _get_pip_whl_path_ctx() as bundled_wheel_path:\n        wheel_name = bundled_wheel_path.name\n        return (\n            # Extract '21.2.4' from 'pip-21.2.4-py3-none-any.whl'\n            wheel_name.\n            removeprefix('pip-').\n            partition('-')[0]\n        )\n\n\ndef _run_pip(args, additional_paths=None):\n    # Run the bootstrapping in a subprocess to avoid leaking any state that happens\n    # after pip has executed. Particularly, this avoids the case when pip holds onto\n    # the files in *additional_paths*, preventing us to remove them at the end of the\n    # invocation.\n    code = f\"\"\"\nimport runpy\nimport sys\nsys.path = {additional_paths or []} + sys.path\nsys.argv[1:] = {args}\nrunpy.run_module(\"pip\", run_name=\"__main__\", alter_sys=True)\n\"\"\"\n\n    cmd = [\n        sys.executable,\n        '-W',\n        'ignore::DeprecationWarning',\n        '-c',\n        code,\n    ]\n    if sys.flags.isolated:\n        # run code in isolated mode if currently running isolated\n        cmd.insert(1, '-I')\n    return subprocess.run(cmd, check=True).returncode\n\n\ndef version():\n    \"\"\"\n    Returns a string specifying the bundled version of pip.\n    \"\"\"\n    return _get_pip_version()\n\n\ndef _disable_pip_configuration_settings():\n    # We deliberately ignore all pip environment variables\n    # when invoking pip\n    # See http://bugs.python.org/issue19734 for details\n    keys_to_remove = [k for k in os.environ if k.startswith(\"PIP_\")]\n    for k in keys_to_remove:\n        del os.environ[k]\n    # We also ignore the settings in the default pip configuration file\n    # See http://bugs.python.org/issue20053 for details\n    os.environ['PIP_CONFIG_FILE'] = os.devnull\n\n\ndef bootstrap(*, root=None, upgrade=False, user=False,\n              altinstall=False, default_pip=False,\n              verbosity=0):\n    \"\"\"\n    Bootstrap pip into the current Python installation (or the given root\n    directory).\n\n    Note that calling this function will alter both sys.path and os.environ.\n    \"\"\"\n    # Discard the return value\n    _bootstrap(root=root, upgrade=upgrade, user=user,\n               altinstall=altinstall, default_pip=default_pip,\n               verbosity=verbosity)\n\n\ndef _bootstrap(*, root=None, upgrade=False, user=False,\n              altinstall=False, default_pip=False,\n              verbosity=0):\n    \"\"\"\n    Bootstrap pip into the current Python installation (or the given root\n    directory). Returns pip command status code.\n\n    Note that calling this function will alter both sys.path and os.environ.\n    \"\"\"\n    if altinstall and default_pip:\n        raise ValueError(\"Cannot use altinstall and default_pip together\")\n\n    sys.audit(\"ensurepip.bootstrap\", root)\n\n    _disable_pip_configuration_settings()\n\n    # By default, installing pip installs all of the\n    # following scripts (X.Y == running Python version):\n    #\n    #   pip, pipX, pipX.Y\n    #\n    # pip 1.5+ allows ensurepip to request that some of those be left out\n    if altinstall:\n        # omit pip, pipX\n        os.environ[\"ENSUREPIP_OPTIONS\"] = \"altinstall\"\n    elif not default_pip:\n        # omit pip\n        os.environ[\"ENSUREPIP_OPTIONS\"] = \"install\"\n\n    with tempfile.TemporaryDirectory() as tmpdir:\n        # Put our bundled wheels into a temporary directory and construct the\n        # additional paths that need added to sys.path\n        tmpdir_path = Path(tmpdir)\n        with _get_pip_whl_path_ctx() as bundled_wheel_path:\n            tmp_wheel_path = tmpdir_path / bundled_wheel_path.name\n            copy2(bundled_wheel_path, tmp_wheel_path)\n\n        # Construct the arguments to be passed to the pip command\n        args = [\"install\", \"--no-cache-dir\", \"--no-index\", \"--find-links\", tmpdir]\n        if root:\n            args += [\"--root\", root]\n        if upgrade:\n            args += [\"--upgrade\"]\n        if user:\n            args += [\"--user\"]\n        if verbosity:\n            args += [\"-\" + \"v\" * verbosity]\n\n        return _run_pip([*args, \"pip\"], [os.fsdecode(tmp_wheel_path)])\n\n\ndef _uninstall_helper(*, verbosity=0):\n    \"\"\"Helper to support a clean default uninstall process on Windows\n\n    Note that calling this function may alter os.environ.\n    \"\"\"\n    # Nothing to do if pip was never installed, or has been removed\n    try:\n        import pip\n    except ImportError:\n        return\n\n    # If the installed pip version doesn't match the available one,\n    # leave it alone\n    available_version = version()\n    if pip.__version__ != available_version:\n        print(f\"ensurepip will only uninstall a matching version \"\n              f\"({pip.__version__!r} installed, \"\n              f\"{available_version!r} available)\",\n              file=sys.stderr)\n        return\n\n    _disable_pip_configuration_settings()\n\n    # Construct the arguments to be passed to the pip command\n    args = [\"uninstall\", \"-y\", \"--disable-pip-version-check\"]\n    if verbosity:\n        args += [\"-\" + \"v\" * verbosity]\n\n    return _run_pip([*args, \"pip\"])\n\n\ndef _main(argv=None):\n    import argparse\n    parser = argparse.ArgumentParser(prog=\"python -m ensurepip\")\n    parser.add_argument(\n        \"--version\",\n        action=\"version\",\n        version=\"pip {}\".format(version()),\n        help=\"Show the version of pip that is bundled with this Python.\",\n    )\n    parser.add_argument(\n        \"-v\", \"--verbose\",\n        action=\"count\",\n        default=0,\n        dest=\"verbosity\",\n        help=(\"Give more output. Option is additive, and can be used up to 3 \"\n              \"times.\"),\n    )\n    parser.add_argument(\n        \"-U\", \"--upgrade\",\n        action=\"store_true\",\n        default=False,\n        help=\"Upgrade pip and dependencies, even if already installed.\",\n    )\n    parser.add_argument(\n        \"--user\",\n        action=\"store_true\",\n        default=False,\n        help=\"Install using the user scheme.\",\n    )\n    parser.add_argument(\n        \"--root\",\n        default=None,\n        help=\"Install everything relative to this alternate root directory.\",\n    )\n    parser.add_argument(\n        \"--altinstall\",\n        action=\"store_true\",\n        default=False,\n        help=(\"Make an alternate install, installing only the X.Y versioned \"\n              \"scripts (Default: pipX, pipX.Y).\"),\n    )\n    parser.add_argument(\n        \"--default-pip\",\n        action=\"store_true\",\n        default=False,\n        help=(\"Make a default pip install, installing the unqualified pip \"\n              \"in addition to the versioned scripts.\"),\n    )\n\n    args = parser.parse_args(argv)\n\n    return _bootstrap(\n        root=args.root,\n        upgrade=args.upgrade,\n        user=args.user,\n        verbosity=args.verbosity,\n        altinstall=args.altinstall,\n        default_pip=args.default_pip,\n    )\n", "file_name": "886160.py", "cwe": ["Unknown"]}
{"source": "\"\"\"Pop up a reminder of how to call a function.\n\nCall Tips are floating windows which display function, class, and method\nparameter and docstring information when you type an opening parenthesis, and\nwhich disappear when you type a closing parenthesis.\n\"\"\"\nimport __main__\nimport inspect\nimport re\nimport sys\nimport textwrap\nimport types\n\nfrom idlelib import calltip_w\nfrom idlelib.hyperparser import HyperParser\n\n\nclass Calltip:\n\n    def __init__(self, editwin=None):\n        if editwin is None:  # subprocess and test\n            self.editwin = None\n        else:\n            self.editwin = editwin\n            self.text = editwin.text\n            self.active_calltip = None\n            self._calltip_window = self._make_tk_calltip_window\n\n    def close(self):\n        self._calltip_window = None\n\n    def _make_tk_calltip_window(self):\n        # See __init__ for usage\n        return calltip_w.CalltipWindow(self.text)\n\n    def remove_calltip_window(self, event=None):\n        if self.active_calltip:\n            self.active_calltip.hidetip()\n            self.active_calltip = None\n\n    def force_open_calltip_event(self, event):\n        \"The user selected the menu entry or hotkey, open the tip.\"\n        self.open_calltip(True)\n        return \"break\"\n\n    def try_open_calltip_event(self, event):\n        \"\"\"Happens when it would be nice to open a calltip, but not really\n        necessary, for example after an opening bracket, so function calls\n        won't be made.\n        \"\"\"\n        self.open_calltip(False)\n\n    def refresh_calltip_event(self, event):\n        if self.active_calltip and self.active_calltip.tipwindow:\n            self.open_calltip(False)\n\n    def open_calltip(self, evalfuncs):\n        \"\"\"Maybe close an existing calltip and maybe open a new calltip.\n\n        Called from (force_open|try_open|refresh)_calltip_event functions.\n        \"\"\"\n        hp = HyperParser(self.editwin, \"insert\")\n        sur_paren = hp.get_surrounding_brackets('(')\n\n        # If not inside parentheses, no calltip.\n        if not sur_paren:\n            self.remove_calltip_window()\n            return\n\n        # If a calltip is shown for the current parentheses, do\n        # nothing.\n        if self.active_calltip:\n            opener_line, opener_col = map(int, sur_paren[0].split('.'))\n            if (\n                (opener_line, opener_col) ==\n                (self.active_calltip.parenline, self.active_calltip.parencol)\n            ):\n                return\n\n        hp.set_index(sur_paren[0])\n        try:\n            expression = hp.get_expression()\n        except ValueError:\n            expression = None\n        if not expression:\n            # No expression before the opening parenthesis, e.g.\n            # because it's in a string or the opener for a tuple:\n            # Do nothing.\n            return\n\n        # At this point, the current index is after an opening\n        # parenthesis, in a section of code, preceded by a valid\n        # expression. If there is a calltip shown, it's not for the\n        # same index and should be closed.\n        self.remove_calltip_window()\n\n        # Simple, fast heuristic: If the preceding expression includes\n        # an opening parenthesis, it likely includes a function call.\n        if not evalfuncs and (expression.find('(') != -1):\n            return\n\n        argspec = self.fetch_tip(expression)\n        if not argspec:\n            return\n        self.active_calltip = self._calltip_window()\n        self.active_calltip.showtip(argspec, sur_paren[0], sur_paren[1])\n\n    def fetch_tip(self, expression):\n        \"\"\"Return the argument list and docstring of a function or class.\n\n        If there is a Python subprocess, get the calltip there.  Otherwise,\n        either this fetch_tip() is running in the subprocess or it was\n        called in an IDLE running without the subprocess.\n\n        The subprocess environment is that of the most recently run script.  If\n        two unrelated modules are being edited some calltips in the current\n        module may be inoperative if the module was not the last to run.\n\n        To find methods, fetch_tip must be fed a fully qualified name.\n\n        \"\"\"\n        try:\n            rpcclt = self.editwin.flist.pyshell.interp.rpcclt\n        except AttributeError:\n            rpcclt = None\n        if rpcclt:\n            return rpcclt.remotecall(\"exec\", \"get_the_calltip\",\n                                     (expression,), {})\n        else:\n            return get_argspec(get_entity(expression))\n\n\ndef get_entity(expression):\n    \"\"\"Return the object corresponding to expression evaluated\n    in a namespace spanning sys.modules and __main.dict__.\n    \"\"\"\n    if expression:\n        namespace = {**sys.modules, **__main__.__dict__}\n        try:\n            return eval(expression, namespace)  # Only protect user code.\n        except BaseException:\n            # An uncaught exception closes idle, and eval can raise any\n            # exception, especially if user classes are involved.\n            return None\n\n# The following are used in get_argspec and some in tests\n_MAX_COLS = 85\n_MAX_LINES = 5  # enough for bytes\n_INDENT = ' '*4  # for wrapped signatures\n_first_param = re.compile(r'(?<=\\()\\w*\\,?\\s*')\n_default_callable_argspec = \"See source or doc\"\n_invalid_method = \"invalid method signature\"\n\ndef get_argspec(ob):\n    '''Return a string describing the signature of a callable object, or ''.\n\n    For Python-coded functions and methods, the first line is introspected.\n    Delete 'self' parameter for classes (.__init__) and bound methods.\n    The next lines are the first lines of the doc string up to the first\n    empty line or _MAX_LINES.    For builtins, this typically includes\n    the arguments in addition to the return value.\n    '''\n    # Determine function object fob to inspect.\n    try:\n        ob_call = ob.__call__\n    except BaseException:  # Buggy user object could raise anything.\n        return ''  # No popup for non-callables.\n    # For Get_argspecTest.test_buggy_getattr_class, CallA() & CallB().\n    fob = ob_call if isinstance(ob_call, types.MethodType) else ob\n\n    # Initialize argspec and wrap it to get lines.\n    try:\n        argspec = str(inspect.signature(fob))\n    except Exception as err:\n        msg = str(err)\n        if msg.startswith(_invalid_method):\n            return _invalid_method\n        else:\n            argspec = ''\n\n    if isinstance(fob, type) and argspec == '()':\n        # If fob has no argument, use default callable argspec.\n        argspec = _default_callable_argspec\n\n    lines = (textwrap.wrap(argspec, _MAX_COLS, subsequent_indent=_INDENT)\n             if len(argspec) > _MAX_COLS else [argspec] if argspec else [])\n\n    # Augment lines from docstring, if any, and join to get argspec.\n    doc = inspect.getdoc(ob)\n    if doc:\n        for line in doc.split('\\n', _MAX_LINES)[:_MAX_LINES]:\n            line = line.strip()\n            if not line:\n                break\n            if len(line) > _MAX_COLS:\n                line = line[: _MAX_COLS - 3] + '...'\n            lines.append(line)\n    argspec = '\\n'.join(lines)\n\n    return argspec or _default_callable_argspec\n\n\nif __name__ == '__main__':\n    from unittest import main\n    main('idlelib.idle_test.test_calltip', verbosity=2)\n", "file_name": "525549.py", "cwe": ["CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"]}
{"source": "import os\nimport pathlib\nimport tempfile\nimport functools\nimport contextlib\nimport types\nimport importlib\nimport inspect\nimport warnings\nimport itertools\n\nfrom typing import Union, Optional, cast\nfrom .abc import ResourceReader, Traversable\n\nPackage = Union[types.ModuleType, str]\nAnchor = Package\n\n\ndef package_to_anchor(func):\n    \"\"\"\n    Replace 'package' parameter as 'anchor' and warn about the change.\n\n    Other errors should fall through.\n\n    >>> files('a', 'b')\n    Traceback (most recent call last):\n    TypeError: files() takes from 0 to 1 positional arguments but 2 were given\n\n    Remove this compatibility in Python 3.14.\n    \"\"\"\n    undefined = object()\n\n    @functools.wraps(func)\n    def wrapper(anchor=undefined, package=undefined):\n        if package is not undefined:\n            if anchor is not undefined:\n                return func(anchor, package)\n            warnings.warn(\n                \"First parameter to files is renamed to 'anchor'\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            return func(package)\n        elif anchor is undefined:\n            return func()\n        return func(anchor)\n\n    return wrapper\n\n\n@package_to_anchor\ndef files(anchor: Optional[Anchor] = None) -> Traversable:\n    \"\"\"\n    Get a Traversable resource for an anchor.\n    \"\"\"\n    return from_package(resolve(anchor))\n\n\ndef get_resource_reader(package: types.ModuleType) -> Optional[ResourceReader]:\n    \"\"\"\n    Return the package's loader if it's a ResourceReader.\n    \"\"\"\n    # We can't use\n    # a issubclass() check here because apparently abc.'s __subclasscheck__()\n    # hook wants to create a weak reference to the object, but\n    # zipimport.zipimporter does not support weak references, resulting in a\n    # TypeError.  That seems terrible.\n    spec = package.__spec__\n    reader = getattr(spec.loader, 'get_resource_reader', None)  # type: ignore\n    if reader is None:\n        return None\n    return reader(spec.name)  # type: ignore\n\n\n@functools.singledispatch\ndef resolve(cand: Optional[Anchor]) -> types.ModuleType:\n    return cast(types.ModuleType, cand)\n\n\n@resolve.register\ndef _(cand: str) -> types.ModuleType:\n    return importlib.import_module(cand)\n\n\n@resolve.register\ndef _(cand: None) -> types.ModuleType:\n    return resolve(_infer_caller().f_globals['__name__'])\n\n\ndef _infer_caller():\n    \"\"\"\n    Walk the stack and find the frame of the first caller not in this module.\n    \"\"\"\n\n    def is_this_file(frame_info):\n        return frame_info.filename == __file__\n\n    def is_wrapper(frame_info):\n        return frame_info.function == 'wrapper'\n\n    not_this_file = itertools.filterfalse(is_this_file, inspect.stack())\n    # also exclude 'wrapper' due to singledispatch in the call stack\n    callers = itertools.filterfalse(is_wrapper, not_this_file)\n    return next(callers).frame\n\n\ndef from_package(package: types.ModuleType):\n    \"\"\"\n    Return a Traversable object for the given package.\n\n    \"\"\"\n    # deferred for performance (python/cpython#109829)\n    from ._adapters import wrap_spec\n\n    spec = wrap_spec(package)\n    reader = spec.loader.get_resource_reader(spec.name)\n    return reader.files()\n\n\n@contextlib.contextmanager\ndef _tempfile(\n    reader,\n    suffix='',\n    # gh-93353: Keep a reference to call os.remove() in late Python\n    # finalization.\n    *,\n    _os_remove=os.remove,\n):\n    # Not using tempfile.NamedTemporaryFile as it leads to deeper 'try'\n    # blocks due to the need to close the temporary file to work on Windows\n    # properly.\n    fd, raw_path = tempfile.mkstemp(suffix=suffix)\n    try:\n        try:\n            os.write(fd, reader())\n        finally:\n            os.close(fd)\n        del reader\n        yield pathlib.Path(raw_path)\n    finally:\n        try:\n            _os_remove(raw_path)\n        except FileNotFoundError:\n            pass\n\n\ndef _temp_file(path):\n    return _tempfile(path.read_bytes, suffix=path.name)\n\n\ndef _is_present_dir(path: Traversable) -> bool:\n    \"\"\"\n    Some Traversables implement ``is_dir()`` to raise an\n    exception (i.e. ``FileNotFoundError``) when the\n    directory doesn't exist. This function wraps that call\n    to always return a boolean and only return True\n    if there's a dir and it exists.\n    \"\"\"\n    with contextlib.suppress(FileNotFoundError):\n        return path.is_dir()\n    return False\n\n\n@functools.singledispatch\ndef as_file(path):\n    \"\"\"\n    Given a Traversable object, return that object as a\n    path on the local file system in a context manager.\n    \"\"\"\n    return _temp_dir(path) if _is_present_dir(path) else _temp_file(path)\n\n\n@as_file.register(pathlib.Path)\n@contextlib.contextmanager\ndef _(path):\n    \"\"\"\n    Degenerate behavior for pathlib.Path objects.\n    \"\"\"\n    yield path\n\n\n@contextlib.contextmanager\ndef _temp_path(dir: tempfile.TemporaryDirectory):\n    \"\"\"\n    Wrap tempfile.TemporyDirectory to return a pathlib object.\n    \"\"\"\n    with dir as result:\n        yield pathlib.Path(result)\n\n\n@contextlib.contextmanager\ndef _temp_dir(path):\n    \"\"\"\n    Given a traversable dir, recursively replicate the whole tree\n    to the file system in a context manager.\n    \"\"\"\n    assert path.is_dir()\n    with _temp_path(tempfile.TemporaryDirectory()) as temp_dir:\n        yield _write_contents(temp_dir, path)\n\n\ndef _write_contents(target, source):\n    child = target.joinpath(source.name)\n    if source.is_dir():\n        child.mkdir()\n        for item in source.iterdir():\n            _write_contents(child, item)\n    else:\n        child.write_bytes(source.read_bytes())\n    return child\n", "file_name": "348050.py", "cwe": ["CWE-706: Use of Incorrectly-Resolved Name or Reference"]}
{"source": "\"\"\"\nTitle: Multi-GPU distributed training with PyTorch\nAuthor: [fchollet](https://twitter.com/fchollet)\nDate created: 2023/06/29\nLast modified: 2023/06/29\nDescription: Guide to multi-GPU training for Keras models with PyTorch.\nAccelerator: GPU\n\"\"\"\n\n\"\"\"\n## Introduction\n\nThere are generally two ways to distribute computation across multiple devices:\n\n**Data parallelism**, where a single model gets replicated on multiple devices or\nmultiple machines. Each of them processes different batches of data, then they merge\ntheir results. There exist many variants of this setup, that differ in how the different\nmodel replicas merge results, in whether they stay in sync at every batch or whether they\nare more loosely coupled, etc.\n\n**Model parallelism**, where different parts of a single model run on different devices,\nprocessing a single batch of data together. This works best with models that have a\nnaturally-parallel architecture, such as models that feature multiple branches.\n\nThis guide focuses on data parallelism, in particular **synchronous data parallelism**,\nwhere the different replicas of the model stay in sync after each batch they process.\nSynchronicity keeps the model convergence behavior identical to what you would see for\nsingle-device training.\n\nSpecifically, this guide teaches you how to use PyTorch's `DistributedDataParallel`\nmodule wrapper to train Keras, with minimal changes to your code,\non multiple GPUs (typically 2 to 16) installed on a single machine (single host,\nmulti-device training). This is the most common setup for researchers and small-scale\nindustry workflows.\n\"\"\"\n\n\"\"\"\n## Setup\n\nLet's start by defining the function that creates the model that we will train,\nand the function that creates the dataset we will train on (MNIST in this case).\n\"\"\"\n\nimport os\n\nos.environ[\"KERAS_BACKEND\"] = \"torch\"\n\nimport torch\nimport numpy as np\nimport keras\n\n\ndef get_model():\n    # Make a simple convnet with batch normalization and dropout.\n    inputs = keras.Input(shape=(28, 28, 1))\n    x = keras.layers.Rescaling(1.0 / 255.0)(inputs)\n    x = keras.layers.Conv2D(\n        filters=12, kernel_size=3, padding=\"same\", use_bias=False\n    )(x)\n    x = keras.layers.BatchNormalization(scale=False, center=True)(x)\n    x = keras.layers.ReLU()(x)\n    x = keras.layers.Conv2D(\n        filters=24,\n        kernel_size=6,\n        use_bias=False,\n        strides=2,\n    )(x)\n    x = keras.layers.BatchNormalization(scale=False, center=True)(x)\n    x = keras.layers.ReLU()(x)\n    x = keras.layers.Conv2D(\n        filters=32,\n        kernel_size=6,\n        padding=\"same\",\n        strides=2,\n        name=\"large_k\",\n    )(x)\n    x = keras.layers.BatchNormalization(scale=False, center=True)(x)\n    x = keras.layers.ReLU()(x)\n    x = keras.layers.GlobalAveragePooling2D()(x)\n    x = keras.layers.Dense(256, activation=\"relu\")(x)\n    x = keras.layers.Dropout(0.5)(x)\n    outputs = keras.layers.Dense(10)(x)\n    model = keras.Model(inputs, outputs)\n    return model\n\n\ndef get_dataset():\n    # Load the data and split it between train and test sets\n    (x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()\n\n    # Scale images to the [0, 1] range\n    x_train = x_train.astype(\"float32\")\n    x_test = x_test.astype(\"float32\")\n    # Make sure images have shape (28, 28, 1)\n    x_train = np.expand_dims(x_train, -1)\n    x_test = np.expand_dims(x_test, -1)\n    print(\"x_train shape:\", x_train.shape)\n\n    # Create a TensorDataset\n    dataset = torch.utils.data.TensorDataset(\n        torch.from_numpy(x_train), torch.from_numpy(y_train)\n    )\n    return dataset\n\n\n\"\"\"\nNext, let's define a simple PyTorch training loop that targets\na GPU (note the calls to `.cuda()`).\n\"\"\"\n\n\ndef train_model(model, dataloader, num_epochs, optimizer, loss_fn):\n    for epoch in range(num_epochs):\n        running_loss = 0.0\n        running_loss_count = 0\n        for batch_idx, (inputs, targets) in enumerate(dataloader):\n            inputs = inputs.cuda(non_blocking=True)\n            targets = targets.cuda(non_blocking=True)\n\n            # Forward pass\n            outputs = model(inputs)\n            loss = loss_fn(outputs, targets)\n\n            # Backward and optimize\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n\n            running_loss += loss.item()\n            running_loss_count += 1\n\n        # Print loss statistics\n        print(\n            f\"Epoch {epoch + 1}/{num_epochs}, \"\n            f\"Loss: {running_loss / running_loss_count}\"\n        )\n\n\n\"\"\"\n## Single-host, multi-device synchronous training\n\nIn this setup, you have one machine with several GPUs on it (typically 2 to 16). Each\ndevice will run a copy of your model (called a **replica**). For simplicity, in what\nfollows, we'll assume we're dealing with 8 GPUs, at no loss of generality.\n\n**How it works**\n\nAt each step of training:\n\n- The current batch of data (called **global batch**) is split into 8 different\nsub-batches (called **local batches**). For instance, if the global batch has 512\nsamples, each of the 8 local batches will have 64 samples.\n- Each of the 8 replicas independently processes a local batch: they run a forward pass,\nthen a backward pass, outputting the gradient of the weights with respect to the loss of\nthe model on the local batch.\n- The weight updates originating from local gradients are efficiently merged across the 8\nreplicas. Because this is done at the end of every step, the replicas always stay in\nsync.\n\nIn practice, the process of synchronously updating the weights of the model replicas is\nhandled at the level of each individual weight variable. This is done through a **mirrored\nvariable** object.\n\n**How to use it**\n\nTo do single-host, multi-device synchronous training with a Keras model, you would use\nthe `torch.nn.parallel.DistributedDataParallel` module wrapper.\nHere's how it works:\n\n- We use `torch.multiprocessing.start_processes` to start multiple Python processes, one\nper device. Each process will run the `per_device_launch_fn` function.\n- The `per_device_launch_fn` function does the following:\n    - It uses `torch.distributed.init_process_group` and `torch.cuda.set_device`\n    to configure the device to be used for that process.\n    - It uses `torch.utils.data.distributed.DistributedSampler`\n    and `torch.utils.data.DataLoader` to turn our data into a distributed data loader.\n    - It also uses `torch.nn.parallel.DistributedDataParallel` to turn our model into\n    a distributed PyTorch module.\n    - It then calls the `train_model` function.\n- The `train_model` function will then run in each process, with the model using\na separate device in each process.\n\nHere's the flow, where each step is split into its own utility function:\n\"\"\"\n\n# Config\nnum_gpu = torch.cuda.device_count()\nnum_epochs = 2\nbatch_size = 64\nprint(f\"Running on {num_gpu} GPUs\")\n\n\ndef setup_device(current_gpu_index, num_gpus):\n    # Device setup\n    os.environ[\"MASTER_ADDR\"] = \"localhost\"\n    os.environ[\"MASTER_PORT\"] = \"56492\"\n    device = torch.device(\"cuda:{}\".format(current_gpu_index))\n    torch.distributed.init_process_group(\n        backend=\"nccl\",\n        init_method=\"env://\",\n        world_size=num_gpus,\n        rank=current_gpu_index,\n    )\n    torch.cuda.set_device(device)\n\n\ndef cleanup():\n    torch.distributed.destroy_process_group()\n\n\ndef prepare_dataloader(dataset, current_gpu_index, num_gpus, batch_size):\n    sampler = torch.utils.data.distributed.DistributedSampler(\n        dataset,\n        num_replicas=num_gpus,\n        rank=current_gpu_index,\n        shuffle=False,\n    )\n    dataloader = torch.utils.data.DataLoader(\n        dataset,\n        sampler=sampler,\n        batch_size=batch_size,\n        shuffle=False,\n    )\n    return dataloader\n\n\ndef per_device_launch_fn(current_gpu_index, num_gpu):\n    # Setup the process groups\n    setup_device(current_gpu_index, num_gpu)\n\n    dataset = get_dataset()\n    model = get_model()\n\n    # prepare the dataloader\n    dataloader = prepare_dataloader(\n        dataset, current_gpu_index, num_gpu, batch_size\n    )\n\n    # Instantiate the torch optimizer\n    optimizer = torch.optim.Adam(model.parameters(), lr=1e-3)\n\n    # Instantiate the torch loss function\n    loss_fn = torch.nn.CrossEntropyLoss()\n\n    # Put model on device\n    model = model.to(current_gpu_index)\n    ddp_model = torch.nn.parallel.DistributedDataParallel(\n        model, device_ids=[current_gpu_index], output_device=current_gpu_index\n    )\n\n    train_model(ddp_model, dataloader, num_epochs, optimizer, loss_fn)\n\n    cleanup()\n\n\n\"\"\"\nTime to start multiple processes:\n\"\"\"\n\nif __name__ == \"__main__\":\n    # We use the \"fork\" method rather than \"spawn\" to support notebooks\n    torch.multiprocessing.start_processes(\n        per_device_launch_fn,\n        args=(num_gpu,),\n        nprocs=num_gpu,\n        join=True,\n        start_method=\"fork\",\n    )\n\n\"\"\"\nThat's it!\n\"\"\"\n", "file_name": "422890.py", "cwe": ["CWE-676: Use of Potentially Dangerous Function"]}
{"source": "\"\"\"IMDB sentiment classification dataset.\"\"\"\n\nimport json\n\nimport numpy as np\n\nfrom keras.src.api_export import keras_export\nfrom keras.src.utils.file_utils import get_file\nfrom keras.src.utils.python_utils import remove_long_seq\n\n\n@keras_export(\"keras.datasets.imdb.load_data\")\ndef load_data(\n    path=\"imdb.npz\",\n    num_words=None,\n    skip_top=0,\n    maxlen=None,\n    seed=113,\n    start_char=1,\n    oov_char=2,\n    index_from=3,\n    **kwargs,\n):\n    \"\"\"Loads the [IMDB dataset](https://ai.stanford.edu/~amaas/data/sentiment/).\n\n    This is a dataset of 25,000 movies reviews from IMDB, labeled by sentiment\n    (positive/negative). Reviews have been preprocessed, and each review is\n    encoded as a list of word indexes (integers).\n    For convenience, words are indexed by overall frequency in the dataset,\n    so that for instance the integer \"3\" encodes the 3rd most frequent word in\n    the data. This allows for quick filtering operations such as:\n    \"only consider the top 10,000 most\n    common words, but eliminate the top 20 most common words\".\n\n    As a convention, \"0\" does not stand for a specific word, but instead is used\n    to encode the pad token.\n\n    Args:\n        path: where to cache the data (relative to `~/.keras/dataset`).\n        num_words: integer or None. Words are\n            ranked by how often they occur (in the training set) and only\n            the `num_words` most frequent words are kept. Any less frequent word\n            will appear as `oov_char` value in the sequence data. If None,\n            all words are kept. Defaults to `None`.\n        skip_top: skip the top N most frequently occurring words\n            (which may not be informative). These words will appear as\n            `oov_char` value in the dataset. When 0, no words are\n            skipped. Defaults to `0`.\n        maxlen: int or None. Maximum sequence length.\n            Any longer sequence will be truncated. None, means no truncation.\n            Defaults to `None`.\n        seed: int. Seed for reproducible data shuffling.\n        start_char: int. The start of a sequence will be marked with this\n            character. 0 is usually the padding character. Defaults to `1`.\n        oov_char: int. The out-of-vocabulary character.\n            Words that were cut out because of the `num_words` or\n            `skip_top` limits will be replaced with this character.\n        index_from: int. Index actual words with this index and higher.\n\n    Returns:\n        Tuple of Numpy arrays: `(x_train, y_train), (x_test, y_test)`.\n\n    **`x_train`, `x_test`**: lists of sequences, which are lists of indexes\n      (integers). If the num_words argument was specific, the maximum\n      possible index value is `num_words - 1`. If the `maxlen` argument was\n      specified, the largest possible sequence length is `maxlen`.\n\n    **`y_train`, `y_test`**: lists of integer labels (1 or 0).\n\n    **Note**: The 'out of vocabulary' character is only used for\n    words that were present in the training set but are not included\n    because they're not making the `num_words` cut here.\n    Words that were not seen in the training set but are in the test set\n    have simply been skipped.\n    \"\"\"\n    origin_folder = (\n        \"https://storage.googleapis.com/tensorflow/tf-keras-datasets/\"\n    )\n    path = get_file(\n        fname=path,\n        origin=origin_folder + \"imdb.npz\",\n        file_hash=(  # noqa: E501\n            \"69664113be75683a8fe16e3ed0ab59fda8886cb3cd7ada244f7d9544e4676b9f\"\n        ),\n    )\n    with np.load(path, allow_pickle=True) as f:\n        x_train, labels_train = f[\"x_train\"], f[\"y_train\"]\n        x_test, labels_test = f[\"x_test\"], f[\"y_test\"]\n\n    rng = np.random.RandomState(seed)\n    indices = np.arange(len(x_train))\n    rng.shuffle(indices)\n    x_train = x_train[indices]\n    labels_train = labels_train[indices]\n\n    indices = np.arange(len(x_test))\n    rng.shuffle(indices)\n    x_test = x_test[indices]\n    labels_test = labels_test[indices]\n\n    if start_char is not None:\n        x_train = [[start_char] + [w + index_from for w in x] for x in x_train]\n        x_test = [[start_char] + [w + index_from for w in x] for x in x_test]\n    elif index_from:\n        x_train = [[w + index_from for w in x] for x in x_train]\n        x_test = [[w + index_from for w in x] for x in x_test]\n    else:\n        x_train = [[w for w in x] for x in x_train]\n        x_test = [[w for w in x] for x in x_test]\n\n    if maxlen:\n        x_train, labels_train = remove_long_seq(maxlen, x_train, labels_train)\n        x_test, labels_test = remove_long_seq(maxlen, x_test, labels_test)\n        if not x_train or not x_test:\n            raise ValueError(\n                \"After filtering for sequences shorter than maxlen=\"\n                f\"{str(maxlen)}, no sequence was kept. Increase maxlen.\"\n            )\n\n    xs = x_train + x_test\n    labels = np.concatenate([labels_train, labels_test])\n\n    if not num_words:\n        num_words = max(max(x) for x in xs)\n\n    # by convention, use 2 as OOV word\n    # reserve 'index_from' (=3 by default) characters:\n    # 0 (padding), 1 (start), 2 (OOV)\n    if oov_char is not None:\n        xs = [\n            [w if (skip_top <= w < num_words) else oov_char for w in x]\n            for x in xs\n        ]\n    else:\n        xs = [[w for w in x if skip_top <= w < num_words] for x in xs]\n\n    idx = len(x_train)\n    x_train, y_train = np.array(xs[:idx], dtype=\"object\"), labels[:idx]\n    x_test, y_test = np.array(xs[idx:], dtype=\"object\"), labels[idx:]\n    return (x_train, y_train), (x_test, y_test)\n\n\n@keras_export(\"keras.datasets.imdb.get_word_index\")\ndef get_word_index(path=\"imdb_word_index.json\"):\n    \"\"\"Retrieves a dict mapping words to their index in the IMDB dataset.\n\n    Args:\n        path: where to cache the data (relative to `~/.keras/dataset`).\n\n    Returns:\n        The word index dictionary. Keys are word strings, values are their\n        index.\n\n    Example:\n\n    ```python\n    # Use the default parameters to keras.datasets.imdb.load_data\n    start_char = 1\n    oov_char = 2\n    index_from = 3\n    # Retrieve the training sequences.\n    (x_train, _), _ = keras.datasets.imdb.load_data(\n        start_char=start_char, oov_char=oov_char, index_from=index_from\n    )\n    # Retrieve the word index file mapping words to indices\n    word_index = keras.datasets.imdb.get_word_index()\n    # Reverse the word index to obtain a dict mapping indices to words\n    # And add `index_from` to indices to sync with `x_train`\n    inverted_word_index = dict(\n        (i + index_from, word) for (word, i) in word_index.items()\n    )\n    # Update `inverted_word_index` to include `start_char` and `oov_char`\n    inverted_word_index[start_char] = \"[START]\"\n    inverted_word_index[oov_char] = \"[OOV]\"\n    # Decode the first sequence in the dataset\n    decoded_sequence = \" \".join(inverted_word_index[i] for i in x_train[0])\n    ```\n    \"\"\"\n    origin_folder = (\n        \"https://storage.googleapis.com/tensorflow/tf-keras-datasets/\"\n    )\n    path = get_file(\n        fname=path,\n        origin=origin_folder + \"imdb_word_index.json\",\n        file_hash=\"bfafd718b763782e994055a2d397834f\",\n    )\n    with open(path) as f:\n        return json.load(f)\n", "file_name": "001029.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "\"\"\"Reuters topic classification dataset.\"\"\"\n\nimport json\n\nimport numpy as np\n\nfrom keras.src.api_export import keras_export\nfrom keras.src.utils.file_utils import get_file\nfrom keras.src.utils.python_utils import remove_long_seq\n\n\n@keras_export(\"keras.datasets.reuters.load_data\")\ndef load_data(\n    path=\"reuters.npz\",\n    num_words=None,\n    skip_top=0,\n    maxlen=None,\n    test_split=0.2,\n    seed=113,\n    start_char=1,\n    oov_char=2,\n    index_from=3,\n):\n    \"\"\"Loads the Reuters newswire classification dataset.\n\n    This is a dataset of 11,228 newswires from Reuters, labeled over 46 topics.\n\n    This was originally generated by parsing and preprocessing the classic\n    Reuters-21578 dataset, but the preprocessing code is no longer packaged\n    with Keras. See this\n    [GitHub discussion](https://github.com/keras-team/keras/issues/12072)\n    for more info.\n\n    Each newswire is encoded as a list of word indexes (integers).\n    For convenience, words are indexed by overall frequency in the dataset,\n    so that for instance the integer \"3\" encodes the 3rd most frequent word in\n    the data. This allows for quick filtering operations such as:\n    \"only consider the top 10,000 most\n    common words, but eliminate the top 20 most common words\".\n\n    As a convention, \"0\" does not stand for a specific word, but instead is used\n    to encode any unknown word.\n\n    Args:\n        path: where to cache the data (relative to `~/.keras/dataset`).\n        num_words: integer or None. Words are\n            ranked by how often they occur (in the training set) and only\n            the `num_words` most frequent words are kept. Any less frequent word\n            will appear as `oov_char` value in the sequence data. If None,\n            all words are kept. Defaults to `None`.\n        skip_top: skip the top N most frequently occurring words\n            (which may not be informative). These words will appear as\n            `oov_char` value in the dataset. 0 means no words are\n            skipped. Defaults to `0`.\n        maxlen: int or None. Maximum sequence length.\n            Any longer sequence will be truncated. None means no truncation.\n            Defaults to `None`.\n        test_split: Float between `0.` and `1.`. Fraction of the dataset to be\n            used as test data. `0.2` means that 20% of the dataset is used as\n            test data. Defaults to `0.2`.\n        seed: int. Seed for reproducible data shuffling.\n        start_char: int. The start of a sequence will be marked with this\n            character. 0 is usually the padding character. Defaults to `1`.\n        oov_char: int. The out-of-vocabulary character.\n            Words that were cut out because of the `num_words` or\n            `skip_top` limits will be replaced with this character.\n        index_from: int. Index actual words with this index and higher.\n\n    Returns:\n        Tuple of Numpy arrays: `(x_train, y_train), (x_test, y_test)`.\n\n    **`x_train`, `x_test`**: lists of sequences, which are lists of indexes\n      (integers). If the num_words argument was specific, the maximum\n      possible index value is `num_words - 1`. If the `maxlen` argument was\n      specified, the largest possible sequence length is `maxlen`.\n\n    **`y_train`, `y_test`**: lists of integer labels (1 or 0).\n\n    **Note**: The 'out of vocabulary' character is only used for\n    words that were present in the training set but are not included\n    because they're not making the `num_words` cut here.\n    Words that were not seen in the training set but are in the test set\n    have simply been skipped.\n    \"\"\"\n    origin_folder = (\n        \"https://storage.googleapis.com/tensorflow/tf-keras-datasets/\"\n    )\n    path = get_file(\n        fname=path,\n        origin=origin_folder + \"reuters.npz\",\n        file_hash=(  # noqa: E501\n            \"d6586e694ee56d7a4e65172e12b3e987c03096cb01eab99753921ef915959916\"\n        ),\n    )\n    with np.load(path, allow_pickle=True) as f:\n        xs, labels = f[\"x\"], f[\"y\"]\n\n    rng = np.random.RandomState(seed)\n    indices = np.arange(len(xs))\n    rng.shuffle(indices)\n    xs = xs[indices]\n    labels = labels[indices]\n\n    if start_char is not None:\n        xs = [[start_char] + [w + index_from for w in x] for x in xs]\n    elif index_from:\n        xs = [[w + index_from for w in x] for x in xs]\n\n    if maxlen:\n        xs, labels = remove_long_seq(maxlen, xs, labels)\n\n    if not num_words:\n        num_words = max(max(x) for x in xs)\n\n    # by convention, use 2 as OOV word\n    # reserve 'index_from' (=3 by default) characters:\n    # 0 (padding), 1 (start), 2 (OOV)\n    if oov_char is not None:\n        xs = [\n            [w if skip_top <= w < num_words else oov_char for w in x]\n            for x in xs\n        ]\n    else:\n        xs = [[w for w in x if skip_top <= w < num_words] for x in xs]\n\n    idx = int(len(xs) * (1 - test_split))\n    x_train, y_train = np.array(xs[:idx], dtype=\"object\"), np.array(\n        labels[:idx]\n    )\n    x_test, y_test = np.array(xs[idx:], dtype=\"object\"), np.array(labels[idx:])\n\n    return (x_train, y_train), (x_test, y_test)\n\n\n@keras_export(\"keras.datasets.reuters.get_word_index\")\ndef get_word_index(path=\"reuters_word_index.json\"):\n    \"\"\"Retrieves a dict mapping words to their index in the Reuters dataset.\n\n    Actual word indices starts from 3, with 3 indices reserved for:\n    0 (padding), 1 (start), 2 (oov).\n\n    E.g. word index of 'the' is 1, but the in the actual training data, the\n    index of 'the' will be 1 + 3 = 4. Vice versa, to translate word indices in\n    training data back to words using this mapping, indices need to subtract 3.\n\n    Args:\n        path: where to cache the data (relative to `~/.keras/dataset`).\n\n    Returns:\n        The word index dictionary. Keys are word strings, values are their\n        index.\n    \"\"\"\n    origin_folder = (\n        \"https://storage.googleapis.com/tensorflow/tf-keras-datasets/\"\n    )\n    path = get_file(\n        path,\n        origin=origin_folder + \"reuters_word_index.json\",\n        file_hash=\"4d44cc38712099c9e383dc6e5f11a921\",\n    )\n    with open(path) as f:\n        return json.load(f)\n\n\n@keras_export(\"keras.datasets.reuters.get_label_names\")\ndef get_label_names():\n    \"\"\"Returns labels as a list of strings with indices matching training data.\n\n    Reference:\n\n    - [Reuters Dataset](https://martin-thoma.com/nlp-reuters/)\n    \"\"\"\n    return (\n        \"cocoa\",\n        \"grain\",\n        \"veg-oil\",\n        \"earn\",\n        \"acq\",\n        \"wheat\",\n        \"copper\",\n        \"housing\",\n        \"money-supply\",\n        \"coffee\",\n        \"sugar\",\n        \"trade\",\n        \"reserves\",\n        \"ship\",\n        \"cotton\",\n        \"carcass\",\n        \"crude\",\n        \"nat-gas\",\n        \"cpi\",\n        \"money-fx\",\n        \"interest\",\n        \"gnp\",\n        \"meal-feed\",\n        \"alum\",\n        \"oilseed\",\n        \"gold\",\n        \"tin\",\n        \"strategic-metal\",\n        \"livestock\",\n        \"retail\",\n        \"ipi\",\n        \"iron-steel\",\n        \"rubber\",\n        \"heat\",\n        \"jobs\",\n        \"lei\",\n        \"bop\",\n        \"zinc\",\n        \"orange\",\n        \"pet-chem\",\n        \"dlr\",\n        \"gas\",\n        \"silver\",\n        \"wpi\",\n        \"hog\",\n        \"lead\",\n    )\n", "file_name": "780018.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "from __future__ import annotations\n\nimport os\nfrom xml.etree import ElementTree as ET\n\nimport numpy as np\nimport svgelements as se\nimport io\n\nfrom manimlib.constants import RIGHT\nfrom manimlib.logger import log\nfrom manimlib.mobject.geometry import Circle\nfrom manimlib.mobject.geometry import Line\nfrom manimlib.mobject.geometry import Polygon\nfrom manimlib.mobject.geometry import Polyline\nfrom manimlib.mobject.geometry import Rectangle\nfrom manimlib.mobject.geometry import RoundedRectangle\nfrom manimlib.mobject.types.vectorized_mobject import VMobject\nfrom manimlib.utils.directories import get_mobject_data_dir\nfrom manimlib.utils.images import get_full_vector_image_path\nfrom manimlib.utils.iterables import hash_obj\nfrom manimlib.utils.simple_functions import hash_string\n\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from typing import Tuple\n    from manimlib.typing import ManimColor, Vect3Array\n\n\n\nSVG_HASH_TO_MOB_MAP: dict[int, list[VMobject]] = {}\nPATH_TO_POINTS: dict[str, Vect3Array] = {}\n\n\ndef _convert_point_to_3d(x: float, y: float) -> np.ndarray:\n    return np.array([x, y, 0.0])\n\n\nclass SVGMobject(VMobject):\n    file_name: str = \"\"\n    height: float | None = 2.0\n    width: float | None = None\n\n    def __init__(\n        self,\n        file_name: str = \"\",\n        should_center: bool = True,\n        height: float | None = None,\n        width: float | None = None,\n        # Style that overrides the original svg\n        color: ManimColor = None,\n        fill_color: ManimColor = None,\n        fill_opacity: float | None = None,\n        stroke_width: float | None = 0.0,\n        stroke_color: ManimColor = None,\n        stroke_opacity: float | None = None,\n        # Style that fills only when not specified\n        # If None, regarded as default values from svg standard\n        svg_default: dict = dict(\n            color=None,\n            opacity=None,\n            fill_color=None,\n            fill_opacity=None,\n            stroke_width=None,\n            stroke_color=None,\n            stroke_opacity=None,\n        ),\n        path_string_config: dict = dict(),\n        **kwargs\n    ):\n        self.file_name = file_name or self.file_name\n        self.svg_default = dict(svg_default)\n        self.path_string_config = dict(path_string_config)\n\n        super().__init__(**kwargs )\n        self.init_svg_mobject()\n        self.ensure_positive_orientation()\n\n        # Rather than passing style into super().__init__\n        # do it after svg has been taken in\n        self.set_style(\n            fill_color=color or fill_color,\n            fill_opacity=fill_opacity,\n            stroke_color=color or stroke_color,\n            stroke_width=stroke_width,\n            stroke_opacity=stroke_opacity,\n        )\n\n        # Initialize position\n        height = height or self.height\n        width = width or self.width\n\n        if should_center:\n            self.center()\n        if height is not None:\n            self.set_height(height)\n        if width is not None:\n            self.set_width(width)\n\n    def init_svg_mobject(self) -> None:\n        hash_val = hash_obj(self.hash_seed)\n        if hash_val in SVG_HASH_TO_MOB_MAP:\n            submobs = [sm.copy() for sm in SVG_HASH_TO_MOB_MAP[hash_val]]\n        else:\n            submobs = self.mobjects_from_file(self.get_file_path())\n            SVG_HASH_TO_MOB_MAP[hash_val] = [sm.copy() for sm in submobs]\n\n        self.add(*submobs)\n        self.flip(RIGHT)  # Flip y\n\n    @property\n    def hash_seed(self) -> tuple:\n        # Returns data which can uniquely represent the result of `init_points`.\n        # The hashed value of it is stored as a key in `SVG_HASH_TO_MOB_MAP`.\n        return (\n            self.__class__.__name__,\n            self.svg_default,\n            self.path_string_config,\n            self.file_name\n        )\n\n    def mobjects_from_file(self, file_path: str) -> list[VMobject]:\n        element_tree = ET.parse(file_path)\n        new_tree = self.modify_xml_tree(element_tree)\n\n        # New svg based on tree contents\n        data_stream = io.BytesIO()\n        new_tree.write(data_stream)\n        data_stream.seek(0)\n        svg = se.SVG.parse(data_stream)\n        data_stream.close()\n\n        return self.mobjects_from_svg(svg)\n\n    def get_file_path(self) -> str:\n        if self.file_name is None:\n            raise Exception(\"Must specify file for SVGMobject\")\n        return get_full_vector_image_path(self.file_name)\n\n    def modify_xml_tree(self, element_tree: ET.ElementTree) -> ET.ElementTree:\n        config_style_attrs = self.generate_config_style_dict()\n        style_keys = (\n            \"fill\",\n            \"fill-opacity\",\n            \"stroke\",\n            \"stroke-opacity\",\n            \"stroke-width\",\n            \"style\"\n        )\n        root = element_tree.getroot()\n        style_attrs = {\n            k: v\n            for k, v in root.attrib.items()\n            if k in style_keys\n        }\n\n        # Ignore other attributes in case that svgelements cannot parse them\n        SVG_XMLNS = \"{http://www.w3.org/2000/svg}\"\n        new_root = ET.Element(\"svg\")\n        config_style_node = ET.SubElement(new_root, f\"{SVG_XMLNS}g\", config_style_attrs)\n        root_style_node = ET.SubElement(config_style_node, f\"{SVG_XMLNS}g\", style_attrs)\n        root_style_node.extend(root)\n        return ET.ElementTree(new_root)\n\n    def generate_config_style_dict(self) -> dict[str, str]:\n        keys_converting_dict = {\n            \"fill\": (\"color\", \"fill_color\"),\n            \"fill-opacity\": (\"opacity\", \"fill_opacity\"),\n            \"stroke\": (\"color\", \"stroke_color\"),\n            \"stroke-opacity\": (\"opacity\", \"stroke_opacity\"),\n            \"stroke-width\": (\"stroke_width\",)\n        }\n        svg_default_dict = self.svg_default\n        result = {}\n        for svg_key, style_keys in keys_converting_dict.items():\n            for style_key in style_keys:\n                if svg_default_dict[style_key] is None:\n                    continue\n                result[svg_key] = str(svg_default_dict[style_key])\n        return result\n\n    def mobjects_from_svg(self, svg: se.SVG) -> list[VMobject]:\n        result = []\n        for shape in svg.elements():\n            if isinstance(shape, (se.Group, se.Use)):\n                continue\n            elif isinstance(shape, se.Path):\n                mob = self.path_to_mobject(shape)\n            elif isinstance(shape, se.SimpleLine):\n                mob = self.line_to_mobject(shape)\n            elif isinstance(shape, se.Rect):\n                mob = self.rect_to_mobject(shape)\n            elif isinstance(shape, (se.Circle, se.Ellipse)):\n                mob = self.ellipse_to_mobject(shape)\n            elif isinstance(shape, se.Polygon):\n                mob = self.polygon_to_mobject(shape)\n            elif isinstance(shape, se.Polyline):\n                mob = self.polyline_to_mobject(shape)\n            # elif isinstance(shape, se.Text):\n            #     mob = self.text_to_mobject(shape)\n            elif type(shape) == se.SVGElement:\n                continue\n            else:\n                log.warning(\"Unsupported element type: %s\", type(shape))\n                continue\n            if not mob.has_points():\n                continue\n            if isinstance(shape, se.GraphicObject):\n                self.apply_style_to_mobject(mob, shape)\n            if isinstance(shape, se.Transformable) and shape.apply:\n                self.handle_transform(mob, shape.transform)\n            result.append(mob)\n        return result\n\n    @staticmethod\n    def handle_transform(mob: VMobject, matrix: se.Matrix) -> VMobject:\n        mat = np.array([\n            [matrix.a, matrix.c],\n            [matrix.b, matrix.d]\n        ])\n        vec = np.array([matrix.e, matrix.f, 0.0])\n        mob.apply_matrix(mat)\n        mob.shift(vec)\n        return mob\n\n    @staticmethod\n    def apply_style_to_mobject(\n        mob: VMobject,\n        shape: se.GraphicObject\n    ) -> VMobject:\n        mob.set_style(\n            stroke_width=shape.stroke_width,\n            stroke_color=shape.stroke.hexrgb,\n            stroke_opacity=shape.stroke.opacity,\n            fill_color=shape.fill.hexrgb,\n            fill_opacity=shape.fill.opacity\n        )\n        return mob\n\n    def path_to_mobject(self, path: se.Path) -> VMobjectFromSVGPath:\n        return VMobjectFromSVGPath(path, **self.path_string_config)\n\n    def line_to_mobject(self, line: se.SimpleLine) -> Line:\n        return Line(\n            start=_convert_point_to_3d(line.x1, line.y1),\n            end=_convert_point_to_3d(line.x2, line.y2)\n        )\n\n    def rect_to_mobject(self, rect: se.Rect) -> Rectangle:\n        if rect.rx == 0 or rect.ry == 0:\n            mob = Rectangle(\n                width=rect.width,\n                height=rect.height,\n            )\n        else:\n            mob = RoundedRectangle(\n                width=rect.width,\n                height=rect.height * rect.rx / rect.ry,\n                corner_radius=rect.rx\n            )\n            mob.stretch_to_fit_height(rect.height)\n        mob.shift(_convert_point_to_3d(\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ))\n        return mob\n\n    def ellipse_to_mobject(self, ellipse: se.Circle | se.Ellipse) -> Circle:\n        mob = Circle(radius=ellipse.rx)\n        mob.stretch_to_fit_height(2 * ellipse.ry)\n        mob.shift(_convert_point_to_3d(\n            ellipse.cx, ellipse.cy\n        ))\n        return mob\n\n    def polygon_to_mobject(self, polygon: se.Polygon) -> Polygon:\n        points = [\n            _convert_point_to_3d(*point)\n            for point in polygon\n        ]\n        return Polygon(*points)\n\n    def polyline_to_mobject(self, polyline: se.Polyline) -> Polyline:\n        points = [\n            _convert_point_to_3d(*point)\n            for point in polyline\n        ]\n        return Polyline(*points)\n\n    def text_to_mobject(self, text: se.Text):\n        pass\n\n\nclass VMobjectFromSVGPath(VMobject):\n    def __init__(\n        self,\n        path_obj: se.Path,\n        **kwargs\n    ):\n        # Get rid of arcs\n        path_obj.approximate_arcs_with_quads()\n        self.path_obj = path_obj\n        super().__init__(**kwargs)\n\n    def init_points(self) -> None:\n        # After a given svg_path has been converted into points, the result\n        # will be saved so that future calls for the same pathdon't need to\n        # retrace the same computation.\n        path_string = self.path_obj.d()\n        if path_string not in PATH_TO_POINTS:\n            self.handle_commands()\n            if not self._use_winding_fill:\n                self.subdivide_intersections()\n            # Save for future use\n            PATH_TO_POINTS[path_string] = self.get_points().copy()\n        else:\n            points = PATH_TO_POINTS[path_string]\n            self.set_points(points)\n\n    def handle_commands(self) -> None:\n        segment_class_to_func_map = {\n            se.Move: (self.start_new_path, (\"end\",)),\n            se.Close: (self.close_path, ()),\n            se.Line: (self.add_line_to, (\"end\",)),\n            se.QuadraticBezier: (self.add_quadratic_bezier_curve_to, (\"control\", \"end\")),\n            se.CubicBezier: (self.add_cubic_bezier_curve_to, (\"control1\", \"control2\", \"end\"))\n        }\n        for segment in self.path_obj:\n            segment_class = segment.__class__\n            func, attr_names = segment_class_to_func_map[segment_class]\n            points = [\n                _convert_point_to_3d(*segment.__getattribute__(attr_name))\n                for attr_name in attr_names\n            ]\n            func(*points)\n\n        # Get rid of the side effect of trailing \"Z M\" commands.\n        if self.has_new_path_started():\n            self.resize_points(self.get_num_points() - 2)\n", "file_name": "703706.py", "cwe": ["CWE-611: Improper Restriction of XML External Entity Reference"]}
{"source": "\"\"\"\n===============================\nWikipedia principal eigenvector\n===============================\n\nA classical way to assert the relative importance of vertices in a\ngraph is to compute the principal eigenvector of the adjacency matrix\nso as to assign to each vertex the values of the components of the first\neigenvector as a centrality score:\n\n    https://en.wikipedia.org/wiki/Eigenvector_centrality\n\nOn the graph of webpages and links those values are called the PageRank\nscores by Google.\n\nThe goal of this example is to analyze the graph of links inside\nwikipedia articles to rank articles by relative importance according to\nthis eigenvector centrality.\n\nThe traditional way to compute the principal eigenvector is to use the\npower iteration method:\n\n    https://en.wikipedia.org/wiki/Power_iteration\n\nHere the computation is achieved thanks to Martinsson's Randomized SVD\nalgorithm implemented in scikit-learn.\n\nThe graph data is fetched from the DBpedia dumps. DBpedia is an extraction\nof the latent structured data of the Wikipedia content.\n\n\"\"\"\n\n# Authors: The scikit-learn developers\n# SPDX-License-Identifier: BSD-3-Clause\n\nimport os\nfrom bz2 import BZ2File\nfrom datetime import datetime\nfrom pprint import pprint\nfrom time import time\nfrom urllib.request import urlopen\n\nimport numpy as np\nfrom scipy import sparse\n\nfrom sklearn.decomposition import randomized_svd\n\n# %%\n# Download data, if not already on disk\n# -------------------------------------\nredirects_url = \"http://downloads.dbpedia.org/3.5.1/en/redirects_en.nt.bz2\"\nredirects_filename = redirects_url.rsplit(\"/\", 1)[1]\n\npage_links_url = \"http://downloads.dbpedia.org/3.5.1/en/page_links_en.nt.bz2\"\npage_links_filename = page_links_url.rsplit(\"/\", 1)[1]\n\nresources = [\n    (redirects_url, redirects_filename),\n    (page_links_url, page_links_filename),\n]\n\nfor url, filename in resources:\n    if not os.path.exists(filename):\n        print(\"Downloading data from '%s', please wait...\" % url)\n        opener = urlopen(url)\n        with open(filename, \"wb\") as f:\n            f.write(opener.read())\n        print()\n\n\n# %%\n# Loading the redirect files\n# --------------------------\ndef index(redirects, index_map, k):\n    \"\"\"Find the index of an article name after redirect resolution\"\"\"\n    k = redirects.get(k, k)\n    return index_map.setdefault(k, len(index_map))\n\n\nDBPEDIA_RESOURCE_PREFIX_LEN = len(\"http://dbpedia.org/resource/\")\nSHORTNAME_SLICE = slice(DBPEDIA_RESOURCE_PREFIX_LEN + 1, -1)\n\n\ndef short_name(nt_uri):\n    \"\"\"Remove the < and > URI markers and the common URI prefix\"\"\"\n    return nt_uri[SHORTNAME_SLICE]\n\n\ndef get_redirects(redirects_filename):\n    \"\"\"Parse the redirections and build a transitively closed map out of it\"\"\"\n    redirects = {}\n    print(\"Parsing the NT redirect file\")\n    for l, line in enumerate(BZ2File(redirects_filename)):\n        split = line.split()\n        if len(split) != 4:\n            print(\"ignoring malformed line: \" + line)\n            continue\n        redirects[short_name(split[0])] = short_name(split[2])\n        if l % 1000000 == 0:\n            print(\"[%s] line: %08d\" % (datetime.now().isoformat(), l))\n\n    # compute the transitive closure\n    print(\"Computing the transitive closure of the redirect relation\")\n    for l, source in enumerate(redirects.keys()):\n        transitive_target = None\n        target = redirects[source]\n        seen = {source}\n        while True:\n            transitive_target = target\n            target = redirects.get(target)\n            if target is None or target in seen:\n                break\n            seen.add(target)\n        redirects[source] = transitive_target\n        if l % 1000000 == 0:\n            print(\"[%s] line: %08d\" % (datetime.now().isoformat(), l))\n\n    return redirects\n\n\n# %%\n# Computing the Adjacency matrix\n# ------------------------------\ndef get_adjacency_matrix(redirects_filename, page_links_filename, limit=None):\n    \"\"\"Extract the adjacency graph as a scipy sparse matrix\n\n    Redirects are resolved first.\n\n    Returns X, the scipy sparse adjacency matrix, redirects as python\n    dict from article names to article names and index_map a python dict\n    from article names to python int (article indexes).\n    \"\"\"\n\n    print(\"Computing the redirect map\")\n    redirects = get_redirects(redirects_filename)\n\n    print(\"Computing the integer index map\")\n    index_map = dict()\n    links = list()\n    for l, line in enumerate(BZ2File(page_links_filename)):\n        split = line.split()\n        if len(split) != 4:\n            print(\"ignoring malformed line: \" + line)\n            continue\n        i = index(redirects, index_map, short_name(split[0]))\n        j = index(redirects, index_map, short_name(split[2]))\n        links.append((i, j))\n        if l % 1000000 == 0:\n            print(\"[%s] line: %08d\" % (datetime.now().isoformat(), l))\n\n        if limit is not None and l >= limit - 1:\n            break\n\n    print(\"Computing the adjacency matrix\")\n    X = sparse.lil_matrix((len(index_map), len(index_map)), dtype=np.float32)\n    for i, j in links:\n        X[i, j] = 1.0\n    del links\n    print(\"Converting to CSR representation\")\n    X = X.tocsr()\n    print(\"CSR conversion done\")\n    return X, redirects, index_map\n\n\n# stop after 5M links to make it possible to work in RAM\nX, redirects, index_map = get_adjacency_matrix(\n    redirects_filename, page_links_filename, limit=5000000\n)\nnames = {i: name for name, i in index_map.items()}\n\n\n# %%\n# Computing Principal Singular Vector using Randomized SVD\n# --------------------------------------------------------\nprint(\"Computing the principal singular vectors using randomized_svd\")\nt0 = time()\nU, s, V = randomized_svd(X, 5, n_iter=3)\nprint(\"done in %0.3fs\" % (time() - t0))\n\n# print the names of the wikipedia related strongest components of the\n# principal singular vector which should be similar to the highest eigenvector\nprint(\"Top wikipedia pages according to principal singular vectors\")\npprint([names[i] for i in np.abs(U.T[0]).argsort()[-10:]])\npprint([names[i] for i in np.abs(V[0]).argsort()[-10:]])\n\n\n# %%\n# Computing Centrality scores\n# ---------------------------\ndef centrality_scores(X, alpha=0.85, max_iter=100, tol=1e-10):\n    \"\"\"Power iteration computation of the principal eigenvector\n\n    This method is also known as Google PageRank and the implementation\n    is based on the one from the NetworkX project (BSD licensed too)\n    with copyrights by:\n\n      Aric Hagberg <hagberg@lanl.gov>\n      Dan Schult <dschult@colgate.edu>\n      Pieter Swart <swart@lanl.gov>\n    \"\"\"\n    n = X.shape[0]\n    X = X.copy()\n    incoming_counts = np.asarray(X.sum(axis=1)).ravel()\n\n    print(\"Normalizing the graph\")\n    for i in incoming_counts.nonzero()[0]:\n        X.data[X.indptr[i] : X.indptr[i + 1]] *= 1.0 / incoming_counts[i]\n    dangle = np.asarray(np.where(np.isclose(X.sum(axis=1), 0), 1.0 / n, 0)).ravel()\n\n    scores = np.full(n, 1.0 / n, dtype=np.float32)  # initial guess\n    for i in range(max_iter):\n        print(\"power iteration #%d\" % i)\n        prev_scores = scores\n        scores = (\n            alpha * (scores * X + np.dot(dangle, prev_scores))\n            + (1 - alpha) * prev_scores.sum() / n\n        )\n        # check convergence: normalized l_inf norm\n        scores_max = np.abs(scores).max()\n        if scores_max == 0.0:\n            scores_max = 1.0\n        err = np.abs(scores - prev_scores).max() / scores_max\n        print(\"error: %0.6f\" % err)\n        if err < n * tol:\n            return scores\n\n    return scores\n\n\nprint(\"Computing principal eigenvector score using a power iteration method\")\nt0 = time()\nscores = centrality_scores(X, max_iter=100)\nprint(\"done in %0.3fs\" % (time() - t0))\npprint([names[i] for i in np.abs(scores).argsort()[-10:]])\n", "file_name": "502316.py", "cwe": ["CWE-939: Improper Authorization in Handler for Custom URL Scheme"]}
{"source": "# Authors: The scikit-learn developers\n# SPDX-License-Identifier: BSD-3-Clause\n\nimport importlib\nimport inspect\nimport os\nimport warnings\nfrom inspect import signature\nfrom pkgutil import walk_packages\n\nimport numpy as np\nimport pytest\n\nimport sklearn\nfrom sklearn.datasets import make_classification\n\n# make it possible to discover experimental estimators when calling `all_estimators`\nfrom sklearn.experimental import (\n    enable_halving_search_cv,  # noqa\n    enable_iterative_imputer,  # noqa\n)\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.preprocessing import FunctionTransformer\nfrom sklearn.utils import all_estimators\nfrom sklearn.utils._testing import (\n    _get_func_name,\n    check_docstring_parameters,\n    ignore_warnings,\n)\nfrom sklearn.utils.deprecation import _is_deprecated\nfrom sklearn.utils.estimator_checks import (\n    _construct_instance,\n    _enforce_estimator_tags_X,\n    _enforce_estimator_tags_y,\n)\n\n# walk_packages() ignores DeprecationWarnings, now we need to ignore\n# FutureWarnings\nwith warnings.catch_warnings():\n    warnings.simplefilter(\"ignore\", FutureWarning)\n    # mypy error: Module has no attribute \"__path__\"\n    sklearn_path = [os.path.dirname(sklearn.__file__)]\n    PUBLIC_MODULES = set(\n        [\n            pckg[1]\n            for pckg in walk_packages(prefix=\"sklearn.\", path=sklearn_path)\n            if not (\"._\" in pckg[1] or \".tests.\" in pckg[1])\n        ]\n    )\n\n# functions to ignore args / docstring of\n# TODO(1.7): remove \"sklearn.utils._joblib\"\n_DOCSTRING_IGNORES = [\n    \"sklearn.utils.deprecation.load_mlcomp\",\n    \"sklearn.pipeline.make_pipeline\",\n    \"sklearn.pipeline.make_union\",\n    \"sklearn.utils.extmath.safe_sparse_dot\",\n    \"sklearn.utils._joblib\",\n    \"HalfBinomialLoss\",\n]\n\n# Methods where y param should be ignored if y=None by default\n_METHODS_IGNORE_NONE_Y = [\n    \"fit\",\n    \"score\",\n    \"fit_predict\",\n    \"fit_transform\",\n    \"partial_fit\",\n    \"predict\",\n]\n\n\ndef test_docstring_parameters():\n    # Test module docstring formatting\n\n    # Skip test if numpydoc is not found\n    pytest.importorskip(\n        \"numpydoc\", reason=\"numpydoc is required to test the docstrings\"\n    )\n\n    # XXX unreached code as of v0.22\n    from numpydoc import docscrape\n\n    incorrect = []\n    for name in PUBLIC_MODULES:\n        if name.endswith(\".conftest\"):\n            # pytest tooling, not part of the scikit-learn API\n            continue\n        if name == \"sklearn.utils.fixes\":\n            # We cannot always control these docstrings\n            continue\n        with warnings.catch_warnings(record=True):\n            module = importlib.import_module(name)\n        classes = inspect.getmembers(module, inspect.isclass)\n        # Exclude non-scikit-learn classes\n        classes = [cls for cls in classes if cls[1].__module__.startswith(\"sklearn\")]\n        for cname, cls in classes:\n            this_incorrect = []\n            if cname in _DOCSTRING_IGNORES or cname.startswith(\"_\"):\n                continue\n            if inspect.isabstract(cls):\n                continue\n            with warnings.catch_warnings(record=True) as w:\n                cdoc = docscrape.ClassDoc(cls)\n            if len(w):\n                raise RuntimeError(\n                    \"Error for __init__ of %s in %s:\\n%s\" % (cls, name, w[0])\n                )\n\n            # Skip checks on deprecated classes\n            if _is_deprecated(cls.__new__):\n                continue\n\n            this_incorrect += check_docstring_parameters(cls.__init__, cdoc)\n\n            for method_name in cdoc.methods:\n                method = getattr(cls, method_name)\n                if _is_deprecated(method):\n                    continue\n                param_ignore = None\n                # Now skip docstring test for y when y is None\n                # by default for API reason\n                if method_name in _METHODS_IGNORE_NONE_Y:\n                    sig = signature(method)\n                    if \"y\" in sig.parameters and sig.parameters[\"y\"].default is None:\n                        param_ignore = [\"y\"]  # ignore y for fit and score\n                result = check_docstring_parameters(method, ignore=param_ignore)\n                this_incorrect += result\n\n            incorrect += this_incorrect\n\n        functions = inspect.getmembers(module, inspect.isfunction)\n        # Exclude imported functions\n        functions = [fn for fn in functions if fn[1].__module__ == name]\n        for fname, func in functions:\n            # Don't test private methods / functions\n            if fname.startswith(\"_\"):\n                continue\n            if fname == \"configuration\" and name.endswith(\"setup\"):\n                continue\n            name_ = _get_func_name(func)\n            if not any(d in name_ for d in _DOCSTRING_IGNORES) and not _is_deprecated(\n                func\n            ):\n                incorrect += check_docstring_parameters(func)\n\n    msg = \"\\n\".join(incorrect)\n    if len(incorrect) > 0:\n        raise AssertionError(\"Docstring Error:\\n\" + msg)\n\n\ndef _construct_searchcv_instance(SearchCV):\n    return SearchCV(LogisticRegression(), {\"C\": [0.1, 1]})\n\n\ndef _construct_compose_pipeline_instance(Estimator):\n    # Minimal / degenerate instances: only useful to test the docstrings.\n    if Estimator.__name__ == \"ColumnTransformer\":\n        return Estimator(transformers=[(\"transformer\", \"passthrough\", [0, 1])])\n    elif Estimator.__name__ == \"Pipeline\":\n        return Estimator(steps=[(\"clf\", LogisticRegression())])\n    elif Estimator.__name__ == \"FeatureUnion\":\n        return Estimator(transformer_list=[(\"transformer\", FunctionTransformer())])\n\n\ndef _construct_sparse_coder(Estimator):\n    # XXX: hard-coded assumption that n_features=3\n    dictionary = np.array(\n        [[0, 1, 0], [-1, -1, 2], [1, 1, 1], [0, 1, 1], [0, 2, 1]],\n        dtype=np.float64,\n    )\n    return Estimator(dictionary=dictionary)\n\n\n@pytest.mark.filterwarnings(\"ignore::sklearn.exceptions.ConvergenceWarning\")\n# TODO(1.6): remove \"@pytest.mark.filterwarnings\" as SAMME.R will be removed\n# and substituted with the SAMME algorithm as a default\n@pytest.mark.filterwarnings(\"ignore:The SAMME.R algorithm\")\n@pytest.mark.parametrize(\"name, Estimator\", all_estimators())\ndef test_fit_docstring_attributes(name, Estimator):\n    pytest.importorskip(\"numpydoc\")\n    from numpydoc import docscrape\n\n    doc = docscrape.ClassDoc(Estimator)\n    attributes = doc[\"Attributes\"]\n\n    if Estimator.__name__ in (\n        \"HalvingRandomSearchCV\",\n        \"RandomizedSearchCV\",\n        \"HalvingGridSearchCV\",\n        \"GridSearchCV\",\n    ):\n        est = _construct_searchcv_instance(Estimator)\n    elif Estimator.__name__ in (\n        \"ColumnTransformer\",\n        \"Pipeline\",\n        \"FeatureUnion\",\n    ):\n        est = _construct_compose_pipeline_instance(Estimator)\n    elif Estimator.__name__ == \"SparseCoder\":\n        est = _construct_sparse_coder(Estimator)\n    else:\n        est = _construct_instance(Estimator)\n\n    if Estimator.__name__ == \"SelectKBest\":\n        est.set_params(k=2)\n    elif Estimator.__name__ == \"DummyClassifier\":\n        est.set_params(strategy=\"stratified\")\n    elif Estimator.__name__ == \"CCA\" or Estimator.__name__.startswith(\"PLS\"):\n        # default = 2 is invalid for single target\n        est.set_params(n_components=1)\n    elif Estimator.__name__ in (\n        \"GaussianRandomProjection\",\n        \"SparseRandomProjection\",\n    ):\n        # default=\"auto\" raises an error with the shape of `X`\n        est.set_params(n_components=2)\n    elif Estimator.__name__ == \"TSNE\":\n        # default raises an error, perplexity must be less than n_samples\n        est.set_params(perplexity=2)\n\n    # TODO(1.6): remove (avoid FutureWarning)\n    if Estimator.__name__ in (\"NMF\", \"MiniBatchNMF\"):\n        est.set_params(n_components=\"auto\")\n\n    # Low max iter to speed up tests: we are only interested in checking the existence\n    # of fitted attributes. This should be invariant to whether it has converged or not.\n    if \"max_iter\" in est.get_params():\n        est.set_params(max_iter=2)\n        # min value for `TSNE` is 250\n        if Estimator.__name__ == \"TSNE\":\n            est.set_params(max_iter=250)\n\n    if \"random_state\" in est.get_params():\n        est.set_params(random_state=0)\n\n    # In case we want to deprecate some attributes in the future\n    skipped_attributes = {}\n\n    if Estimator.__name__.endswith(\"Vectorizer\"):\n        # Vectorizer require some specific input data\n        if Estimator.__name__ in (\n            \"CountVectorizer\",\n            \"HashingVectorizer\",\n            \"TfidfVectorizer\",\n        ):\n            X = [\n                \"This is the first document.\",\n                \"This document is the second document.\",\n                \"And this is the third one.\",\n                \"Is this the first document?\",\n            ]\n        elif Estimator.__name__ == \"DictVectorizer\":\n            X = [{\"foo\": 1, \"bar\": 2}, {\"foo\": 3, \"baz\": 1}]\n        y = None\n    else:\n        X, y = make_classification(\n            n_samples=20,\n            n_features=3,\n            n_redundant=0,\n            n_classes=2,\n            random_state=2,\n        )\n\n        y = _enforce_estimator_tags_y(est, y)\n        X = _enforce_estimator_tags_X(est, X)\n\n    if \"1dlabels\" in est._get_tags()[\"X_types\"]:\n        est.fit(y)\n    elif \"2dlabels\" in est._get_tags()[\"X_types\"]:\n        est.fit(np.c_[y, y])\n    elif \"3darray\" in est._get_tags()[\"X_types\"]:\n        est.fit(X[np.newaxis, ...], y)\n    else:\n        est.fit(X, y)\n\n    for attr in attributes:\n        if attr.name in skipped_attributes:\n            continue\n        desc = \" \".join(attr.desc).lower()\n        # As certain attributes are present \"only\" if a certain parameter is\n        # provided, this checks if the word \"only\" is present in the attribute\n        # description, and if not the attribute is required to be present.\n        if \"only \" in desc:\n            continue\n        # ignore deprecation warnings\n        with ignore_warnings(category=FutureWarning):\n            assert hasattr(est, attr.name)\n\n    fit_attr = _get_all_fitted_attributes(est)\n    fit_attr_names = [attr.name for attr in attributes]\n    undocumented_attrs = set(fit_attr).difference(fit_attr_names)\n    undocumented_attrs = set(undocumented_attrs).difference(skipped_attributes)\n    if undocumented_attrs:\n        raise AssertionError(\n            f\"Undocumented attributes for {Estimator.__name__}: {undocumented_attrs}\"\n        )\n\n\ndef _get_all_fitted_attributes(estimator):\n    \"Get all the fitted attributes of an estimator including properties\"\n    # attributes\n    fit_attr = list(estimator.__dict__.keys())\n\n    # properties\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"error\", category=FutureWarning)\n\n        for name in dir(estimator.__class__):\n            obj = getattr(estimator.__class__, name)\n            if not isinstance(obj, property):\n                continue\n\n            # ignore properties that raises an AttributeError and deprecated\n            # properties\n            try:\n                getattr(estimator, name)\n            except (AttributeError, FutureWarning):\n                continue\n            fit_attr.append(name)\n\n    return [k for k in fit_attr if k.endswith(\"_\") and not k.startswith(\"_\")]\n", "file_name": "352492.py", "cwe": ["CWE-706: Use of Incorrectly-Resolved Name or Reference"]}
{"source": "\"\"\"Module for initialization hooks https://docs.localstack.cloud/references/init-hooks/\"\"\"\n\nimport dataclasses\nimport logging\nimport os.path\nimport subprocess\nimport time\nfrom enum import Enum\nfrom functools import cached_property\nfrom typing import Dict, List, Optional\n\nfrom plux import Plugin, PluginManager\n\nfrom localstack import constants\nfrom localstack.runtime import hooks\nfrom localstack.utils.objects import singleton_factory\n\nLOG = logging.getLogger(__name__)\n\n\nclass State(Enum):\n    UNKNOWN = \"UNKNOWN\"\n    RUNNING = \"RUNNING\"\n    SUCCESSFUL = \"SUCCESSFUL\"\n    ERROR = \"ERROR\"\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return self.name\n\n\nclass Stage(Enum):\n    BOOT = 0\n    START = 1\n    READY = 2\n    SHUTDOWN = 3\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return self.name\n\n\n@dataclasses.dataclass\nclass Script:\n    path: str\n    stage: Stage\n    state: State = State.UNKNOWN\n\n\nclass ScriptRunner(Plugin):\n    \"\"\"\n    Interface for running scripts.\n    \"\"\"\n\n    namespace = \"localstack.init.runner\"\n    suffixes = []\n\n    def run(self, path: str) -> None:\n        \"\"\"\n        Run the given script with the appropriate runtime.\n\n        :param path: the path to the script\n        \"\"\"\n        raise NotImplementedError\n\n    def should_run(self, script_file: str) -> bool:\n        \"\"\"\n        Checks whether the given file should be run with this script runner. In case multiple runners\n        evaluate this condition to true on the same file (ideally this doesn't happen), the first one\n        loaded will be used, which is potentially indeterministic.\n\n        :param script_file: the script file to run\n        :return: True if this runner should be used, False otherwise\n        \"\"\"\n        for suffix in self.suffixes:\n            if script_file.endswith(suffix):\n                return True\n        return False\n\n\nclass ShellScriptRunner(ScriptRunner):\n    \"\"\"\n    Runner that interprets scripts as shell scripts and calls them directly.\n    \"\"\"\n\n    name = \"sh\"\n    suffixes = [\".sh\"]\n\n    def run(self, path: str) -> None:\n        exit_code = subprocess.call(args=[], executable=path)\n        if exit_code != 0:\n            raise OSError(\"Script %s returned a non-zero exit code %s\" % (path, exit_code))\n\n\nclass PythonScriptRunner(ScriptRunner):\n    \"\"\"\n    Runner that uses ``exec`` to run a python script.\n    \"\"\"\n\n    name = \"py\"\n    suffixes = [\".py\"]\n\n    def run(self, path: str) -> None:\n        with open(path, \"rb\") as fd:\n            exec(fd.read(), {})\n\n\nclass InitScriptManager:\n    _stage_directories: Dict[Stage, str] = {\n        Stage.BOOT: \"boot.d\",\n        Stage.START: \"start.d\",\n        Stage.READY: \"ready.d\",\n        Stage.SHUTDOWN: \"shutdown.d\",\n    }\n\n    script_root: str\n    stage_completed: Dict[Stage, bool]\n\n    def __init__(self, script_root: str):\n        self.script_root = script_root\n        self.stage_completed = {stage: False for stage in Stage}\n        self.runner_manager: PluginManager[ScriptRunner] = PluginManager(ScriptRunner.namespace)\n\n    @cached_property\n    def scripts(self) -> Dict[Stage, List[Script]]:\n        return self._find_scripts()\n\n    def get_script_runner(self, script_file: str) -> Optional[ScriptRunner]:\n        runners = self.runner_manager.load_all()\n        for runner in runners:\n            if runner.should_run(script_file):\n                return runner\n        return None\n\n    def has_script_runner(self, script_file: str) -> bool:\n        return self.get_script_runner(script_file) is not None\n\n    def run_stage(self, stage: Stage) -> List[Script]:\n        \"\"\"\n        Runs all scripts in the given stage.\n\n        :param stage: the stage to run\n        :return: the scripts that were in the stage\n        \"\"\"\n        scripts = self.scripts.get(stage, [])\n\n        if self.stage_completed[stage]:\n            LOG.debug(\"Stage %s already completed, skipping\", stage)\n            return scripts\n\n        try:\n            for script in scripts:\n                LOG.debug(\"Running %s script %s\", script.stage, script.path)\n\n                # Deprecated: To be removed in v4.0 major release.\n                # Explicit AWS credentials and region will need to be set in the script.\n                env_original = os.environ.copy()\n                os.environ[\"AWS_ACCESS_KEY_ID\"] = constants.DEFAULT_AWS_ACCOUNT_ID\n                os.environ[\"AWS_SECRET_ACCESS_KEY\"] = constants.INTERNAL_AWS_SECRET_ACCESS_KEY\n                os.environ[\"AWS_REGION\"] = constants.AWS_REGION_US_EAST_1\n\n                try:\n                    script.state = State.RUNNING\n                    runner = self.get_script_runner(script.path)\n                    runner.run(script.path)\n                except Exception as e:\n                    script.state = State.ERROR\n                    if LOG.isEnabledFor(logging.DEBUG):\n                        LOG.exception(\"Error while running script %s\", script)\n                    else:\n                        LOG.error(\"Error while running script %s: %s\", script, e)\n                else:\n                    script.state = State.SUCCESSFUL\n                finally:\n                    # Restore original state of Boto credentials.\n                    for env_var in (\"AWS_ACCESS_KEY_ID\", \"AWS_SECRET_ACCESS_KEY\", \"AWS_REGION\"):\n                        if env_var in env_original:\n                            os.environ[env_var] = env_original[env_var]\n                        else:\n                            os.environ.pop(env_var, None)\n\n        finally:\n            self.stage_completed[stage] = True\n\n        return scripts\n\n    def _find_scripts(self) -> Dict[Stage, List[Script]]:\n        scripts = {}\n\n        if self.script_root is None:\n            LOG.debug(\"Unable to discover init scripts as script_root is None\")\n            return {}\n\n        for stage in Stage:\n            scripts[stage] = []\n\n            stage_dir = self._stage_directories[stage]\n            if not stage_dir:\n                continue\n\n            stage_path = os.path.join(self.script_root, stage_dir)\n            if not os.path.isdir(stage_path):\n                continue\n\n            for root, dirs, files in os.walk(stage_path, topdown=True):\n                # from the docs: \"When topdown is true, the caller can modify the dirnames list in-place\"\n                dirs.sort()\n                files.sort()\n                for file in files:\n                    script_path = os.path.abspath(os.path.join(root, file))\n                    if not os.path.isfile(script_path):\n                        continue\n\n                    # only add the script if there's a runner for it\n                    if not self.has_script_runner(script_path):\n                        LOG.debug(\"No runner available for script %s\", script_path)\n                        continue\n\n                    scripts[stage].append(Script(path=script_path, stage=stage))\n        LOG.debug(\"Init scripts discovered: %s\", scripts)\n\n        return scripts\n\n\n# runtime integration\n\n\n@singleton_factory\ndef init_script_manager() -> InitScriptManager:\n    from localstack import config\n\n    return InitScriptManager(script_root=config.dirs.init)\n\n\n@hooks.on_infra_start()\ndef _run_init_scripts_on_start():\n    # this is a hack since we currently cannot know whether boot scripts have been executed or not\n    init_script_manager().stage_completed[Stage.BOOT] = True\n    _run_and_log(Stage.START)\n\n\n@hooks.on_infra_ready()\ndef _run_init_scripts_on_ready():\n    _run_and_log(Stage.READY)\n\n\n@hooks.on_infra_shutdown()\ndef _run_init_scripts_on_shutdown():\n    _run_and_log(Stage.SHUTDOWN)\n\n\ndef _run_and_log(stage: Stage):\n    from localstack.utils.analytics import log\n\n    then = time.time()\n    scripts = init_script_manager().run_stage(stage)\n    took = (time.time() - then) * 1000\n\n    if scripts:\n        log.event(\"run_init\", {\"stage\": stage.name, \"scripts\": len(scripts), \"duration\": took})\n\n\ndef main():\n    \"\"\"\n    Run the init scripts for a particular stage. For example, to run all boot scripts run::\n\n        python -m localstack.runtime.init BOOT\n\n    The __main__ entrypoint is currently mainly used for the docker-entrypoint.sh. Other stages\n    are executed from runtime hooks.\n    \"\"\"\n    import sys\n\n    stage = Stage[sys.argv[1]]\n    init_script_manager().run_stage(stage)\n\n\nif __name__ == \"__main__\":\n    main()\n", "file_name": "974666.py", "cwe": ["CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"]}
{"source": "import glob\nimport logging\nimport os\nimport re\nimport shutil\nimport textwrap\nimport threading\nfrom typing import List\n\nimport semver\n\nfrom localstack import config\nfrom localstack.constants import (\n    ELASTICSEARCH_DEFAULT_VERSION,\n    ELASTICSEARCH_DELETE_MODULES,\n    ELASTICSEARCH_PLUGIN_LIST,\n    OPENSEARCH_DEFAULT_VERSION,\n    OPENSEARCH_PLUGIN_LIST,\n)\nfrom localstack.packages import InstallTarget, Package, PackageInstaller\nfrom localstack.services.opensearch import versions\nfrom localstack.utils.archives import download_and_extract_with_retry\nfrom localstack.utils.files import chmod_r, load_file, mkdir, rm_rf, save_file\nfrom localstack.utils.run import run\nfrom localstack.utils.ssl import create_ssl_cert, install_predefined_cert_if_available\nfrom localstack.utils.sync import SynchronizedDefaultDict, retry\n\nLOG = logging.getLogger(__name__)\n\n\n_OPENSEARCH_INSTALL_LOCKS = SynchronizedDefaultDict(threading.RLock)\n\n\nclass OpensearchPackage(Package):\n    def __init__(self, default_version: str = OPENSEARCH_DEFAULT_VERSION):\n        super().__init__(name=\"OpenSearch\", default_version=default_version)\n\n    def _get_installer(self, version: str) -> PackageInstaller:\n        if version in versions._prefixed_elasticsearch_install_versions:\n            return ElasticsearchPackageInstaller(version)\n        else:\n            return OpensearchPackageInstaller(version)\n\n    def get_versions(self) -> List[str]:\n        return list(versions.install_versions.keys())\n\n\nclass OpensearchPackageInstaller(PackageInstaller):\n    def __init__(self, version: str):\n        super().__init__(\"opensearch\", version)\n\n    def _install(self, target: InstallTarget):\n        # locally import to avoid having a dependency on ASF when starting the CLI\n        from localstack.aws.api.opensearch import EngineType\n        from localstack.services.opensearch import versions\n\n        version = self._get_opensearch_install_version()\n        install_dir = self._get_install_dir(target)\n        with _OPENSEARCH_INSTALL_LOCKS[version]:\n            if not os.path.exists(install_dir):\n                opensearch_url = versions.get_download_url(version, EngineType.OpenSearch)\n                install_dir_parent = os.path.dirname(install_dir)\n                mkdir(install_dir_parent)\n                # download and extract archive\n                tmp_archive = os.path.join(\n                    config.dirs.cache, f\"localstack.{os.path.basename(opensearch_url)}\"\n                )\n                print(f\"DEBUG: installing opensearch to path {install_dir_parent}\")\n                download_and_extract_with_retry(opensearch_url, tmp_archive, install_dir_parent)\n                opensearch_dir = glob.glob(os.path.join(install_dir_parent, \"opensearch*\"))\n                if not opensearch_dir:\n                    raise Exception(f\"Unable to find OpenSearch folder in {install_dir_parent}\")\n                shutil.move(opensearch_dir[0], install_dir)\n\n                for dir_name in (\"data\", \"logs\", \"modules\", \"plugins\", \"config/scripts\"):\n                    dir_path = os.path.join(install_dir, dir_name)\n                    mkdir(dir_path)\n                    chmod_r(dir_path, 0o777)\n\n                parsed_version = semver.VersionInfo.parse(version)\n\n                # setup security based on the version\n                self._setup_security(install_dir, parsed_version)\n\n                # install other default plugins for opensearch 1.1+\n                # https://forum.opensearch.org/t/ingest-attachment-cannot-be-installed/6494/12\n                if parsed_version >= \"1.1.0\":\n                    for plugin in OPENSEARCH_PLUGIN_LIST:\n                        plugin_binary = os.path.join(install_dir, \"bin\", \"opensearch-plugin\")\n                        plugin_dir = os.path.join(install_dir, \"plugins\", plugin)\n                        if not os.path.exists(plugin_dir):\n                            LOG.info(\"Installing OpenSearch plugin %s\", plugin)\n\n                            def try_install():\n                                output = run([plugin_binary, \"install\", \"-b\", plugin])\n                                LOG.debug(\"Plugin installation output: %s\", output)\n\n                            # We're occasionally seeing javax.net.ssl.SSLHandshakeException -> add download retries\n                            download_attempts = 3\n                            try:\n                                retry(try_install, retries=download_attempts - 1, sleep=2)\n                            except Exception:\n                                LOG.warning(\n                                    \"Unable to download OpenSearch plugin '%s' after %s attempts\",\n                                    plugin,\n                                    download_attempts,\n                                )\n                                if not os.environ.get(\"IGNORE_OS_DOWNLOAD_ERRORS\"):\n                                    raise\n\n    def _setup_security(self, install_dir: str, parsed_version: semver.VersionInfo):\n        \"\"\"\n        Prepares the usage of the SecurityPlugin for the different versions of OpenSearch.\n        :param install_dir: root installation directory for OpenSearch which should be configured\n        :param parsed_version: parsed semantic version of the OpenSearch installation which should be configured\n        \"\"\"\n        # create & copy SSL certs to opensearch config dir\n        install_predefined_cert_if_available()\n        config_path = os.path.join(install_dir, \"config\")\n        _, cert_file_name, key_file_name = create_ssl_cert()\n        shutil.copyfile(cert_file_name, os.path.join(config_path, \"cert.crt\"))\n        shutil.copyfile(key_file_name, os.path.join(config_path, \"cert.key\"))\n\n        # configure the default roles, roles_mappings, and internal_users\n        if parsed_version >= \"2.0.0\":\n            # with version 2 of opensearch and the security plugin, the config moved to the root config folder\n            security_config_folder = os.path.join(install_dir, \"config\", \"opensearch-security\")\n        else:\n            security_config_folder = os.path.join(\n                install_dir, \"plugins\", \"opensearch-security\", \"securityconfig\"\n            )\n\n        # no non-default roles (not even the demo roles) should be set up\n        roles_path = os.path.join(security_config_folder, \"roles.yml\")\n        save_file(\n            file=roles_path,\n            permissions=0o666,\n            content=textwrap.dedent(\n                \"\"\"\\\n                _meta:\n                  type: \"roles\"\n                  config_version: 2\n                \"\"\"\n            ),\n        )\n\n        # create the internal user which allows localstack to manage the running instance\n        internal_users_path = os.path.join(security_config_folder, \"internal_users.yml\")\n        save_file(\n            file=internal_users_path,\n            permissions=0o666,\n            content=textwrap.dedent(\n                \"\"\"\\\n                _meta:\n                  type: \"internalusers\"\n                  config_version: 2\n\n                # Define your internal users here\n                localstack-internal:\n                  hash: \"$2y$12$ZvpKLI2nsdGj1ResAmlLne7ki5o45XpBppyg9nXF2RLNfmwjbFY22\"\n                  reserved: true\n                  hidden: true\n                  backend_roles: []\n                  attributes: {}\n                  opendistro_security_roles: []\n                  static: false\n                \"\"\"\n            ),\n        )\n\n        # define the necessary roles mappings for the internal user\n        roles_mapping_path = os.path.join(security_config_folder, \"roles_mapping.yml\")\n        save_file(\n            file=roles_mapping_path,\n            permissions=0o666,\n            content=textwrap.dedent(\n                \"\"\"\\\n                _meta:\n                  type: \"rolesmapping\"\n                  config_version: 2\n\n                security_manager:\n                  hosts: []\n                  users:\n                    - localstack-internal\n                  reserved: false\n                  hidden: false\n                  backend_roles: []\n                  and_backend_roles: []\n\n                all_access:\n                  hosts: []\n                  users:\n                    - localstack-internal\n                  reserved: false\n                  hidden: false\n                  backend_roles: []\n                  and_backend_roles: []\n                \"\"\"\n            ),\n        )\n\n    def _get_install_marker_path(self, install_dir: str) -> str:\n        return os.path.join(install_dir, \"bin\", \"opensearch\")\n\n    def _get_opensearch_install_version(self) -> str:\n        from localstack.services.opensearch import versions\n\n        if config.SKIP_INFRA_DOWNLOADS:\n            self.version = OPENSEARCH_DEFAULT_VERSION\n\n        return versions.get_install_version(self.version)\n\n\nclass ElasticsearchPackageInstaller(PackageInstaller):\n    def __init__(self, version: str):\n        super().__init__(\"elasticsearch\", version)\n\n    def _install(self, target: InstallTarget):\n        # locally import to avoid having a dependency on ASF when starting the CLI\n        from localstack.aws.api.opensearch import EngineType\n        from localstack.services.opensearch import versions\n\n        version = self.get_elasticsearch_install_version()\n        install_dir = self._get_install_dir(target)\n        installed_executable = os.path.join(install_dir, \"bin\", \"elasticsearch\")\n        if not os.path.exists(installed_executable):\n            es_url = versions.get_download_url(version, EngineType.Elasticsearch)\n            install_dir_parent = os.path.dirname(install_dir)\n            mkdir(install_dir_parent)\n            # download and extract archive\n            tmp_archive = os.path.join(config.dirs.cache, f\"localstack.{os.path.basename(es_url)}\")\n            download_and_extract_with_retry(es_url, tmp_archive, install_dir_parent)\n            elasticsearch_dir = glob.glob(os.path.join(install_dir_parent, \"elasticsearch*\"))\n            if not elasticsearch_dir:\n                raise Exception(f\"Unable to find Elasticsearch folder in {install_dir_parent}\")\n            shutil.move(elasticsearch_dir[0], install_dir)\n\n            for dir_name in (\"data\", \"logs\", \"modules\", \"plugins\", \"config/scripts\"):\n                dir_path = os.path.join(install_dir, dir_name)\n                mkdir(dir_path)\n                chmod_r(dir_path, 0o777)\n\n            # install default plugins\n            for plugin in ELASTICSEARCH_PLUGIN_LIST:\n                plugin_binary = os.path.join(install_dir, \"bin\", \"elasticsearch-plugin\")\n                plugin_dir = os.path.join(install_dir, \"plugins\", plugin)\n                if not os.path.exists(plugin_dir):\n                    LOG.info(\"Installing Elasticsearch plugin %s\", plugin)\n\n                    def try_install():\n                        output = run([plugin_binary, \"install\", \"-b\", plugin])\n                        LOG.debug(\"Plugin installation output: %s\", output)\n\n                    # We're occasionally seeing javax.net.ssl.SSLHandshakeException -> add download retries\n                    download_attempts = 3\n                    try:\n                        retry(try_install, retries=download_attempts - 1, sleep=2)\n                    except Exception:\n                        LOG.warning(\n                            \"Unable to download Elasticsearch plugin '%s' after %s attempts\",\n                            plugin,\n                            download_attempts,\n                        )\n                        if not os.environ.get(\"IGNORE_ES_DOWNLOAD_ERRORS\"):\n                            raise\n\n        # delete some plugins to free up space\n        for plugin in ELASTICSEARCH_DELETE_MODULES:\n            module_dir = os.path.join(install_dir, \"modules\", plugin)\n            rm_rf(module_dir)\n\n        # disable x-pack-ml plugin (not working on Alpine)\n        xpack_dir = os.path.join(install_dir, \"modules\", \"x-pack-ml\", \"platform\")\n        rm_rf(xpack_dir)\n\n        # patch JVM options file - replace hardcoded heap size settings\n        jvm_options_file = os.path.join(install_dir, \"config\", \"jvm.options\")\n        if os.path.exists(jvm_options_file):\n            jvm_options = load_file(jvm_options_file)\n            jvm_options_replaced = re.sub(\n                r\"(^-Xm[sx][a-zA-Z0-9.]+$)\", r\"# \\1\", jvm_options, flags=re.MULTILINE\n            )\n            if jvm_options != jvm_options_replaced:\n                save_file(jvm_options_file, jvm_options_replaced)\n\n        # patch JVM options file - replace hardcoded heap size settings\n        jvm_options_file = os.path.join(install_dir, \"config\", \"jvm.options\")\n        if os.path.exists(jvm_options_file):\n            jvm_options = load_file(jvm_options_file)\n            jvm_options_replaced = re.sub(\n                r\"(^-Xm[sx][a-zA-Z0-9.]+$)\", r\"# \\1\", jvm_options, flags=re.MULTILINE\n            )\n            if jvm_options != jvm_options_replaced:\n                save_file(jvm_options_file, jvm_options_replaced)\n\n    def _get_install_marker_path(self, install_dir: str) -> str:\n        return os.path.join(install_dir, \"bin\", \"elasticsearch\")\n\n    def get_elasticsearch_install_version(self) -> str:\n        from localstack.services.opensearch import versions\n\n        if config.SKIP_INFRA_DOWNLOADS:\n            return ELASTICSEARCH_DEFAULT_VERSION\n\n        return versions.get_install_version(self.version)\n\n\nopensearch_package = OpensearchPackage(default_version=OPENSEARCH_DEFAULT_VERSION)\nelasticsearch_package = OpensearchPackage(default_version=ELASTICSEARCH_DEFAULT_VERSION)\n", "file_name": "215937.py", "cwe": ["CWE-798: Use of Hard-coded Credentials"]}
{"source": "import io\nimport tarfile\nimport zipfile\nfrom subprocess import Popen\nfrom typing import IO, Optional\n\ntry:\n    from typing import Literal\nexcept ImportError:\n    from typing_extensions import Literal\n\nimport glob\nimport logging\nimport os\nimport re\nimport tempfile\nimport time\nfrom typing import Union\n\nfrom localstack.constants import MAVEN_REPO_URL\nfrom localstack.utils.files import load_file, mkdir, new_tmp_file, rm_rf, save_file\nfrom localstack.utils.http import download\nfrom localstack.utils.run import run\n\nfrom .run import is_command_available\nfrom .strings import truncate\n\nLOG = logging.getLogger(__name__)\n\n\nStrPath = Union[str, os.PathLike]\n\n\ndef is_zip_file(content):\n    stream = io.BytesIO(content)\n    return zipfile.is_zipfile(stream)\n\n\ndef get_unzipped_size(zip_file: Union[str, IO[bytes]]):\n    \"\"\"Returns the size of the unzipped file.\"\"\"\n    with zipfile.ZipFile(zip_file, \"r\") as zip_ref:\n        return sum(f.file_size for f in zip_ref.infolist())\n\n\ndef unzip(path: str, target_dir: str, overwrite: bool = True) -> Optional[Union[str, Popen]]:\n    from localstack.utils.platform import is_debian\n\n    use_native_cmd = is_debian() or is_command_available(\"unzip\")\n    if use_native_cmd:\n        # Running the native command can be an order of magnitude faster in the container. Also, `unzip`\n        #  is capable of extracting zip files with incorrect CRC codes (sometimes happens, e.g., with some\n        #  Node.js/Serverless versions), which can fail with Python's `zipfile` (extracting empty files).\n        flags = [\"-o\"] if overwrite else []\n        flags += [\"-q\"]\n        try:\n            cmd = [\"unzip\"] + flags + [path]\n            return run(cmd, cwd=target_dir, print_error=False)\n        except Exception as e:\n            error_str = truncate(str(e), max_length=200)\n            LOG.info(\n                'Unable to use native \"unzip\" command (using fallback mechanism): %s', error_str\n            )\n\n    try:\n        zip_ref = zipfile.ZipFile(path, \"r\")\n    except Exception as e:\n        LOG.warning(\"Unable to open zip file: %s: %s\", path, e)\n        raise e\n\n    def _unzip_file_entry(zip_ref, file_entry, target_dir):\n        \"\"\"Extracts a Zipfile entry and preserves permissions\"\"\"\n        out_path = os.path.join(target_dir, file_entry.filename)\n        if use_native_cmd and os.path.exists(out_path) and os.path.getsize(out_path) > 0:\n            # this can happen under certain circumstances if the native \"unzip\" command\n            # fails with a non-zero exit code, yet manages to extract parts of the zip file\n            return\n        zip_ref.extract(file_entry.filename, path=target_dir)\n        perm = file_entry.external_attr >> 16\n        # Make sure to preserve file permissions in the zip file\n        # https://www.burgundywall.com/post/preserving-file-perms-with-python-zipfile-module\n        os.chmod(out_path, perm or 0o777)\n\n    try:\n        for file_entry in zip_ref.infolist():\n            _unzip_file_entry(zip_ref, file_entry, target_dir)\n    finally:\n        zip_ref.close()\n\n\ndef untar(path: str, target_dir: str):\n    mode = \"r:gz\" if path.endswith(\"gz\") else \"r\"\n    with tarfile.open(path, mode) as tar:\n        tar.extractall(path=target_dir)\n\n\ndef create_zip_file_cli(source_path: StrPath, base_dir: StrPath, zip_file: StrPath):\n    \"\"\"\n    Creates a zip archive by using the native zip command. The native command can be an order of magnitude faster in CI\n    \"\"\"\n    source = \".\" if source_path == base_dir else os.path.basename(source_path)\n    run([\"zip\", \"-r\", zip_file, source], cwd=base_dir)\n\n\ndef create_zip_file_python(\n    base_dir: StrPath,\n    zip_file: StrPath,\n    mode: Literal[\"r\", \"w\", \"x\", \"a\"] = \"w\",\n    content_root: Optional[str] = None,\n):\n    with zipfile.ZipFile(zip_file, mode) as zip_file:\n        for root, dirs, files in os.walk(base_dir):\n            for name in files:\n                full_name = os.path.join(root, name)\n                relative = os.path.relpath(root, start=base_dir)\n                if content_root:\n                    dest = os.path.join(content_root, relative, name)\n                else:\n                    dest = os.path.join(relative, name)\n                zip_file.write(full_name, dest)\n\n\ndef add_file_to_jar(class_file, class_url, target_jar, base_dir=None):\n    base_dir = base_dir or os.path.dirname(target_jar)\n    patch_class_file = os.path.join(base_dir, class_file)\n    if not os.path.exists(patch_class_file):\n        download(class_url, patch_class_file)\n        run([\"zip\", target_jar, class_file], cwd=base_dir)\n\n\ndef update_jar_manifest(\n    jar_file_name: str, parent_dir: str, search: Union[str, re.Pattern], replace: str\n):\n    manifest_file_path = \"META-INF/MANIFEST.MF\"\n    jar_path = os.path.join(parent_dir, jar_file_name)\n    with tempfile.TemporaryDirectory() as tmp_dir:\n        tmp_manifest_file = os.path.join(tmp_dir, manifest_file_path)\n        run([\"unzip\", \"-o\", jar_path, manifest_file_path], cwd=tmp_dir)\n        manifest = load_file(tmp_manifest_file)\n\n    # return if the search pattern does not match (for idempotence, to avoid file permission issues further below)\n    if isinstance(search, re.Pattern):\n        if not search.search(manifest):\n            return\n        manifest = search.sub(replace, manifest, 1)\n    else:\n        if search not in manifest:\n            return\n        manifest = manifest.replace(search, replace, 1)\n\n    manifest_file = os.path.join(parent_dir, manifest_file_path)\n    save_file(manifest_file, manifest)\n    run([\"zip\", jar_file_name, manifest_file_path], cwd=parent_dir)\n\n\ndef upgrade_jar_file(base_dir: str, file_glob: str, maven_asset: str):\n    \"\"\"\n    Upgrade the matching Java JAR file in a local directory with the given Maven asset\n    :param base_dir: base directory to search the JAR file to replace in\n    :param file_glob: glob pattern for the JAR file to replace\n    :param maven_asset: name of Maven asset to download, in the form \"<qualified_name>:<version>\"\n    \"\"\"\n\n    local_path = os.path.join(base_dir, file_glob)\n    parent_dir = os.path.dirname(local_path)\n    maven_asset = maven_asset.replace(\":\", \"/\")\n    parts = maven_asset.split(\"/\")\n    maven_asset_url = f\"{MAVEN_REPO_URL}/{maven_asset}/{parts[-2]}-{parts[-1]}.jar\"\n    target_file = os.path.join(parent_dir, os.path.basename(maven_asset_url))\n    if os.path.exists(target_file):\n        # avoid re-downloading the newer JAR version if it already exists locally\n        return\n    matches = glob.glob(local_path)\n    if not matches:\n        return\n    for match in matches:\n        os.remove(match)\n    download(maven_asset_url, target_file)\n\n\ndef download_and_extract(archive_url, target_dir, retries=0, sleep=3, tmp_archive=None):\n    mkdir(target_dir)\n\n    _, ext = os.path.splitext(tmp_archive or archive_url)\n    tmp_archive = tmp_archive or new_tmp_file()\n    if not os.path.exists(tmp_archive) or os.path.getsize(tmp_archive) <= 0:\n        # create temporary placeholder file, to avoid duplicate parallel downloads\n        save_file(tmp_archive, \"\")\n\n        for i in range(retries + 1):\n            try:\n                download(archive_url, tmp_archive)\n                break\n            except Exception as e:\n                LOG.warning(\n                    \"Attempt %d. Failed to download archive from %s: %s\",\n                    i + 1,\n                    archive_url,\n                    e,\n                )\n                # only sleep between retries, not after the last one\n                if i < retries:\n                    time.sleep(sleep)\n\n    # if the temporary file we created above hasn't been replaced, we assume failure\n    if os.path.getsize(tmp_archive) <= 0:\n        raise Exception(\"Failed to download archive from %s: . Retries exhausted\", archive_url)\n\n    if ext == \".zip\":\n        unzip(tmp_archive, target_dir)\n    elif ext in (\n        \".bz2\",\n        \".gz\",\n        \".tgz\",\n        \".xz\",\n    ):\n        untar(tmp_archive, target_dir)\n    else:\n        raise Exception(f\"Unsupported archive format: {ext}\")\n\n\ndef download_and_extract_with_retry(archive_url, tmp_archive, target_dir):\n    try:\n        download_and_extract(archive_url, target_dir, tmp_archive=tmp_archive)\n    except Exception as e:\n        # try deleting and re-downloading the zip file\n        LOG.info(\"Unable to extract file, re-downloading ZIP archive %s: %s\", tmp_archive, e)\n        rm_rf(tmp_archive)\n        download_and_extract(archive_url, target_dir, tmp_archive=tmp_archive)\n", "file_name": "124108.py", "cwe": ["CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"]}
{"source": "\"\"\"Scrapy Shell\n\nSee documentation in docs/topics/shell.rst\n\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport signal\nfrom typing import Any, Callable, Dict, Optional, Tuple, Union\n\nfrom itemadapter import is_item\nfrom twisted.internet import defer, threads\nfrom twisted.python import threadable\nfrom w3lib.url import any_to_uri\n\nfrom scrapy.crawler import Crawler\nfrom scrapy.exceptions import IgnoreRequest\nfrom scrapy.http import Request, Response\nfrom scrapy.settings import Settings\nfrom scrapy.spiders import Spider\nfrom scrapy.utils.conf import get_config\nfrom scrapy.utils.console import DEFAULT_PYTHON_SHELLS, start_python_console\nfrom scrapy.utils.datatypes import SequenceExclude\nfrom scrapy.utils.misc import load_object\nfrom scrapy.utils.reactor import is_asyncio_reactor_installed, set_asyncio_event_loop\nfrom scrapy.utils.response import open_in_browser\n\n\nclass Shell:\n    relevant_classes: Tuple[type, ...] = (Crawler, Spider, Request, Response, Settings)\n\n    def __init__(\n        self,\n        crawler: Crawler,\n        update_vars: Optional[Callable[[Dict[str, Any]], None]] = None,\n        code: Optional[str] = None,\n    ):\n        self.crawler: Crawler = crawler\n        self.update_vars: Callable[[Dict[str, Any]], None] = update_vars or (\n            lambda x: None\n        )\n        self.item_class: type = load_object(crawler.settings[\"DEFAULT_ITEM_CLASS\"])\n        self.spider: Optional[Spider] = None\n        self.inthread: bool = not threadable.isInIOThread()\n        self.code: Optional[str] = code\n        self.vars: Dict[str, Any] = {}\n\n    def start(\n        self,\n        url: Optional[str] = None,\n        request: Optional[Request] = None,\n        response: Optional[Response] = None,\n        spider: Optional[Spider] = None,\n        redirect: bool = True,\n    ) -> None:\n        # disable accidental Ctrl-C key press from shutting down the engine\n        signal.signal(signal.SIGINT, signal.SIG_IGN)\n        if url:\n            self.fetch(url, spider, redirect=redirect)\n        elif request:\n            self.fetch(request, spider)\n        elif response:\n            request = response.request\n            self.populate_vars(response, request, spider)\n        else:\n            self.populate_vars()\n        if self.code:\n            print(eval(self.code, globals(), self.vars))  # nosec\n        else:\n            \"\"\"\n            Detect interactive shell setting in scrapy.cfg\n            e.g.: ~/.config/scrapy.cfg or ~/.scrapy.cfg\n            [settings]\n            # shell can be one of ipython, bpython or python;\n            # to be used as the interactive python console, if available.\n            # (default is ipython, fallbacks in the order listed above)\n            shell = python\n            \"\"\"\n            cfg = get_config()\n            section, option = \"settings\", \"shell\"\n            env = os.environ.get(\"SCRAPY_PYTHON_SHELL\")\n            shells = []\n            if env:\n                shells += env.strip().lower().split(\",\")\n            elif cfg.has_option(section, option):\n                shells += [cfg.get(section, option).strip().lower()]\n            else:  # try all by default\n                shells += DEFAULT_PYTHON_SHELLS.keys()\n            # always add standard shell as fallback\n            shells += [\"python\"]\n            start_python_console(\n                self.vars, shells=shells, banner=self.vars.pop(\"banner\", \"\")\n            )\n\n    def _schedule(\n        self, request: Request, spider: Optional[Spider]\n    ) -> defer.Deferred[Any]:\n        if is_asyncio_reactor_installed():\n            # set the asyncio event loop for the current thread\n            event_loop_path = self.crawler.settings[\"ASYNCIO_EVENT_LOOP\"]\n            set_asyncio_event_loop(event_loop_path)\n        spider = self._open_spider(request, spider)\n        d = _request_deferred(request)\n        d.addCallback(lambda x: (x, spider))\n        assert self.crawler.engine\n        self.crawler.engine.crawl(request)\n        return d\n\n    def _open_spider(self, request: Request, spider: Optional[Spider]) -> Spider:\n        if self.spider:\n            return self.spider\n\n        if spider is None:\n            spider = self.crawler.spider or self.crawler._create_spider()\n\n        self.crawler.spider = spider\n        assert self.crawler.engine\n        self.crawler.engine.open_spider(spider, close_if_idle=False)\n        self.spider = spider\n        return spider\n\n    def fetch(\n        self,\n        request_or_url: Union[Request, str],\n        spider: Optional[Spider] = None,\n        redirect: bool = True,\n        **kwargs: Any,\n    ) -> None:\n        from twisted.internet import reactor\n\n        if isinstance(request_or_url, Request):\n            request = request_or_url\n        else:\n            url = any_to_uri(request_or_url)\n            request = Request(url, dont_filter=True, **kwargs)\n            if redirect:\n                request.meta[\"handle_httpstatus_list\"] = SequenceExclude(\n                    range(300, 400)\n                )\n            else:\n                request.meta[\"handle_httpstatus_all\"] = True\n        response = None\n        try:\n            response, spider = threads.blockingCallFromThread(\n                reactor, self._schedule, request, spider\n            )\n        except IgnoreRequest:\n            pass\n        self.populate_vars(response, request, spider)\n\n    def populate_vars(\n        self,\n        response: Optional[Response] = None,\n        request: Optional[Request] = None,\n        spider: Optional[Spider] = None,\n    ) -> None:\n        import scrapy\n\n        self.vars[\"scrapy\"] = scrapy\n        self.vars[\"crawler\"] = self.crawler\n        self.vars[\"item\"] = self.item_class()\n        self.vars[\"settings\"] = self.crawler.settings\n        self.vars[\"spider\"] = spider\n        self.vars[\"request\"] = request\n        self.vars[\"response\"] = response\n        if self.inthread:\n            self.vars[\"fetch\"] = self.fetch\n        self.vars[\"view\"] = open_in_browser\n        self.vars[\"shelp\"] = self.print_help\n        self.update_vars(self.vars)\n        if not self.code:\n            self.vars[\"banner\"] = self.get_help()\n\n    def print_help(self) -> None:\n        print(self.get_help())\n\n    def get_help(self) -> str:\n        b = []\n        b.append(\"Available Scrapy objects:\")\n        b.append(\n            \"  scrapy     scrapy module (contains scrapy.Request, scrapy.Selector, etc)\"\n        )\n        for k, v in sorted(self.vars.items()):\n            if self._is_relevant(v):\n                b.append(f\"  {k:<10} {v}\")\n        b.append(\"Useful shortcuts:\")\n        if self.inthread:\n            b.append(\n                \"  fetch(url[, redirect=True]) \"\n                \"Fetch URL and update local objects (by default, redirects are followed)\"\n            )\n            b.append(\n                \"  fetch(req)                  \"\n                \"Fetch a scrapy.Request and update local objects \"\n            )\n        b.append(\"  shelp()           Shell help (print this help)\")\n        b.append(\"  view(response)    View response in a browser\")\n\n        return \"\\n\".join(f\"[s] {line}\" for line in b)\n\n    def _is_relevant(self, value: Any) -> bool:\n        return isinstance(value, self.relevant_classes) or is_item(value)\n\n\ndef inspect_response(response: Response, spider: Spider) -> None:\n    \"\"\"Open a shell to inspect the given response\"\"\"\n    # Shell.start removes the SIGINT handler, so save it and re-add it after\n    # the shell has closed\n    sigint_handler = signal.getsignal(signal.SIGINT)\n    Shell(spider.crawler).start(response=response, spider=spider)\n    signal.signal(signal.SIGINT, sigint_handler)\n\n\ndef _request_deferred(request: Request) -> defer.Deferred[Any]:\n    \"\"\"Wrap a request inside a Deferred.\n\n    This function is harmful, do not use it until you know what you are doing.\n\n    This returns a Deferred whose first pair of callbacks are the request\n    callback and errback. The Deferred also triggers when the request\n    callback/errback is executed (i.e. when the request is downloaded)\n\n    WARNING: Do not call request.replace() until after the deferred is called.\n    \"\"\"\n    request_callback = request.callback\n    request_errback = request.errback\n\n    def _restore_callbacks(result: Any) -> Any:\n        request.callback = request_callback\n        request.errback = request_errback\n        return result\n\n    d: defer.Deferred[Any] = defer.Deferred()\n    d.addBoth(_restore_callbacks)\n    if request.callback:\n        d.addCallback(request.callback)\n    if request.errback:\n        d.addErrback(request.errback)\n\n    request.callback, request.errback = d.callback, d.errback\n    return d\n", "file_name": "671115.py", "cwe": ["CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"]}
{"source": "\"\"\"\nScheduler queues\n\"\"\"\n\nfrom __future__ import annotations\n\nimport marshal\nimport pickle  # nosec\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, Callable, Optional, Type, Union\n\nfrom queuelib import queue\n\nfrom scrapy.utils.request import request_from_dict\n\nif TYPE_CHECKING:\n    from os import PathLike\n\n    # typing.Self requires Python 3.11\n    from typing_extensions import Self\n\n    from scrapy import Request\n    from scrapy.crawler import Crawler\n\n\ndef _with_mkdir(queue_class: Type[queue.BaseQueue]) -> Type[queue.BaseQueue]:\n    class DirectoriesCreated(queue_class):  # type: ignore[valid-type,misc]\n        def __init__(self, path: Union[str, PathLike], *args: Any, **kwargs: Any):\n            dirname = Path(path).parent\n            if not dirname.exists():\n                dirname.mkdir(parents=True, exist_ok=True)\n            super().__init__(path, *args, **kwargs)\n\n    return DirectoriesCreated\n\n\ndef _serializable_queue(\n    queue_class: Type[queue.BaseQueue],\n    serialize: Callable[[Any], bytes],\n    deserialize: Callable[[bytes], Any],\n) -> Type[queue.BaseQueue]:\n    class SerializableQueue(queue_class):  # type: ignore[valid-type,misc]\n        def push(self, obj: Any) -> None:\n            s = serialize(obj)\n            super().push(s)\n\n        def pop(self) -> Optional[Any]:\n            s = super().pop()\n            if s:\n                return deserialize(s)\n            return None\n\n        def peek(self) -> Optional[Any]:\n            \"\"\"Returns the next object to be returned by :meth:`pop`,\n            but without removing it from the queue.\n\n            Raises :exc:`NotImplementedError` if the underlying queue class does\n            not implement a ``peek`` method, which is optional for queues.\n            \"\"\"\n            try:\n                s = super().peek()\n            except AttributeError as ex:\n                raise NotImplementedError(\n                    \"The underlying queue class does not implement 'peek'\"\n                ) from ex\n            if s:\n                return deserialize(s)\n            return None\n\n    return SerializableQueue\n\n\ndef _scrapy_serialization_queue(\n    queue_class: Type[queue.BaseQueue],\n) -> Type[queue.BaseQueue]:\n    class ScrapyRequestQueue(queue_class):  # type: ignore[valid-type,misc]\n        def __init__(self, crawler: Crawler, key: str):\n            self.spider = crawler.spider\n            super().__init__(key)\n\n        @classmethod\n        def from_crawler(\n            cls, crawler: Crawler, key: str, *args: Any, **kwargs: Any\n        ) -> Self:\n            return cls(crawler, key)\n\n        def push(self, request: Request) -> None:\n            request_dict = request.to_dict(spider=self.spider)\n            super().push(request_dict)\n\n        def pop(self) -> Optional[Request]:\n            request = super().pop()\n            if not request:\n                return None\n            return request_from_dict(request, spider=self.spider)\n\n        def peek(self) -> Optional[Request]:\n            \"\"\"Returns the next object to be returned by :meth:`pop`,\n            but without removing it from the queue.\n\n            Raises :exc:`NotImplementedError` if the underlying queue class does\n            not implement a ``peek`` method, which is optional for queues.\n            \"\"\"\n            request = super().peek()\n            if not request:\n                return None\n            return request_from_dict(request, spider=self.spider)\n\n    return ScrapyRequestQueue\n\n\ndef _scrapy_non_serialization_queue(\n    queue_class: Type[queue.BaseQueue],\n) -> Type[queue.BaseQueue]:\n    class ScrapyRequestQueue(queue_class):  # type: ignore[valid-type,misc]\n        @classmethod\n        def from_crawler(cls, crawler: Crawler, *args: Any, **kwargs: Any) -> Self:\n            return cls()\n\n        def peek(self) -> Optional[Any]:\n            \"\"\"Returns the next object to be returned by :meth:`pop`,\n            but without removing it from the queue.\n\n            Raises :exc:`NotImplementedError` if the underlying queue class does\n            not implement a ``peek`` method, which is optional for queues.\n            \"\"\"\n            try:\n                s = super().peek()\n            except AttributeError as ex:\n                raise NotImplementedError(\n                    \"The underlying queue class does not implement 'peek'\"\n                ) from ex\n            return s\n\n    return ScrapyRequestQueue\n\n\ndef _pickle_serialize(obj: Any) -> bytes:\n    try:\n        return pickle.dumps(obj, protocol=4)\n    # Both pickle.PicklingError and AttributeError can be raised by pickle.dump(s)\n    # TypeError is raised from parsel.Selector\n    except (pickle.PicklingError, AttributeError, TypeError) as e:\n        raise ValueError(str(e)) from e\n\n\n# queue.*Queue aren't subclasses of queue.BaseQueue\n_PickleFifoSerializationDiskQueue = _serializable_queue(\n    _with_mkdir(queue.FifoDiskQueue), _pickle_serialize, pickle.loads  # type: ignore[arg-type]\n)\n_PickleLifoSerializationDiskQueue = _serializable_queue(\n    _with_mkdir(queue.LifoDiskQueue), _pickle_serialize, pickle.loads  # type: ignore[arg-type]\n)\n_MarshalFifoSerializationDiskQueue = _serializable_queue(\n    _with_mkdir(queue.FifoDiskQueue), marshal.dumps, marshal.loads  # type: ignore[arg-type]\n)\n_MarshalLifoSerializationDiskQueue = _serializable_queue(\n    _with_mkdir(queue.LifoDiskQueue), marshal.dumps, marshal.loads  # type: ignore[arg-type]\n)\n\n# public queue classes\nPickleFifoDiskQueue = _scrapy_serialization_queue(_PickleFifoSerializationDiskQueue)\nPickleLifoDiskQueue = _scrapy_serialization_queue(_PickleLifoSerializationDiskQueue)\nMarshalFifoDiskQueue = _scrapy_serialization_queue(_MarshalFifoSerializationDiskQueue)\nMarshalLifoDiskQueue = _scrapy_serialization_queue(_MarshalLifoSerializationDiskQueue)\nFifoMemoryQueue = _scrapy_non_serialization_queue(queue.FifoMemoryQueue)  # type: ignore[arg-type]\nLifoMemoryQueue = _scrapy_non_serialization_queue(queue.LifoMemoryQueue)  # type: ignore[arg-type]\n", "file_name": "452701.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "\"\"\"\nThis module provides some useful functions for working with\nscrapy.http.Request objects\n\"\"\"\n\nfrom __future__ import annotations\n\nimport hashlib\nimport json\nimport warnings\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Dict,\n    Iterable,\n    List,\n    Optional,\n    Protocol,\n    Tuple,\n    Type,\n    Union,\n)\nfrom urllib.parse import urlunparse\nfrom weakref import WeakKeyDictionary\n\nfrom w3lib.http import basic_auth_header\nfrom w3lib.url import canonicalize_url\n\nfrom scrapy import Request, Spider\nfrom scrapy.exceptions import ScrapyDeprecationWarning\nfrom scrapy.utils.httpobj import urlparse_cached\nfrom scrapy.utils.misc import load_object\nfrom scrapy.utils.python import to_bytes, to_unicode\n\nif TYPE_CHECKING:\n    # typing.Self requires Python 3.11\n    from typing_extensions import Self\n\n    from scrapy.crawler import Crawler\n\n\ndef _serialize_headers(headers: Iterable[bytes], request: Request) -> Iterable[bytes]:\n    for header in headers:\n        if header in request.headers:\n            yield header\n            yield from request.headers.getlist(header)\n\n\n_fingerprint_cache: WeakKeyDictionary[\n    Request, Dict[Tuple[Optional[Tuple[bytes, ...]], bool], bytes]\n]\n_fingerprint_cache = WeakKeyDictionary()\n\n\ndef fingerprint(\n    request: Request,\n    *,\n    include_headers: Optional[Iterable[Union[bytes, str]]] = None,\n    keep_fragments: bool = False,\n) -> bytes:\n    \"\"\"\n    Return the request fingerprint.\n\n    The request fingerprint is a hash that uniquely identifies the resource the\n    request points to. For example, take the following two urls:\n\n    http://www.example.com/query?id=111&cat=222\n    http://www.example.com/query?cat=222&id=111\n\n    Even though those are two different URLs both point to the same resource\n    and are equivalent (i.e. they should return the same response).\n\n    Another example are cookies used to store session ids. Suppose the\n    following page is only accessible to authenticated users:\n\n    http://www.example.com/members/offers.html\n\n    Lots of sites use a cookie to store the session id, which adds a random\n    component to the HTTP Request and thus should be ignored when calculating\n    the fingerprint.\n\n    For this reason, request headers are ignored by default when calculating\n    the fingerprint. If you want to include specific headers use the\n    include_headers argument, which is a list of Request headers to include.\n\n    Also, servers usually ignore fragments in urls when handling requests,\n    so they are also ignored by default when calculating the fingerprint.\n    If you want to include them, set the keep_fragments argument to True\n    (for instance when handling requests with a headless browser).\n    \"\"\"\n    processed_include_headers: Optional[Tuple[bytes, ...]] = None\n    if include_headers:\n        processed_include_headers = tuple(\n            to_bytes(h.lower()) for h in sorted(include_headers)\n        )\n    cache = _fingerprint_cache.setdefault(request, {})\n    cache_key = (processed_include_headers, keep_fragments)\n    if cache_key not in cache:\n        # To decode bytes reliably (JSON does not support bytes), regardless of\n        # character encoding, we use bytes.hex()\n        headers: Dict[str, List[str]] = {}\n        if processed_include_headers:\n            for header in processed_include_headers:\n                if header in request.headers:\n                    headers[header.hex()] = [\n                        header_value.hex()\n                        for header_value in request.headers.getlist(header)\n                    ]\n        fingerprint_data = {\n            \"method\": to_unicode(request.method),\n            \"url\": canonicalize_url(request.url, keep_fragments=keep_fragments),\n            \"body\": (request.body or b\"\").hex(),\n            \"headers\": headers,\n        }\n        fingerprint_json = json.dumps(fingerprint_data, sort_keys=True)\n        cache[cache_key] = hashlib.sha1(fingerprint_json.encode()).digest()  # nosec\n    return cache[cache_key]\n\n\nclass RequestFingerprinterProtocol(Protocol):\n    def fingerprint(self, request: Request) -> bytes: ...\n\n\nclass RequestFingerprinter:\n    \"\"\"Default fingerprinter.\n\n    It takes into account a canonical version\n    (:func:`w3lib.url.canonicalize_url`) of :attr:`request.url\n    <scrapy.http.Request.url>` and the values of :attr:`request.method\n    <scrapy.http.Request.method>` and :attr:`request.body\n    <scrapy.http.Request.body>`. It then generates an `SHA1\n    <https://en.wikipedia.org/wiki/SHA-1>`_ hash.\n\n    .. seealso:: :setting:`REQUEST_FINGERPRINTER_IMPLEMENTATION`.\n    \"\"\"\n\n    @classmethod\n    def from_crawler(cls, crawler: Crawler) -> Self:\n        return cls(crawler)\n\n    def __init__(self, crawler: Optional[Crawler] = None):\n        if crawler:\n            implementation = crawler.settings.get(\n                \"REQUEST_FINGERPRINTER_IMPLEMENTATION\"\n            )\n        else:\n            implementation = \"SENTINEL\"\n\n        if implementation != \"SENTINEL\":\n            message = (\n                \"'REQUEST_FINGERPRINTER_IMPLEMENTATION' is a deprecated setting.\\n\"\n                \"And it will be removed in future version of Scrapy.\"\n            )\n            warnings.warn(message, category=ScrapyDeprecationWarning, stacklevel=2)\n        self._fingerprint = fingerprint\n\n    def fingerprint(self, request: Request) -> bytes:\n        return self._fingerprint(request)\n\n\ndef request_authenticate(\n    request: Request,\n    username: str,\n    password: str,\n) -> None:\n    \"\"\"Authenticate the given request (in place) using the HTTP basic access\n    authentication mechanism (RFC 2617) and the given username and password\n    \"\"\"\n    request.headers[\"Authorization\"] = basic_auth_header(username, password)\n\n\ndef request_httprepr(request: Request) -> bytes:\n    \"\"\"Return the raw HTTP representation (as bytes) of the given request.\n    This is provided only for reference since it's not the actual stream of\n    bytes that will be send when performing the request (that's controlled\n    by Twisted).\n    \"\"\"\n    parsed = urlparse_cached(request)\n    path = urlunparse((\"\", \"\", parsed.path or \"/\", parsed.params, parsed.query, \"\"))\n    s = to_bytes(request.method) + b\" \" + to_bytes(path) + b\" HTTP/1.1\\r\\n\"\n    s += b\"Host: \" + to_bytes(parsed.hostname or b\"\") + b\"\\r\\n\"\n    if request.headers:\n        s += request.headers.to_string() + b\"\\r\\n\"\n    s += b\"\\r\\n\"\n    s += request.body\n    return s\n\n\ndef referer_str(request: Request) -> Optional[str]:\n    \"\"\"Return Referer HTTP header suitable for logging.\"\"\"\n    referrer = request.headers.get(\"Referer\")\n    if referrer is None:\n        return referrer\n    return to_unicode(referrer, errors=\"replace\")\n\n\ndef request_from_dict(d: Dict[str, Any], *, spider: Optional[Spider] = None) -> Request:\n    \"\"\"Create a :class:`~scrapy.Request` object from a dict.\n\n    If a spider is given, it will try to resolve the callbacks looking at the\n    spider for methods with the same name.\n    \"\"\"\n    request_cls: Type[Request] = load_object(d[\"_class\"]) if \"_class\" in d else Request\n    kwargs = {key: value for key, value in d.items() if key in request_cls.attributes}\n    if d.get(\"callback\") and spider:\n        kwargs[\"callback\"] = _get_method(spider, d[\"callback\"])\n    if d.get(\"errback\") and spider:\n        kwargs[\"errback\"] = _get_method(spider, d[\"errback\"])\n    return request_cls(**kwargs)\n\n\ndef _get_method(obj: Any, name: Any) -> Any:\n    \"\"\"Helper function for request_from_dict\"\"\"\n    name = str(name)\n    try:\n        return getattr(obj, name)\n    except AttributeError:\n        raise ValueError(f\"Method {name!r} not found in: {obj}\")\n\n\ndef request_to_curl(request: Request) -> str:\n    \"\"\"\n    Converts a :class:`~scrapy.Request` object to a curl command.\n\n    :param :class:`~scrapy.Request`: Request object to be converted\n    :return: string containing the curl command\n    \"\"\"\n    method = request.method\n\n    data = f\"--data-raw '{request.body.decode('utf-8')}'\" if request.body else \"\"\n\n    headers = \" \".join(\n        f\"-H '{k.decode()}: {v[0].decode()}'\" for k, v in request.headers.items()\n    )\n\n    url = request.url\n    cookies = \"\"\n    if request.cookies:\n        if isinstance(request.cookies, dict):\n            cookie = \"; \".join(f\"{k}={v}\" for k, v in request.cookies.items())\n            cookies = f\"--cookie '{cookie}'\"\n        elif isinstance(request.cookies, list):\n            cookie = \"; \".join(\n                f\"{list(c.keys())[0]}={list(c.values())[0]}\" for c in request.cookies\n            )\n            cookies = f\"--cookie '{cookie}'\"\n\n    curl_cmd = f\"curl -X {method} {url} {data} {headers} {cookies}\".strip()\n    return \" \".join(curl_cmd.split())\n", "file_name": "109129.py", "cwe": ["CWE-327: Use of a Broken or Risky Cryptographic Algorithm"]}
{"source": "from encoder.params_data import *\nfrom encoder.model import SpeakerEncoder\nfrom encoder.audio import preprocess_wav   # We want to expose this function from here\nfrom matplotlib import cm\nfrom encoder import audio\nfrom pathlib import Path\nimport numpy as np\nimport torch\n\n_model = None # type: SpeakerEncoder\n_device = None # type: torch.device\n\n\ndef load_model(weights_fpath: Path, device=None):\n    \"\"\"\n    Loads the model in memory. If this function is not explicitely called, it will be run on the\n    first call to embed_frames() with the default weights file.\n\n    :param weights_fpath: the path to saved model weights.\n    :param device: either a torch device or the name of a torch device (e.g. \"cpu\", \"cuda\"). The\n    model will be loaded and will run on this device. Outputs will however always be on the cpu.\n    If None, will default to your GPU if it\"s available, otherwise your CPU.\n    \"\"\"\n    # TODO: I think the slow loading of the encoder might have something to do with the device it\n    #   was saved on. Worth investigating.\n    global _model, _device\n    if device is None:\n        _device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    elif isinstance(device, str):\n        _device = torch.device(device)\n    _model = SpeakerEncoder(_device, torch.device(\"cpu\"))\n    checkpoint = torch.load(weights_fpath, _device)\n    _model.load_state_dict(checkpoint[\"model_state\"])\n    _model.eval()\n    print(\"Loaded encoder \\\"%s\\\" trained to step %d\" % (weights_fpath.name, checkpoint[\"step\"]))\n\n\ndef is_loaded():\n    return _model is not None\n\n\ndef embed_frames_batch(frames_batch):\n    \"\"\"\n    Computes embeddings for a batch of mel spectrogram.\n\n    :param frames_batch: a batch mel of spectrogram as a numpy array of float32 of shape\n    (batch_size, n_frames, n_channels)\n    :return: the embeddings as a numpy array of float32 of shape (batch_size, model_embedding_size)\n    \"\"\"\n    if _model is None:\n        raise Exception(\"Model was not loaded. Call load_model() before inference.\")\n\n    frames = torch.from_numpy(frames_batch).to(_device)\n    embed = _model.forward(frames).detach().cpu().numpy()\n    return embed\n\n\ndef compute_partial_slices(n_samples, partial_utterance_n_frames=partials_n_frames,\n                           min_pad_coverage=0.75, overlap=0.5):\n    \"\"\"\n    Computes where to split an utterance waveform and its corresponding mel spectrogram to obtain\n    partial utterances of <partial_utterance_n_frames> each. Both the waveform and the mel\n    spectrogram slices are returned, so as to make each partial utterance waveform correspond to\n    its spectrogram. This function assumes that the mel spectrogram parameters used are those\n    defined in params_data.py.\n\n    The returned ranges may be indexing further than the length of the waveform. It is\n    recommended that you pad the waveform with zeros up to wave_slices[-1].stop.\n\n    :param n_samples: the number of samples in the waveform\n    :param partial_utterance_n_frames: the number of mel spectrogram frames in each partial\n    utterance\n    :param min_pad_coverage: when reaching the last partial utterance, it may or may not have\n    enough frames. If at least <min_pad_coverage> of <partial_utterance_n_frames> are present,\n    then the last partial utterance will be considered, as if we padded the audio. Otherwise,\n    it will be discarded, as if we trimmed the audio. If there aren't enough frames for 1 partial\n    utterance, this parameter is ignored so that the function always returns at least 1 slice.\n    :param overlap: by how much the partial utterance should overlap. If set to 0, the partial\n    utterances are entirely disjoint.\n    :return: the waveform slices and mel spectrogram slices as lists of array slices. Index\n    respectively the waveform and the mel spectrogram with these slices to obtain the partial\n    utterances.\n    \"\"\"\n    assert 0 <= overlap < 1\n    assert 0 < min_pad_coverage <= 1\n\n    samples_per_frame = int((sampling_rate * mel_window_step / 1000))\n    n_frames = int(np.ceil((n_samples + 1) / samples_per_frame))\n    frame_step = max(int(np.round(partial_utterance_n_frames * (1 - overlap))), 1)\n\n    # Compute the slices\n    wav_slices, mel_slices = [], []\n    steps = max(1, n_frames - partial_utterance_n_frames + frame_step + 1)\n    for i in range(0, steps, frame_step):\n        mel_range = np.array([i, i + partial_utterance_n_frames])\n        wav_range = mel_range * samples_per_frame\n        mel_slices.append(slice(*mel_range))\n        wav_slices.append(slice(*wav_range))\n\n    # Evaluate whether extra padding is warranted or not\n    last_wav_range = wav_slices[-1]\n    coverage = (n_samples - last_wav_range.start) / (last_wav_range.stop - last_wav_range.start)\n    if coverage < min_pad_coverage and len(mel_slices) > 1:\n        mel_slices = mel_slices[:-1]\n        wav_slices = wav_slices[:-1]\n\n    return wav_slices, mel_slices\n\n\ndef embed_utterance(wav, using_partials=True, return_partials=False, **kwargs):\n    \"\"\"\n    Computes an embedding for a single utterance.\n\n    # TODO: handle multiple wavs to benefit from batching on GPU\n    :param wav: a preprocessed (see audio.py) utterance waveform as a numpy array of float32\n    :param using_partials: if True, then the utterance is split in partial utterances of\n    <partial_utterance_n_frames> frames and the utterance embedding is computed from their\n    normalized average. If False, the utterance is instead computed from feeding the entire\n    spectogram to the network.\n    :param return_partials: if True, the partial embeddings will also be returned along with the\n    wav slices that correspond to the partial embeddings.\n    :param kwargs: additional arguments to compute_partial_splits()\n    :return: the embedding as a numpy array of float32 of shape (model_embedding_size,). If\n    <return_partials> is True, the partial utterances as a numpy array of float32 of shape\n    (n_partials, model_embedding_size) and the wav partials as a list of slices will also be\n    returned. If <using_partials> is simultaneously set to False, both these values will be None\n    instead.\n    \"\"\"\n    # Process the entire utterance if not using partials\n    if not using_partials:\n        frames = audio.wav_to_mel_spectrogram(wav)\n        embed = embed_frames_batch(frames[None, ...])[0]\n        if return_partials:\n            return embed, None, None\n        return embed\n\n    # Compute where to split the utterance into partials and pad if necessary\n    wave_slices, mel_slices = compute_partial_slices(len(wav), **kwargs)\n    max_wave_length = wave_slices[-1].stop\n    if max_wave_length >= len(wav):\n        wav = np.pad(wav, (0, max_wave_length - len(wav)), \"constant\")\n\n    # Split the utterance into partials\n    frames = audio.wav_to_mel_spectrogram(wav)\n    frames_batch = np.array([frames[s] for s in mel_slices])\n    partial_embeds = embed_frames_batch(frames_batch)\n\n    # Compute the utterance embedding from the partial embeddings\n    raw_embed = np.mean(partial_embeds, axis=0)\n    embed = raw_embed / np.linalg.norm(raw_embed, 2)\n\n    if return_partials:\n        return embed, partial_embeds, wave_slices\n    return embed\n\n\ndef embed_speaker(wavs, **kwargs):\n    raise NotImplemented()\n\n\ndef plot_embedding_as_heatmap(embed, ax=None, title=\"\", shape=None, color_range=(0, 0.30)):\n    import matplotlib.pyplot as plt\n    if ax is None:\n        ax = plt.gca()\n\n    if shape is None:\n        height = int(np.sqrt(len(embed)))\n        shape = (height, -1)\n    embed = embed.reshape(shape)\n\n    cmap = cm.get_cmap()\n    mappable = ax.imshow(embed, cmap=cmap)\n    cbar = plt.colorbar(mappable, ax=ax, fraction=0.046, pad=0.04)\n    sm = cm.ScalarMappable(cmap=cmap)\n    sm.set_clim(*color_range)\n\n    ax.set_xticks([]), ax.set_yticks([])\n    ax.set_title(title)\n", "file_name": "770044.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "from datetime import datetime\nfrom functools import partial\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\nfrom torch import optim\nfrom torch.utils.data import DataLoader\n\nfrom synthesizer import audio\nfrom synthesizer.models.tacotron import Tacotron\nfrom synthesizer.synthesizer_dataset import SynthesizerDataset, collate_synthesizer\nfrom synthesizer.utils import ValueWindow, data_parallel_workaround\nfrom synthesizer.utils.plot import plot_spectrogram\nfrom synthesizer.utils.symbols import symbols\nfrom synthesizer.utils.text import sequence_to_text\nfrom vocoder.display import *\n\n\ndef np_now(x: torch.Tensor): return x.detach().cpu().numpy()\n\n\ndef time_string():\n    return datetime.now().strftime(\"%Y-%m-%d %H:%M\")\n\n\ndef train(run_id: str, syn_dir: Path, models_dir: Path, save_every: int,  backup_every: int, force_restart: bool,\n          hparams):\n    models_dir.mkdir(exist_ok=True)\n\n    model_dir = models_dir.joinpath(run_id)\n    plot_dir = model_dir.joinpath(\"plots\")\n    wav_dir = model_dir.joinpath(\"wavs\")\n    mel_output_dir = model_dir.joinpath(\"mel-spectrograms\")\n    meta_folder = model_dir.joinpath(\"metas\")\n    model_dir.mkdir(exist_ok=True)\n    plot_dir.mkdir(exist_ok=True)\n    wav_dir.mkdir(exist_ok=True)\n    mel_output_dir.mkdir(exist_ok=True)\n    meta_folder.mkdir(exist_ok=True)\n\n    weights_fpath = model_dir / f\"synthesizer.pt\"\n    metadata_fpath = syn_dir.joinpath(\"train.txt\")\n\n    print(\"Checkpoint path: {}\".format(weights_fpath))\n    print(\"Loading training data from: {}\".format(metadata_fpath))\n    print(\"Using model: Tacotron\")\n\n    # Bookkeeping\n    time_window = ValueWindow(100)\n    loss_window = ValueWindow(100)\n\n    # From WaveRNN/train_tacotron.py\n    if torch.cuda.is_available():\n        device = torch.device(\"cuda\")\n\n        for session in hparams.tts_schedule:\n            _, _, _, batch_size = session\n            if batch_size % torch.cuda.device_count() != 0:\n                raise ValueError(\"`batch_size` must be evenly divisible by n_gpus!\")\n    else:\n        device = torch.device(\"cpu\")\n    print(\"Using device:\", device)\n\n    # Instantiate Tacotron Model\n    print(\"\\nInitialising Tacotron Model...\\n\")\n    model = Tacotron(embed_dims=hparams.tts_embed_dims,\n                     num_chars=len(symbols),\n                     encoder_dims=hparams.tts_encoder_dims,\n                     decoder_dims=hparams.tts_decoder_dims,\n                     n_mels=hparams.num_mels,\n                     fft_bins=hparams.num_mels,\n                     postnet_dims=hparams.tts_postnet_dims,\n                     encoder_K=hparams.tts_encoder_K,\n                     lstm_dims=hparams.tts_lstm_dims,\n                     postnet_K=hparams.tts_postnet_K,\n                     num_highways=hparams.tts_num_highways,\n                     dropout=hparams.tts_dropout,\n                     stop_threshold=hparams.tts_stop_threshold,\n                     speaker_embedding_size=hparams.speaker_embedding_size).to(device)\n\n    # Initialize the optimizer\n    optimizer = optim.Adam(model.parameters())\n\n    # Load the weights\n    if force_restart or not weights_fpath.exists():\n        print(\"\\nStarting the training of Tacotron from scratch\\n\")\n        model.save(weights_fpath)\n\n        # Embeddings metadata\n        char_embedding_fpath = meta_folder.joinpath(\"CharacterEmbeddings.tsv\")\n        with open(char_embedding_fpath, \"w\", encoding=\"utf-8\") as f:\n            for symbol in symbols:\n                if symbol == \" \":\n                    symbol = \"\\\\s\"  # For visual purposes, swap space with \\s\n\n                f.write(\"{}\\n\".format(symbol))\n\n    else:\n        print(\"\\nLoading weights at %s\" % weights_fpath)\n        model.load(weights_fpath, optimizer)\n        print(\"Tacotron weights loaded from step %d\" % model.step)\n\n    # Initialize the dataset\n    metadata_fpath = syn_dir.joinpath(\"train.txt\")\n    mel_dir = syn_dir.joinpath(\"mels\")\n    embed_dir = syn_dir.joinpath(\"embeds\")\n    dataset = SynthesizerDataset(metadata_fpath, mel_dir, embed_dir, hparams)\n\n    for i, session in enumerate(hparams.tts_schedule):\n        current_step = model.get_step()\n\n        r, lr, max_step, batch_size = session\n\n        training_steps = max_step - current_step\n\n        # Do we need to change to the next session?\n        if current_step >= max_step:\n            # Are there no further sessions than the current one?\n            if i == len(hparams.tts_schedule) - 1:\n                # We have completed training. Save the model and exit\n                model.save(weights_fpath, optimizer)\n                break\n            else:\n                # There is a following session, go to it\n                continue\n\n        model.r = r\n\n        # Begin the training\n        simple_table([(f\"Steps with r={r}\", str(training_steps // 1000) + \"k Steps\"),\n                      (\"Batch Size\", batch_size),\n                      (\"Learning Rate\", lr),\n                      (\"Outputs/Step (r)\", model.r)])\n\n        for p in optimizer.param_groups:\n            p[\"lr\"] = lr\n\n        collate_fn = partial(collate_synthesizer, r=r, hparams=hparams)\n        data_loader = DataLoader(dataset, batch_size, shuffle=True, num_workers=2, collate_fn=collate_fn)\n\n        total_iters = len(dataset)\n        steps_per_epoch = np.ceil(total_iters / batch_size).astype(np.int32)\n        epochs = np.ceil(training_steps / steps_per_epoch).astype(np.int32)\n\n        for epoch in range(1, epochs+1):\n            for i, (texts, mels, embeds, idx) in enumerate(data_loader, 1):\n                start_time = time.time()\n\n                # Generate stop tokens for training\n                stop = torch.ones(mels.shape[0], mels.shape[2])\n                for j, k in enumerate(idx):\n                    stop[j, :int(dataset.metadata[k][4])-1] = 0\n\n                texts = texts.to(device)\n                mels = mels.to(device)\n                embeds = embeds.to(device)\n                stop = stop.to(device)\n\n                # Forward pass\n                # Parallelize model onto GPUS using workaround due to python bug\n                if device.type == \"cuda\" and torch.cuda.device_count() > 1:\n                    m1_hat, m2_hat, attention, stop_pred = data_parallel_workaround(model, texts, mels, embeds)\n                else:\n                    m1_hat, m2_hat, attention, stop_pred = model(texts, mels, embeds)\n\n                # Backward pass\n                m1_loss = F.mse_loss(m1_hat, mels) + F.l1_loss(m1_hat, mels)\n                m2_loss = F.mse_loss(m2_hat, mels)\n                stop_loss = F.binary_cross_entropy(stop_pred, stop)\n\n                loss = m1_loss + m2_loss + stop_loss\n\n                optimizer.zero_grad()\n                loss.backward()\n\n                if hparams.tts_clip_grad_norm is not None:\n                    grad_norm = torch.nn.utils.clip_grad_norm_(model.parameters(), hparams.tts_clip_grad_norm)\n                    if np.isnan(grad_norm.cpu()):\n                        print(\"grad_norm was NaN!\")\n\n                optimizer.step()\n\n                time_window.append(time.time() - start_time)\n                loss_window.append(loss.item())\n\n                step = model.get_step()\n                k = step // 1000\n\n                msg = f\"| Epoch: {epoch}/{epochs} ({i}/{steps_per_epoch}) | Loss: {loss_window.average:#.4} | \" \\\n                      f\"{1./time_window.average:#.2} steps/s | Step: {k}k | \"\n                stream(msg)\n\n                # Backup or save model as appropriate\n                if backup_every != 0 and step % backup_every == 0 :\n                    backup_fpath = weights_fpath.parent / f\"synthesizer_{k:06d}.pt\"\n                    model.save(backup_fpath, optimizer)\n\n                if save_every != 0 and step % save_every == 0 :\n                    # Must save latest optimizer state to ensure that resuming training\n                    # doesn't produce artifacts\n                    model.save(weights_fpath, optimizer)\n\n                # Evaluate model to generate samples\n                epoch_eval = hparams.tts_eval_interval == -1 and i == steps_per_epoch  # If epoch is done\n                step_eval = hparams.tts_eval_interval > 0 and step % hparams.tts_eval_interval == 0  # Every N steps\n                if epoch_eval or step_eval:\n                    for sample_idx in range(hparams.tts_eval_num_samples):\n                        # At most, generate samples equal to number in the batch\n                        if sample_idx + 1 <= len(texts):\n                            # Remove padding from mels using frame length in metadata\n                            mel_length = int(dataset.metadata[idx[sample_idx]][4])\n                            mel_prediction = np_now(m2_hat[sample_idx]).T[:mel_length]\n                            target_spectrogram = np_now(mels[sample_idx]).T[:mel_length]\n                            attention_len = mel_length // model.r\n\n                            eval_model(attention=np_now(attention[sample_idx][:, :attention_len]),\n                                       mel_prediction=mel_prediction,\n                                       target_spectrogram=target_spectrogram,\n                                       input_seq=np_now(texts[sample_idx]),\n                                       step=step,\n                                       plot_dir=plot_dir,\n                                       mel_output_dir=mel_output_dir,\n                                       wav_dir=wav_dir,\n                                       sample_num=sample_idx + 1,\n                                       loss=loss,\n                                       hparams=hparams)\n\n                # Break out of loop to update training schedule\n                if step >= max_step:\n                    break\n\n            # Add line break after every epoch\n            print(\"\")\n\n\ndef eval_model(attention, mel_prediction, target_spectrogram, input_seq, step,\n               plot_dir, mel_output_dir, wav_dir, sample_num, loss, hparams):\n    # Save some results for evaluation\n    attention_path = str(plot_dir.joinpath(\"attention_step_{}_sample_{}\".format(step, sample_num)))\n    save_attention(attention, attention_path)\n\n    # save predicted mel spectrogram to disk (debug)\n    mel_output_fpath = mel_output_dir.joinpath(\"mel-prediction-step-{}_sample_{}.npy\".format(step, sample_num))\n    np.save(str(mel_output_fpath), mel_prediction, allow_pickle=False)\n\n    # save griffin lim inverted wav for debug (mel -> wav)\n    wav = audio.inv_mel_spectrogram(mel_prediction.T, hparams)\n    wav_fpath = wav_dir.joinpath(\"step-{}-wave-from-mel_sample_{}.wav\".format(step, sample_num))\n    audio.save_wav(wav, str(wav_fpath), sr=hparams.sample_rate)\n\n    # save real and predicted mel-spectrogram plot to disk (control purposes)\n    spec_fpath = plot_dir.joinpath(\"step-{}-mel-spectrogram_sample_{}.png\".format(step, sample_num))\n    title_str = \"{}, {}, step={}, loss={:.5f}\".format(\"Tacotron\", time_string(), step, loss)\n    plot_spectrogram(mel_prediction, str(spec_fpath), title=title_str,\n                     target_spectrogram=target_spectrogram,\n                     max_len=target_spectrogram.size // hparams.num_mels)\n    print(\"Input at step {}: {}\".format(step, sequence_to_text(input_seq)))\n", "file_name": "508391.py", "cwe": ["CWE-676: Use of Potentially Dangerous Function"]}
{"source": "\"\"\"\nMain entry point for the benchmarking tool.\n\nThis module provides a command-line interface for running benchmarks using Typer.\nIt allows users to specify the path to an agent, the benchmark(s) to run, and other\noptions such as verbosity.\n\nFunctions\n---------\nget_agent : function\n    Dynamically imports and returns the default configuration agent from the given path.\n\nmain : function\n    The main function that runs the specified benchmarks with the given agent.\n    Outputs the results to the console.\n\nAttributes\n----------\n__name__ : str\n    The standard boilerplate for invoking the main function when the script is executed.\n\"\"\"\nimport importlib\nimport os.path\nimport sys\n\nfrom typing import Annotated, Optional\n\nimport typer\n\nfrom langchain.globals import set_llm_cache\nfrom langchain_community.cache import SQLiteCache\n\nfrom gpt_engineer.applications.cli.main import load_env_if_needed\nfrom gpt_engineer.benchmark.bench_config import BenchConfig\nfrom gpt_engineer.benchmark.benchmarks.load import get_benchmark\nfrom gpt_engineer.benchmark.run import export_yaml_results, print_results, run\n\napp = typer.Typer(\n    context_settings={\"help_option_names\": [\"-h\", \"--help\"]}\n)  # creates a CLI app\n\n\ndef get_agent(path):\n    \"\"\"\n    Dynamically imports and returns the default configuration agent from the given path.\n\n    Parameters\n    ----------\n    path : str\n        The file path to the module containing the default configuration agent.\n\n    Returns\n    -------\n    BaseAgent\n        An instance of the imported default configuration agent.\n    \"\"\"\n    # Dynamically import the python module at path\n    sys.path.append(os.path.dirname(path))\n    agent_module = importlib.import_module(path.replace(\"/\", \".\").replace(\".py\", \"\"))\n    return agent_module.default_config_agent()\n\n\n@app.command(\n    help=\"\"\"\n        Run any benchmark(s) against the specified agent.\n\n        \\b\n        Currently available benchmarks are: apps and mbpp\n    \"\"\"\n)\ndef main(\n    path_to_agent: Annotated[\n        str,\n        typer.Argument(\n            help=\"python file that contains a function called 'default_config_agent'\"\n        ),\n    ],\n    bench_config: Annotated[\n        str, typer.Argument(help=\"optional task name in benchmark\")\n    ] = os.path.join(os.path.dirname(__file__), \"default_bench_config.toml\"),\n    yaml_output: Annotated[\n        Optional[str],\n        typer.Option(help=\"print results for each task\", show_default=False),\n    ] = None,\n    verbose: Annotated[\n        Optional[bool],\n        typer.Option(help=\"print results for each task\", show_default=False),\n    ] = False,\n    use_cache: Annotated[\n        Optional[bool],\n        typer.Option(\n            help=\"Speeds up computations and saves tokens when running the same prompt multiple times by caching the LLM response.\",\n            show_default=False,\n        ),\n    ] = True,\n):\n    \"\"\"\n    The main function that runs the specified benchmarks with the given agent and outputs the results to the console.\n\n    Parameters\n    ----------\n    path_to_agent : str\n        The file path to the Python module that contains a function called 'default_config_agent'.\n    bench_config : str, default=default_bench_config.toml\n        Configuration file for choosing which benchmark problems to run. See default config for more details.\n    yaml_output: Optional[str], default=None\n        Pass a path to a yaml file to have results written to file.\n    verbose : Optional[bool], default=False\n        A flag to indicate whether to print results for each task.\n    use_cache : Optional[bool], default=True\n        Speeds up computations and saves tokens when running the same prompt multiple times by caching the LLM response.\n    Returns\n    -------\n    None\n    \"\"\"\n    if use_cache:\n        set_llm_cache(SQLiteCache(database_path=\".langchain.db\"))\n    load_env_if_needed()\n    config = BenchConfig.from_toml(bench_config)\n    print(\"using config file: \" + bench_config)\n    benchmarks = list()\n    benchmark_results = dict()\n    for specific_config_name in vars(config):\n        specific_config = getattr(config, specific_config_name)\n        if hasattr(specific_config, \"active\"):\n            if specific_config.active:\n                benchmarks.append(specific_config_name)\n\n    for benchmark_name in benchmarks:\n        benchmark = get_benchmark(benchmark_name, config)\n        if len(benchmark.tasks) == 0:\n            print(\n                benchmark_name\n                + \" was skipped, since no tasks are specified. Increase the number of tasks in the config file at: \"\n                + bench_config\n            )\n            continue\n        agent = get_agent(path_to_agent)\n\n        results = run(agent, benchmark, verbose=verbose)\n        print(\n            f\"\\n--- Results for agent {path_to_agent}, benchmark: {benchmark_name} ---\"\n        )\n        print_results(results)\n        print()\n        benchmark_results[benchmark_name] = {\n            \"detailed\": [result.to_dict() for result in results]\n        }\n    if yaml_output is not None:\n        export_yaml_results(yaml_output, benchmark_results, config.to_dict())\n\n\nif __name__ == \"__main__\":\n    typer.run(main)\n", "file_name": "641969.py", "cwe": ["CWE-706: Use of Incorrectly-Resolved Name or Reference"]}
{"source": "# This is a websocket interpreter, TTS and STT disabled.\n# It makes a websocket on a port that sends/receives LMC messages in *streaming* format.\n\n### You MUST send a start and end flag with each message! For example: ###\n\n\"\"\"\n{\"role\": \"user\", \"type\": \"message\", \"start\": True})\n{\"role\": \"user\", \"type\": \"message\", \"content\": \"hi\"})\n{\"role\": \"user\", \"type\": \"message\", \"end\": True})\n\"\"\"\n\nimport asyncio\nimport json\n\n###\n# from RealtimeTTS import TextToAudioStream, OpenAIEngine, CoquiEngine\n# from RealtimeSTT import AudioToTextRecorder\n# from beeper import Beeper\nimport time\nimport traceback\nfrom typing import Any, Dict, List\n\nfrom fastapi import FastAPI, Header, WebSocket\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel\nfrom uvicorn import Config, Server\n\n\nclass Settings(BaseModel):\n    auto_run: bool\n    custom_instructions: str\n    model: str\n\n\nclass AsyncInterpreter:\n    def __init__(self, interpreter):\n        self.interpreter = interpreter\n\n        # STT\n        # self.stt = AudioToTextRecorder(use_microphone=False)\n        # self.stt.stop() # It needs this for some reason\n\n        # TTS\n        # if self.interpreter.tts == \"coqui\":\n        #     engine = CoquiEngine()\n        # elif self.interpreter.tts == \"openai\":\n        #     engine = OpenAIEngine()\n        # self.tts = TextToAudioStream(engine)\n\n        # Clock\n        # clock()\n\n        # self.beeper = Beeper()\n\n        # Startup sounds\n        # self.beeper.beep(\"Blow\")\n        # self.tts.feed(\"Hi, how can I help you?\")\n        # self.tts.play_async(on_audio_chunk=self.on_tts_chunk, muted=True)\n\n        self._input_queue = asyncio.Queue()  # Queue that .input will shove things into\n        self._output_queue = asyncio.Queue()  # Queue to put output chunks into\n        self._last_lmc_start_flag = None  # Unix time of last LMC start flag received\n        self._in_keyboard_write_block = (\n            False  # Tracks whether interpreter is trying to use the keyboard\n        )\n\n        # self.loop = asyncio.get_event_loop()\n\n    async def _add_to_queue(self, queue, item):\n        await queue.put(item)\n\n    async def clear_queue(self, queue):\n        while not queue.empty():\n            await queue.get()\n\n    async def clear_input_queue(self):\n        await self.clear_queue(self._input_queue)\n\n    async def clear_output_queue(self):\n        await self.clear_queue(self._output_queue)\n\n    async def input(self, chunk):\n        \"\"\"\n        Expects a chunk in streaming LMC format.\n        \"\"\"\n        if isinstance(chunk, bytes):\n            # It's probably a chunk of audio\n            # self.stt.feed_audio(chunk)\n            pass\n        else:\n            try:\n                chunk = json.loads(chunk)\n            except:\n                pass\n\n            if \"start\" in chunk:\n                # self.stt.start()\n                self._last_lmc_start_flag = time.time()\n                self.interpreter.computer.terminate()\n                # Stop any code execution... maybe we should make interpreter.stop()?\n            elif \"end\" in chunk:\n                asyncio.create_task(self.run())\n            else:\n                await self._add_to_queue(self._input_queue, chunk)\n\n    def add_to_output_queue_sync(self, chunk):\n        \"\"\"\n        Synchronous function to add a chunk to the output queue.\n        \"\"\"\n        asyncio.create_task(self._add_to_queue(self._output_queue, chunk))\n\n    async def run(self):\n        \"\"\"\n        Runs OI on the audio bytes submitted to the input. Will add streaming LMC chunks to the _output_queue.\n        \"\"\"\n        # self.beeper.start()\n\n        # self.stt.stop()\n        # message = self.stt.text()\n        # print(\"THE MESSAGE:\", message)\n\n        input_queue = list(self._input_queue._queue)\n        message = [i for i in input_queue if i[\"type\"] == \"message\"][0][\"content\"]\n\n        def generate(message):\n            last_lmc_start_flag = self._last_lmc_start_flag\n            # interpreter.messages = self.active_chat_messages\n            # print(\"\ud83c\udf40\ud83c\udf40\ud83c\udf40\ud83c\udf40GENERATING, using these messages: \", self.interpreter.messages)\n            print(\"passing this in:\", message)\n            for chunk in self.interpreter.chat(message, display=False, stream=True):\n                if self._last_lmc_start_flag != last_lmc_start_flag:\n                    # self.beeper.stop()\n                    break\n\n                # self.add_to_output_queue_sync(chunk) # To send text, not just audio\n\n                content = chunk.get(\"content\")\n\n                # Handle message blocks\n                if chunk.get(\"type\") == \"message\":\n                    self.add_to_output_queue_sync(\n                        chunk.copy()\n                    )  # To send text, not just audio\n                    # ^^^^^^^ MUST be a copy, otherwise the first chunk will get modified by OI >>while<< it's in the queue. Insane\n                    if content:\n                        # self.beeper.stop()\n\n                        # Experimental: The AI voice sounds better with replacements like these, but it should happen at the TTS layer\n                        # content = content.replace(\". \", \". ... \").replace(\", \", \", ... \").replace(\"!\", \"! ... \").replace(\"?\", \"? ... \")\n\n                        yield content\n\n                # Handle code blocks\n                elif chunk.get(\"type\") == \"code\":\n                    pass\n                    # if \"start\" in chunk:\n                    # self.beeper.start()\n\n                    # Experimental: If the AI wants to type, we should type immediately\n                    # if (\n                    #     self.interpreter.messages[-1]\n                    #     .get(\"content\", \"\")\n                    #     .startswith(\"computer.keyboard.write(\")\n                    # ):\n                    #     keyboard.controller.type(content)\n                    #     self._in_keyboard_write_block = True\n                    # if \"end\" in chunk and self._in_keyboard_write_block:\n                    #     self._in_keyboard_write_block = False\n                    #     # (This will make it so it doesn't type twice when the block executes)\n                    #     if self.interpreter.messages[-1][\"content\"].startswith(\n                    #         \"computer.keyboard.write(\"\n                    #     ):\n                    #         self.interpreter.messages[-1][\"content\"] = (\n                    #             \"dummy_variable = (\"\n                    #             + self.interpreter.messages[-1][\"content\"][\n                    #                 len(\"computer.keyboard.write(\") :\n                    #             ]\n                    #         )\n\n            # Send a completion signal\n            self.add_to_output_queue_sync(\n                {\"role\": \"server\", \"type\": \"completion\", \"content\": \"DONE\"}\n            )\n\n        # Feed generate to RealtimeTTS\n        # self.tts.feed(generate(message))\n        for _ in generate(message):\n            pass\n        # self.tts.play_async(on_audio_chunk=self.on_tts_chunk, muted=True)\n\n    async def output(self):\n        return await self._output_queue.get()\n\n\ndef server(interpreter, port=8000):  # Default port is 8000 if not specified\n    async_interpreter = AsyncInterpreter(interpreter)\n\n    app = FastAPI()\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],  # Allow all methods (GET, POST, etc.)\n        allow_headers=[\"*\"],  # Allow all headers\n    )\n\n    @app.post(\"/settings\")\n    async def settings(payload: Dict[str, Any]):\n        for key, value in payload.items():\n            print(\"Updating interpreter settings with the following:\")\n            print(key, value)\n            if key == \"llm\" and isinstance(value, dict):\n                for sub_key, sub_value in value.items():\n                    setattr(async_interpreter.interpreter, sub_key, sub_value)\n            else:\n                setattr(async_interpreter.interpreter, key, value)\n\n        return {\"status\": \"success\"}\n\n    @app.websocket(\"/\")\n    async def websocket_endpoint(websocket: WebSocket):\n        await websocket.accept()\n        try:\n\n            async def receive_input():\n                while True:\n                    data = await websocket.receive()\n                    print(data)\n                    if isinstance(data, bytes):\n                        await async_interpreter.input(data)\n                    elif \"text\" in data:\n                        await async_interpreter.input(data[\"text\"])\n                    elif data == {\"type\": \"websocket.disconnect\", \"code\": 1000}:\n                        print(\"Websocket disconnected with code 1000.\")\n                        break\n\n            async def send_output():\n                while True:\n                    output = await async_interpreter.output()\n                    if isinstance(output, bytes):\n                        # await websocket.send_bytes(output)\n                        # we don't send out bytes rn, no TTS\n                        pass\n                    elif isinstance(output, dict):\n                        await websocket.send_text(json.dumps(output))\n\n            await asyncio.gather(receive_input(), send_output())\n        except Exception as e:\n            print(f\"WebSocket connection closed with exception: {e}\")\n            traceback.print_exc()\n        finally:\n            await websocket.close()\n\n    config = Config(app, host=\"0.0.0.0\", port=port)\n    interpreter.uvicorn_server = Server(config)\n    interpreter.uvicorn_server.run()\n", "file_name": "262477.py", "cwe": ["CWE-942: Permissive Cross-domain Policy with Untrusted Domains"]}
{"source": "#!/usr/bin python3\n\"\"\" Handles command line calls to git \"\"\"\nimport logging\nimport os\nimport sys\n\nfrom subprocess import PIPE, Popen\n\nlogger = logging.getLogger(__name__)\n\n\nclass Git():\n    \"\"\" Handles calls to github \"\"\"\n    def __init__(self) -> None:\n        logger.debug(\"Initializing: %s\", self.__class__.__name__)\n        self._working_dir = os.path.dirname(os.path.realpath(sys.argv[0]))\n        self._available = self._check_available()\n        logger.debug(\"Initialized: %s\", self.__class__.__name__)\n\n    def _from_git(self, command: str) -> tuple[bool, list[str]]:\n        \"\"\" Execute a git command\n\n        Parameters\n        ----------\n        command : str\n            The command to send to git\n\n        Returns\n        -------\n        success: bool\n            ``True`` if the command succesfully executed otherwise ``False``\n        list[str]\n            The output lines from stdout if there was no error, otherwise from stderr\n        \"\"\"\n        logger.debug(\"command: '%s'\", command)\n        cmd = f\"git {command}\"\n        with Popen(cmd, shell=True, stdout=PIPE, stderr=PIPE, cwd=self._working_dir) as proc:\n            stdout, stderr = proc.communicate()\n        retcode = proc.returncode\n        success = retcode == 0\n        lines = stdout.decode(\"utf-8\", errors=\"replace\").splitlines()\n        if not lines:\n            lines = stderr.decode(\"utf-8\", errors=\"replace\").splitlines()\n        logger.debug(\"command: '%s', returncode: %s, success: %s, lines: %s\",\n                     cmd, retcode, success, lines)\n        return success, lines\n\n    def _check_available(self) -> bool:\n        \"\"\" Check if git is available. Does a call to git status. If the process errors due to\n        folder ownership, attempts to add the folder to github safe folders list and tries\n        again\n\n        Returns\n        -------\n        bool\n            ``True`` if git is available otherwise ``False``\n\n        \"\"\"\n        success, msg = self._from_git(\"status\")\n        if success:\n            return True\n        config = next((line.strip() for line in msg if \"add safe.directory\" in line), None)\n        if not config:\n            return False\n        success, _ = self._from_git(config.split(\"git \", 1)[-1])\n        return True\n\n    @property\n    def status(self) -> list[str]:\n        \"\"\" Obtain the output of git status for tracked files only \"\"\"\n        if not self._available:\n            return []\n        success, status = self._from_git(\"status -uno\")\n        if not success or not status:\n            return []\n        return status\n\n    @property\n    def branch(self) -> str:\n        \"\"\" str: The git branch that is currently being used to execute Faceswap. \"\"\"\n        status = next((line.strip() for line in self.status if \"On branch\" in line), \"Not Found\")\n        return status.replace(\"On branch \", \"\")\n\n    @property\n    def branches(self) -> list[str]:\n        \"\"\" list[str]: List of all available branches. \"\"\"\n        if not self._available:\n            return []\n        success, branches = self._from_git(\"branch -a\")\n        if not success or not branches:\n            return []\n        return branches\n\n    def update_remote(self) -> bool:\n        \"\"\" Update all branches to track remote\n\n        Returns\n        -------\n        bool\n            ``True`` if update was succesful otherwise ``False``\n        \"\"\"\n        if not self._available:\n            return False\n        return self._from_git(\"remote update\")[0]\n\n    def pull(self) -> bool:\n        \"\"\" Pull the current branch\n\n        Returns\n        -------\n        bool\n            ``True`` if pull is successful otherwise ``False``\n        \"\"\"\n        if not self._available:\n            return False\n        return self._from_git(\"pull\")[0]\n\n    def checkout(self, branch: str) -> bool:\n        \"\"\" Checkout the requested branch\n\n        Parameters\n        ----------\n        branch : str\n            The branch to checkout\n\n        Returns\n        -------\n        bool\n            ``True`` if the branch was succesfully checkout out otherwise ``False``\n        \"\"\"\n        if not self._available:\n            return False\n        return self._from_git(f\"checkout {branch}\")[0]\n\n    def get_commits(self, count: int) -> list[str]:\n        \"\"\" Obtain the last commits to the repo\n\n        Parameters\n        ----------\n        count : int\n            The last number of commits to obtain\n\n        Returns\n        -------\n        list[str]\n            list of commits, or empty list if none found\n        \"\"\"\n        if not self._available:\n            return []\n        success, commits = self._from_git(f\"log --pretty=oneline --abbrev-commit -n {count}\")\n        if not success or not commits:\n            return []\n        return commits\n\n\ngit = Git()\n\"\"\" :class:`Git`: Handles calls to github \"\"\"\n", "file_name": "513433.py", "cwe": ["CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"]}
{"source": "#!/usr/bin/env python3\n\"\"\" Plugin loader for Faceswap extract, training and convert tasks \"\"\"\nfrom __future__ import annotations\nimport logging\nimport os\nimport typing as T\n\nfrom importlib import import_module\n\nif T.TYPE_CHECKING:\n    from collections.abc import Callable\n    from plugins.extract.detect._base import Detector\n    from plugins.extract.align._base import Aligner\n    from plugins.extract.mask._base import Masker\n    from plugins.extract.recognition._base import Identity\n    from plugins.train.model._base import ModelBase\n    from plugins.train.trainer._base import TrainerBase\n\nlogger = logging.getLogger(__name__)\n\n\nclass PluginLoader():\n    \"\"\" Retrieve, or get information on, Faceswap plugins\n\n    Return a specific plugin, list available plugins, or get the default plugin for a\n    task.\n\n    Example\n    -------\n    >>> from plugins.plugin_loader import PluginLoader\n    >>> align_plugins = PluginLoader.get_available_extractors('align')\n    >>> aligner = PluginLoader.get_aligner('cv2-dnn')\n    \"\"\"\n    @staticmethod\n    def get_detector(name: str, disable_logging: bool = False) -> type[Detector]:\n        \"\"\" Return requested detector plugin\n\n        Parameters\n        ----------\n        name: str\n            The name of the requested detector plugin\n        disable_logging: bool, optional\n            Whether to disable the INFO log message that the plugin is being imported.\n            Default: `False`\n\n        Returns\n        -------\n        :class:`plugins.extract.detect` object:\n            An extraction detector plugin\n        \"\"\"\n        return PluginLoader._import(\"extract.detect\", name, disable_logging)\n\n    @staticmethod\n    def get_aligner(name: str, disable_logging: bool = False) -> type[Aligner]:\n        \"\"\" Return requested aligner plugin\n\n        Parameters\n        ----------\n        name: str\n            The name of the requested aligner plugin\n        disable_logging: bool, optional\n            Whether to disable the INFO log message that the plugin is being imported.\n            Default: `False`\n\n        Returns\n        -------\n        :class:`plugins.extract.align` object:\n            An extraction aligner plugin\n        \"\"\"\n        return PluginLoader._import(\"extract.align\", name, disable_logging)\n\n    @staticmethod\n    def get_masker(name: str, disable_logging: bool = False) -> type[Masker]:\n        \"\"\" Return requested masker plugin\n\n        Parameters\n        ----------\n        name: str\n            The name of the requested masker plugin\n        disable_logging: bool, optional\n            Whether to disable the INFO log message that the plugin is being imported.\n            Default: `False`\n\n        Returns\n        -------\n        :class:`plugins.extract.mask` object:\n            An extraction masker plugin\n        \"\"\"\n        return PluginLoader._import(\"extract.mask\", name, disable_logging)\n\n    @staticmethod\n    def get_recognition(name: str, disable_logging: bool = False) -> type[Identity]:\n        \"\"\" Return requested recognition plugin\n\n        Parameters\n        ----------\n        name: str\n            The name of the requested reccognition plugin\n        disable_logging: bool, optional\n            Whether to disable the INFO log message that the plugin is being imported.\n            Default: `False`\n\n        Returns\n        -------\n        :class:`plugins.extract.recognition` object:\n            An extraction recognition plugin\n        \"\"\"\n        return PluginLoader._import(\"extract.recognition\", name, disable_logging)\n\n    @staticmethod\n    def get_model(name: str, disable_logging: bool = False) -> type[ModelBase]:\n        \"\"\" Return requested training model plugin\n\n        Parameters\n        ----------\n        name: str\n            The name of the requested training model plugin\n        disable_logging: bool, optional\n            Whether to disable the INFO log message that the plugin is being imported.\n            Default: `False`\n\n        Returns\n        -------\n        :class:`plugins.train.model` object:\n            A training model plugin\n        \"\"\"\n        return PluginLoader._import(\"train.model\", name, disable_logging)\n\n    @staticmethod\n    def get_trainer(name: str, disable_logging: bool = False) -> type[TrainerBase]:\n        \"\"\" Return requested training trainer plugin\n\n        Parameters\n        ----------\n        name: str\n            The name of the requested training trainer plugin\n        disable_logging: bool, optional\n            Whether to disable the INFO log message that the plugin is being imported.\n            Default: `False`\n\n        Returns\n        -------\n        :class:`plugins.train.trainer` object:\n            A training trainer plugin\n        \"\"\"\n        return PluginLoader._import(\"train.trainer\", name, disable_logging)\n\n    @staticmethod\n    def get_converter(category: str, name: str, disable_logging: bool = False) -> Callable:\n        \"\"\" Return requested converter plugin\n\n        Converters work slightly differently to other faceswap plugins. They are created to do a\n        specific task (e.g. color adjustment, mask blending etc.), so multiple plugins will be\n        loaded in the convert phase, rather than just one plugin for the other phases.\n\n        Parameters\n        ----------\n        name: str\n            The name of the requested converter plugin\n        disable_logging: bool, optional\n            Whether to disable the INFO log message that the plugin is being imported.\n            Default: `False`\n\n        Returns\n        -------\n        :class:`plugins.convert` object:\n            A converter sub plugin\n        \"\"\"\n        return PluginLoader._import(f\"convert.{category}\", name, disable_logging)\n\n    @staticmethod\n    def _import(attr: str, name: str, disable_logging: bool):\n        \"\"\" Import the plugin's module\n\n        Parameters\n        ----------\n        name: str\n            The name of the requested converter plugin\n        disable_logging: bool\n            Whether to disable the INFO log message that the plugin is being imported.\n\n        Returns\n        -------\n        :class:`plugin` object:\n            A plugin\n        \"\"\"\n        name = name.replace(\"-\", \"_\")\n        ttl = attr.split(\".\")[-1].title()\n        if not disable_logging:\n            logger.info(\"Loading %s from %s plugin...\", ttl, name.title())\n        attr = \"model\" if attr == \"Trainer\" else attr.lower()\n        mod = \".\".join((\"plugins\", attr, name))\n        module = import_module(mod)\n        return getattr(module, ttl)\n\n    @staticmethod\n    def get_available_extractors(extractor_type: T.Literal[\"align\", \"detect\", \"mask\"],\n                                 add_none: bool = False,\n                                 extend_plugin: bool = False) -> list[str]:\n        \"\"\" Return a list of available extractors of the given type\n\n        Parameters\n        ----------\n        extractor_type: {'align', 'detect', 'mask'}\n            The type of extractor to return the plugins for\n        add_none: bool, optional\n            Append \"none\" to the list of returned plugins. Default: False\n        extend_plugin: bool, optional\n            Some plugins have configuration options that mean that multiple 'pseudo-plugins'\n            can be generated based on their settings. An example of this is the bisenet-fp mask\n            which, whilst selected as 'bisenet-fp' can be stored as 'bisenet-fp-face' and\n            'bisenet-fp-head' depending on whether hair has been included in the mask or not.\n            ``True`` will generate each pseudo-plugin, ``False`` will generate the original\n            plugin name. Default: ``False``\n\n        Returns\n        -------\n        list:\n            A list of the available extractor plugin names for the given type\n        \"\"\"\n        extractpath = os.path.join(os.path.dirname(__file__),\n                                   \"extract\",\n                                   extractor_type)\n        extractors = [item.name.replace(\".py\", \"\").replace(\"_\", \"-\")\n                      for item in os.scandir(extractpath)\n                      if not item.name.startswith(\"_\")\n                      and not item.name.endswith(\"defaults.py\")\n                      and item.name.endswith(\".py\")]\n        extendable = [\"bisenet-fp\", \"custom\"]\n        if extend_plugin and extractor_type == \"mask\" and any(ext in extendable\n                                                              for ext in extractors):\n            for msk in extendable:\n                extractors.remove(msk)\n                extractors.extend([f\"{msk}_face\", f\"{msk}_head\"])\n\n        extractors = sorted(extractors)\n        if add_none:\n            extractors.insert(0, \"none\")\n        return extractors\n\n    @staticmethod\n    def get_available_models() -> list[str]:\n        \"\"\" Return a list of available training models\n\n        Returns\n        -------\n        list:\n            A list of the available training model plugin names\n        \"\"\"\n        modelpath = os.path.join(os.path.dirname(__file__), \"train\", \"model\")\n        models = sorted(item.name.replace(\".py\", \"\").replace(\"_\", \"-\")\n                        for item in os.scandir(modelpath)\n                        if not item.name.startswith(\"_\")\n                        and not item.name.endswith(\"defaults.py\")\n                        and item.name.endswith(\".py\"))\n        return models\n\n    @staticmethod\n    def get_default_model() -> str:\n        \"\"\" Return the default training model plugin name\n\n        Returns\n        -------\n        str:\n            The default faceswap training model\n\n        \"\"\"\n        models = PluginLoader.get_available_models()\n        return 'original' if 'original' in models else models[0]\n\n    @staticmethod\n    def get_available_convert_plugins(convert_category: str, add_none: bool = True) -> list[str]:\n        \"\"\" Return a list of available converter plugins in the given category\n\n        Parameters\n        ----------\n        convert_category: {'color', 'mask', 'scaling', 'writer'}\n            The category of converter plugin to return the plugins for\n        add_none: bool, optional\n            Append \"none\" to the list of returned plugins. Default: True\n\n        Returns\n        -------\n        list\n            A list of the available converter plugin names in the given category\n        \"\"\"\n\n        convertpath = os.path.join(os.path.dirname(__file__),\n                                   \"convert\",\n                                   convert_category)\n        converters = sorted(item.name.replace(\".py\", \"\").replace(\"_\", \"-\")\n                            for item in os.scandir(convertpath)\n                            if not item.name.startswith(\"_\")\n                            and not item.name.endswith(\"defaults.py\")\n                            and item.name.endswith(\".py\"))\n        if add_none:\n            converters.insert(0, \"none\")\n        return converters\n", "file_name": "335203.py", "cwe": ["CWE-706: Use of Incorrectly-Resolved Name or Reference"]}
{"source": "\"\"\"\nContains some simple tests.\nThe purpose of this tests is to detect crashes and hangs\nbut NOT to guarantee the corectness of the operations.\nFor this we want another set of testcases using pytest.\n\nDue to my lazy coding, DON'T USE PATHES WITH BLANKS !\n\"\"\"\n\nimport sys\nfrom subprocess import check_call, CalledProcessError\nimport urllib\nfrom urllib.request import urlretrieve\nimport os\nfrom os.path import join as pathjoin, expanduser\n\nFAIL_COUNT = 0\nTEST_COUNT = 0\n_COLORS = {\n    \"FAIL\": \"\\033[1;31m\",\n    \"OK\": \"\\033[1;32m\",\n    \"STATUS\": \"\\033[1;37m\",\n    \"BOLD\": \"\\033[1m\",\n    \"ENDC\": \"\\033[0m\"\n}\n\n\ndef print_colored(text, color=\"OK\", bold=False):\n    \"\"\" Print colored text\n    This might not work on windows,\n    although travis runs windows stuff in git bash, so it might ?\n    \"\"\"\n    color = _COLORS.get(color, color)\n    fmt = '' if not bold else _COLORS['BOLD']\n    print(f\"{color}{fmt}{text}{_COLORS['ENDC']}\")\n\n\ndef print_ok(text):\n    \"\"\" Print ok in colored text \"\"\"\n    print_colored(text, \"OK\", True)\n\n\ndef print_fail(text):\n    \"\"\" Print fail in colored text \"\"\"\n    print_colored(text, \"FAIL\", True)\n\n\ndef print_status(text):\n    \"\"\" Print status in colored text \"\"\"\n    print_colored(text, \"STATUS\", True)\n\n\ndef run_test(name, cmd):\n    \"\"\" run a test \"\"\"\n    global FAIL_COUNT, TEST_COUNT  # pylint:disable=global-statement\n    print_status(f\"[?] running {name}\")\n    print(f\"Cmd: {' '.join(cmd)}\")\n    TEST_COUNT += 1\n    try:\n        check_call(cmd)\n        print_ok(\"[+] Test success\")\n        return True\n    except CalledProcessError as err:\n        print_fail(f\"[-] Test failed with {err}\")\n        FAIL_COUNT += 1\n        return False\n\n\ndef download_file(url, filename):  # TODO: retry\n    \"\"\" Download a file from given url \"\"\"\n    if os.path.isfile(filename):\n        print_status(f\"[?] '{url}' already cached as '{filename}'\")\n        return filename\n    try:\n        print_status(f\"[?] Downloading '{url}' to '{filename}'\")\n        video, _ = urlretrieve(url, filename)\n        return video\n    except urllib.error.URLError as err:\n        print_fail(f\"[-] Failed downloading: {err}\")\n        return None\n\n\ndef extract_args(detector, aligner, in_path, out_path, args=None):\n    \"\"\" Extraction command \"\"\"\n    py_exe = sys.executable\n    _extract_args = (f\"{py_exe} faceswap.py extract -i {in_path} -o {out_path} -D {detector} \"\n                     f\"-A {aligner}\")\n    if args:\n        _extract_args += f\" {args}\"\n    return _extract_args.split()\n\n\ndef train_args(model, model_path, faces, iterations=1, batchsize=2, extra_args=\"\"):\n    \"\"\" Train command \"\"\"\n    py_exe = sys.executable\n    args = (f\"{py_exe} faceswap.py train -A {faces} -B {faces} -m {model_path} -t {model} \"\n            f\"-b {batchsize} -i {iterations} {extra_args}\")\n    return args.split()\n\n\ndef convert_args(in_path, out_path, model_path, writer, args=None):\n    \"\"\" Convert command \"\"\"\n    py_exe = sys.executable\n    conv_args = (f\"{py_exe} faceswap.py convert -i {in_path} -o {out_path} -m {model_path} \"\n                 f\"-w {writer}\")\n    if args:\n        conv_args += f\" {args}\"\n    return conv_args.split()  # Don't use pathes with spaces ;)\n\n\ndef sort_args(in_path, out_path, sortby=\"face\", groupby=\"hist\"):\n    \"\"\" Sort command \"\"\"\n    py_exe = sys.executable\n    _sort_args = (f\"{py_exe} tools.py sort -i {in_path} -o {out_path} -s {sortby} -g {groupby} -k\")\n    return _sort_args.split()\n\n\ndef set_train_config(value):\n    \"\"\" Update the mixed_precision and autoclip values to given value\n\n    Parameters\n    ----------\n    value: bool\n        The value to set the config parameters to.\n    \"\"\"\n    old_val, new_val = (\"False\", \"True\") if value else (\"True\", \"False\")\n    base_path = os.path.split(os.path.dirname(os.path.abspath(__file__)))[0]\n    train_ini = os.path.join(base_path, \"config\", \"train.ini\")\n    try:\n        cmd = [\"sed\", \"-i\", f\"s/autoclip = {old_val}/autoclip = {new_val}/\", train_ini]\n        check_call(cmd)\n        cmd = [\"sed\",\n               \"-i\",\n               f\"s/mixed_precision = {old_val}/mixed_precision = {new_val}/\",\n               train_ini]\n        check_call(cmd)\n        print_ok(f\"Set autoclip and mixed_precision to `{new_val}`\")\n    except CalledProcessError as err:\n        print_fail(f\"[-] Test failed with {err}\")\n        return False\n\n\ndef main():\n    \"\"\" Main testing script \"\"\"\n    vid_src = \"https://faceswap.dev/data/test.mp4\"\n    img_src = \"https://archive.org/download/GPN-2003-00070/GPN-2003-00070.jpg\"\n    base_dir = pathjoin(expanduser(\"~\"), \"cache\", \"tests\")\n\n    vid_base = pathjoin(base_dir, \"vid\")\n    img_base = pathjoin(base_dir, \"imgs\")\n    os.makedirs(vid_base, exist_ok=True)\n    os.makedirs(img_base, exist_ok=True)\n    py_exe = sys.executable\n    was_trained = False\n\n    vid_path = download_file(vid_src, pathjoin(vid_base, \"test.mp4\"))\n    if not vid_path:\n        print_fail(\"[-] Aborting\")\n        sys.exit(1)\n    vid_extract = run_test(\n        \"Extraction video with cv2-dnn detector and cv2-dnn aligner.\",\n        extract_args(\"Cv2-Dnn\", \"Cv2-Dnn\", vid_path, pathjoin(vid_base, \"faces\"))\n    )\n\n    img_path = download_file(img_src, pathjoin(img_base, \"test_img.jpg\"))\n    if not img_path:\n        print_fail(\"[-] Aborting\")\n        sys.exit(1)\n    run_test(\n        \"Extraction images with cv2-dnn detector and cv2-dnn aligner.\",\n        extract_args(\"Cv2-Dnn\", \"Cv2-Dnn\", img_base, pathjoin(img_base, \"faces\"))\n    )\n\n    if vid_extract:\n        run_test(\n                \"Generate configs and test help output\",\n                (\n                    py_exe, \"faceswap.py\", \"-h\"\n                )\n        )\n        run_test(\n            \"Sort faces.\",\n            sort_args(\n                pathjoin(vid_base, \"faces\"), pathjoin(vid_base, \"faces_sorted\"),\n                sortby=\"face\"\n            )\n        )\n\n        run_test(\n            \"Rename sorted faces.\",\n            (\n                py_exe, \"tools.py\", \"alignments\", \"-j\", \"rename\",\n                \"-a\", pathjoin(vid_base, \"test_alignments.fsa\"),\n                \"-c\", pathjoin(vid_base, \"faces_sorted\"),\n            )\n        )\n        set_train_config(True)\n        run_test(\n            \"Train lightweight model for 1 iteration with WTL, AutoClip, MixedPrecion\",\n            train_args(\"lightweight\",\n                       pathjoin(vid_base, \"model\"),\n                       pathjoin(vid_base, \"faces\"),\n                       iterations=1,\n                       batchsize=1,\n                       extra_args=\"-M\"))\n\n        set_train_config(False)\n        was_trained = run_test(\n            \"Train lightweight model for 1 iterations WITHOUT WTL, AutoClip, MixedPrecion\",\n            train_args(\"lightweight\",\n                       pathjoin(vid_base, \"model\"),\n                       pathjoin(vid_base, \"faces\"),\n                       iterations=1,\n                       batchsize=1))\n\n    if was_trained:\n        run_test(\n            \"Convert video.\",\n            convert_args(\n                vid_path, pathjoin(vid_base, \"conv\"),\n                pathjoin(vid_base, \"model\"), \"ffmpeg\"\n            )\n        )\n\n        run_test(\n            \"Convert images.\",\n            convert_args(\n                img_base, pathjoin(img_base, \"conv\"),\n                pathjoin(vid_base, \"model\"), \"opencv\"\n            )\n        )\n\n    if FAIL_COUNT == 0:\n        print_ok(f\"[+] Failed {FAIL_COUNT}/{TEST_COUNT} tests.\")\n        sys.exit(0)\n    else:\n        print_fail(f\"[-] Failed {FAIL_COUNT}/{TEST_COUNT} tests.\")\n        sys.exit(1)\n\n\nif __name__ == '__main__':\n    main()\n", "file_name": "006394.py", "cwe": ["CWE-939: Improper Authorization in Handler for Custom URL Scheme"]}
{"source": "#!/usr/bin/env python\n\n#__all__ = ['pptv_download', 'pptv_download_by_id']\n\nfrom ..common import *\nfrom ..extractor import VideoExtractor\n\nimport re\nimport time\nimport urllib\nimport random\nimport binascii\nfrom xml.dom.minidom import parseString\n\n\ndef lshift(a, b):\n    return (a << b) & 0xffffffff\ndef rshift(a, b):\n    if a >= 0:\n        return a >> b\n    return (0x100000000 + a) >> b\n\ndef le32_pack(b_str):\n    result = 0\n    result |= b_str[0]\n    result |= (b_str[1] << 8)\n    result |= (b_str[2] << 16)\n    result |= (b_str[3] << 24)\n    return result\n\ndef tea_core(data, key_seg):\n    delta = 2654435769\n\n    d0 = le32_pack(data[:4])\n    d1 = le32_pack(data[4:8])\n\n    sum_ = 0\n    for rnd in range(32):\n        sum_ = (sum_ + delta) & 0xffffffff\n        p1 = (lshift(d1, 4) + key_seg[0]) & 0xffffffff\n        p2 = (d1 + sum_) & 0xffffffff\n        p3 = (rshift(d1, 5) + key_seg[1]) & 0xffffffff\n\n        mid_p = p1 ^ p2 ^ p3\n        d0 = (d0 + mid_p) & 0xffffffff\n\n        p4 = (lshift(d0, 4) + key_seg[2]) & 0xffffffff\n        p5 = (d0 + sum_) & 0xffffffff\n        p6 = (rshift(d0, 5) + key_seg[3]) & 0xffffffff\n\n        mid_p = p4 ^ p5 ^ p6\n        d1 = (d1 + mid_p) & 0xffffffff\n\n    return bytes(unpack_le32(d0) + unpack_le32(d1))\n\ndef ran_hex(size):\n    result = []\n    for i in range(size):\n        result.append(hex(int(15 * random.random()))[2:])\n    return ''.join(result)\n\ndef zpad(b_str, size):\n    size_diff = size - len(b_str)\n    return b_str + bytes(size_diff)\n\ndef gen_key(t):\n    key_seg = [1896220160,101056625, 100692230, 7407110]\n    t_s = hex(int(t))[2:].encode('utf8')\n    input_data = zpad(t_s, 16)\n    out = tea_core(input_data, key_seg)\n    return binascii.hexlify(out[:8]).decode('utf8') + ran_hex(16)\n\ndef unpack_le32(i32):\n    result = []\n    result.append(i32 & 0xff)\n    i32 = rshift(i32, 8)\n    result.append(i32 & 0xff)\n    i32 = rshift(i32, 8)\n    result.append(i32 & 0xff)\n    i32 = rshift(i32, 8)\n    result.append(i32 & 0xff)\n    return result\n\ndef get_elem(elem, tag):\n    return elem.getElementsByTagName(tag)\n\ndef get_attr(elem, attr):\n    return elem.getAttribute(attr)\n\ndef get_text(elem):\n    return elem.firstChild.nodeValue\n\ndef shift_time(time_str):\n    ts = time_str[:-4]\n    return time.mktime(time.strptime(ts)) - 60\n\ndef parse_pptv_xml(dom):\n    channel = get_elem(dom, 'channel')[0]\n    title = get_attr(channel, 'nm')\n    file_list = get_elem(channel, 'file')[0]\n    item_list = get_elem(file_list, 'item')\n    streams_cnt = len(item_list)\n    item_mlist = []\n    for item in item_list:\n        rid = get_attr(item, 'rid')\n        file_type = get_attr(item, 'ft')\n        size = get_attr(item, 'filesize')\n        width = get_attr(item, 'width')\n        height = get_attr(item, 'height')\n        bitrate = get_attr(item, 'bitrate')\n        res = '{}x{}@{}kbps'.format(width, height, bitrate)\n        item_meta = (file_type, rid, size, res)\n        item_mlist.append(item_meta)\n\n    dt_list = get_elem(dom, 'dt')\n    dragdata_list = get_elem(dom, 'dragdata')\n\n    stream_mlist = []\n    for dt in dt_list:\n        file_type = get_attr(dt, 'ft')\n        serv_time = get_text(get_elem(dt, 'st')[0])\n        expr_time = get_text(get_elem(dt, 'key')[0])\n        serv_addr = get_text(get_elem(dt, 'sh')[0])\n        stream_meta = (file_type, serv_addr, expr_time, serv_time)\n        stream_mlist.append(stream_meta)\n\n    segs_mlist = []\n    for dd in dragdata_list:\n        file_type = get_attr(dd, 'ft')\n        seg_list = get_elem(dd, 'sgm')\n        segs = []\n        segs_size = []\n        for seg in seg_list:\n            rid = get_attr(seg, 'rid')\n            size = get_attr(seg, 'fs')\n            segs.append(rid)\n            segs_size.append(size)\n        segs_meta = (file_type, segs, segs_size)\n        segs_mlist.append(segs_meta)\n    return title, item_mlist, stream_mlist, segs_mlist\n\n#mergs 3 meta_data\ndef merge_meta(item_mlist, stream_mlist, segs_mlist):\n    streams = {}\n    for i in range(len(segs_mlist)):\n        streams[str(i)] = {}\n\n    for item in item_mlist:\n        stream = streams[item[0]]\n        stream['rid'] = item[1]\n        stream['size'] = item[2]\n        stream['res'] = item[3]\n\n    for s in stream_mlist:\n        stream = streams[s[0]]\n        stream['serv_addr'] = s[1]\n        stream['expr_time'] = s[2]\n        stream['serv_time'] = s[3]\n\n    for seg in segs_mlist:\n        stream = streams[seg[0]]\n        stream['segs'] = seg[1]\n        stream['segs_size'] = seg[2]\n\n    return streams\n\n\ndef make_url(stream):\n    host = stream['serv_addr']\n    rid = stream['rid']\n    key = gen_key(shift_time(stream['serv_time']))\n    key_expr = stream['expr_time']\n\n    src = []\n    for i, seg in enumerate(stream['segs']):\n        url = 'http://{}/{}/{}?key={}&k={}'.format(host, i, rid, key, key_expr)\n        url += '&type=web.fpp'\n        src.append(url)\n    return src\n\nclass PPTV(VideoExtractor):\n    name = 'PPTV'\n    stream_types = [\n            {'itag': '4'},\n            {'itag': '3'},\n            {'itag': '2'},\n            {'itag': '1'},\n            {'itag': '0'},\n    ]\n\n    def prepare(self, **kwargs):\n        headers = {\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \"\n                          \"Chrome/69.0.3497.100 Safari/537.36\"\n        }\n        self.vid = match1(self.url, r'https?://sports.pptv.com/vod/(\\d+)/*')\n        if self.url and not self.vid:\n            if not re.match(r'https?://v.pptv.com/show/(\\w+)\\.html', self.url):\n                raise('Unknown url pattern')\n            page_content = get_content(self.url, headers)\n\n            self.vid = match1(page_content, r'webcfg\\s*=\\s*{\"id\":\\s*(\\d+)')\n            if not self.vid:\n                request = urllib.request.Request(self.url, headers=headers)\n                response = urllib.request.urlopen(request)\n                self.vid = match1(response.url, r'https?://sports.pptv.com/vod/(\\d+)/*')\n\n        if not self.vid:\n            raise('Cannot find id')\n        api_url = 'http://web-play.pptv.com/webplay3-0-{}.xml'.format(self.vid)\n        api_url += '?type=web.fpp&param=type=web.fpp&version=4'\n        dom = parseString(get_content(api_url, headers))\n        self.title, m_items, m_streams, m_segs = parse_pptv_xml(dom)\n        xml_streams = merge_meta(m_items, m_streams, m_segs)\n        for stream_id in xml_streams:\n            stream_data = xml_streams[stream_id]\n            src = make_url(stream_data)\n            self.streams[stream_id] = {\n                    'container': 'mp4',\n                    'video_profile': stream_data['res'],\n                    'size': int(stream_data['size']),\n                    'src': src\n            }\n\nsite = PPTV()\n#site_info = \"PPTV.com\"\n#download = pptv_download\ndownload = site.download_by_url\ndownload_playlist = playlist_not_supported('pptv')\n", "file_name": "454489.py", "cwe": ["CWE-939: Improper Authorization in Handler for Custom URL Scheme"]}
{"source": "import json\nimport shutil\nimport traceback\nfrom pathlib import Path\n\nimport numpy as np\n\nfrom core import pathex\nfrom core.cv2ex import *\nfrom core.interact import interact as io\nfrom core.leras import nn\nfrom DFLIMG import *\nfrom facelib import XSegNet, LandmarksProcessor, FaceType\nimport pickle\n\ndef apply_xseg(input_path, model_path):\n    if not input_path.exists():\n        raise ValueError(f'{input_path} not found. Please ensure it exists.')\n\n    if not model_path.exists():\n        raise ValueError(f'{model_path} not found. Please ensure it exists.')\n        \n    face_type = None\n    \n    model_dat = model_path / 'XSeg_data.dat'\n    if model_dat.exists():\n        dat = pickle.loads( model_dat.read_bytes() )\n        dat_options = dat.get('options', None)\n        if dat_options is not None:\n            face_type = dat_options.get('face_type', None)\n        \n        \n        \n    if face_type is None:\n        face_type = io.input_str (\"XSeg model face type\", 'same', ['h','mf','f','wf','head','same'], help_message=\"Specify face type of trained XSeg model. For example if XSeg model trained as WF, but faceset is HEAD, specify WF to apply xseg only on WF part of HEAD. Default is 'same'\").lower()\n        if face_type == 'same':\n            face_type = None\n    \n    if face_type is not None:\n        face_type = {'h'  : FaceType.HALF,\n                     'mf' : FaceType.MID_FULL,\n                     'f'  : FaceType.FULL,\n                     'wf' : FaceType.WHOLE_FACE,\n                     'head' : FaceType.HEAD}[face_type]\n                     \n    io.log_info(f'Applying trained XSeg model to {input_path.name}/ folder.')\n\n    device_config = nn.DeviceConfig.ask_choose_device(choose_only_one=True)\n    nn.initialize(device_config)\n        \n    \n    \n    xseg = XSegNet(name='XSeg', \n                    load_weights=True,\n                    weights_file_root=model_path,\n                    data_format=nn.data_format,\n                    raise_on_no_model_files=True)\n    xseg_res = xseg.get_resolution()\n              \n    images_paths = pathex.get_image_paths(input_path, return_Path_class=True)\n    \n    for filepath in io.progress_bar_generator(images_paths, \"Processing\"):\n        dflimg = DFLIMG.load(filepath)\n        if dflimg is None or not dflimg.has_data():\n            io.log_info(f'{filepath} is not a DFLIMG')\n            continue\n        \n        img = cv2_imread(filepath).astype(np.float32) / 255.0\n        h,w,c = img.shape\n        \n        img_face_type = FaceType.fromString( dflimg.get_face_type() )\n        if face_type is not None and img_face_type != face_type:\n            lmrks = dflimg.get_source_landmarks()\n            \n            fmat = LandmarksProcessor.get_transform_mat(lmrks, w, face_type)\n            imat = LandmarksProcessor.get_transform_mat(lmrks, w, img_face_type)\n            \n            g_p = LandmarksProcessor.transform_points (np.float32([(0,0),(w,0),(0,w) ]), fmat, True)\n            g_p2 = LandmarksProcessor.transform_points (g_p, imat)\n            \n            mat = cv2.getAffineTransform( g_p2, np.float32([(0,0),(w,0),(0,w) ]) )\n            \n            img = cv2.warpAffine(img, mat, (w, w), cv2.INTER_LANCZOS4)\n            img = cv2.resize(img, (xseg_res, xseg_res), interpolation=cv2.INTER_LANCZOS4)\n        else:\n            if w != xseg_res:\n                img = cv2.resize( img, (xseg_res,xseg_res), interpolation=cv2.INTER_LANCZOS4 )    \n                    \n        if len(img.shape) == 2:\n            img = img[...,None]            \n    \n        mask = xseg.extract(img)\n        \n        if face_type is not None and img_face_type != face_type:\n            mask = cv2.resize(mask, (w, w), interpolation=cv2.INTER_LANCZOS4)\n            mask = cv2.warpAffine( mask, mat, (w,w), np.zeros( (h,w,c), dtype=np.float), cv2.WARP_INVERSE_MAP | cv2.INTER_LANCZOS4)\n            mask = cv2.resize(mask, (xseg_res, xseg_res), interpolation=cv2.INTER_LANCZOS4)\n        mask[mask < 0.5]=0\n        mask[mask >= 0.5]=1    \n        dflimg.set_xseg_mask(mask)\n        dflimg.save()\n\n\n        \ndef fetch_xseg(input_path):\n    if not input_path.exists():\n        raise ValueError(f'{input_path} not found. Please ensure it exists.')\n    \n    output_path = input_path.parent / (input_path.name + '_xseg')\n    output_path.mkdir(exist_ok=True, parents=True)\n    \n    io.log_info(f'Copying faces containing XSeg polygons to {output_path.name}/ folder.')\n    \n    images_paths = pathex.get_image_paths(input_path, return_Path_class=True)\n    \n    \n    files_copied = []\n    for filepath in io.progress_bar_generator(images_paths, \"Processing\"):\n        dflimg = DFLIMG.load(filepath)\n        if dflimg is None or not dflimg.has_data():\n            io.log_info(f'{filepath} is not a DFLIMG')\n            continue\n        \n        ie_polys = dflimg.get_seg_ie_polys()\n\n        if ie_polys.has_polys():\n            files_copied.append(filepath)\n            shutil.copy ( str(filepath), str(output_path / filepath.name) )\n    \n    io.log_info(f'Files copied: {len(files_copied)}')\n    \n    is_delete = io.input_bool (f\"\\r\\nDelete original files?\", True)\n    if is_delete:\n        for filepath in files_copied:\n            Path(filepath).unlink()\n            \n    \ndef remove_xseg(input_path):\n    if not input_path.exists():\n        raise ValueError(f'{input_path} not found. Please ensure it exists.')\n    \n    io.log_info(f'Processing folder {input_path}')\n    io.log_info('!!! WARNING : APPLIED XSEG MASKS WILL BE REMOVED FROM THE FRAMES !!!')\n    io.log_info('!!! WARNING : APPLIED XSEG MASKS WILL BE REMOVED FROM THE FRAMES !!!')\n    io.log_info('!!! WARNING : APPLIED XSEG MASKS WILL BE REMOVED FROM THE FRAMES !!!')\n    io.input_str('Press enter to continue.')\n                               \n    images_paths = pathex.get_image_paths(input_path, return_Path_class=True)\n    \n    files_processed = 0\n    for filepath in io.progress_bar_generator(images_paths, \"Processing\"):\n        dflimg = DFLIMG.load(filepath)\n        if dflimg is None or not dflimg.has_data():\n            io.log_info(f'{filepath} is not a DFLIMG')\n            continue\n        \n        if dflimg.has_xseg_mask():\n            dflimg.set_xseg_mask(None)\n            dflimg.save()\n            files_processed += 1\n    io.log_info(f'Files processed: {files_processed}')\n    \ndef remove_xseg_labels(input_path):\n    if not input_path.exists():\n        raise ValueError(f'{input_path} not found. Please ensure it exists.')\n    \n    io.log_info(f'Processing folder {input_path}')\n    io.log_info('!!! WARNING : LABELED XSEG POLYGONS WILL BE REMOVED FROM THE FRAMES !!!')\n    io.log_info('!!! WARNING : LABELED XSEG POLYGONS WILL BE REMOVED FROM THE FRAMES !!!')\n    io.log_info('!!! WARNING : LABELED XSEG POLYGONS WILL BE REMOVED FROM THE FRAMES !!!')\n    io.input_str('Press enter to continue.')\n    \n    images_paths = pathex.get_image_paths(input_path, return_Path_class=True)\n    \n    files_processed = 0\n    for filepath in io.progress_bar_generator(images_paths, \"Processing\"):\n        dflimg = DFLIMG.load(filepath)\n        if dflimg is None or not dflimg.has_data():\n            io.log_info(f'{filepath} is not a DFLIMG')\n            continue\n\n        if dflimg.has_seg_ie_polys():\n            dflimg.set_seg_ie_polys(None)\n            dflimg.save()            \n            files_processed += 1\n            \n    io.log_info(f'Files processed: {files_processed}')", "file_name": "494107.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\n@Time    : 2023/5/11 17:46\n@Author  : alexanderwu\n@File    : run_code.py\n@Modified By: mashenquan, 2023/11/27.\n            1. Mark the location of Console logs in the PROMPT_TEMPLATE with markdown code-block formatting to enhance\n            the understanding for the LLM.\n            2. Fix bug: Add the \"install dependency\" operation.\n            3. Encapsulate the input of RunCode into RunCodeContext and encapsulate the output of RunCode into\n            RunCodeResult to standardize and unify parameter passing between WriteCode, RunCode, and DebugError.\n            4. According to section 2.2.3.5.7 of RFC 135, change the method of transferring file content\n            (code files, unit test files, log files) from using the message to using the file name.\n            5. Merged the `Config` class of send18:dev branch to take over the set/get operations of the Environment\n            class.\n\"\"\"\nimport subprocess\nfrom pathlib import Path\nfrom typing import Tuple\n\nfrom pydantic import Field\n\nfrom metagpt.actions.action import Action\nfrom metagpt.logs import logger\nfrom metagpt.schema import RunCodeContext, RunCodeResult\nfrom metagpt.utils.exceptions import handle_exception\n\nPROMPT_TEMPLATE = \"\"\"\nRole: You are a senior development and qa engineer, your role is summarize the code running result.\nIf the running result does not include an error, you should explicitly approve the result.\nOn the other hand, if the running result indicates some error, you should point out which part, the development code or the test code, produces the error,\nand give specific instructions on fixing the errors. Here is the code info:\n{context}\nNow you should begin your analysis\n---\n## instruction:\nPlease summarize the cause of the errors and give correction instruction\n## File To Rewrite:\nDetermine the ONE file to rewrite in order to fix the error, for example, xyz.py, or test_xyz.py\n## Status:\nDetermine if all of the code works fine, if so write PASS, else FAIL,\nWRITE ONLY ONE WORD, PASS OR FAIL, IN THIS SECTION\n## Send To:\nPlease write NoOne if there are no errors, Engineer if the errors are due to problematic development codes, else QaEngineer,\nWRITE ONLY ONE WORD, NoOne OR Engineer OR QaEngineer, IN THIS SECTION.\n---\nYou should fill in necessary instruction, status, send to, and finally return all content between the --- segment line.\n\"\"\"\n\nTEMPLATE_CONTEXT = \"\"\"\n## Development Code File Name\n{code_file_name}\n## Development Code\n```python\n{code}\n```\n## Test File Name\n{test_file_name}\n## Test Code\n```python\n{test_code}\n```\n## Running Command\n{command}\n## Running Output\nstandard output: \n```text\n{outs}\n```\nstandard errors: \n```text\n{errs}\n```\n\"\"\"\n\n\nclass RunCode(Action):\n    name: str = \"RunCode\"\n    i_context: RunCodeContext = Field(default_factory=RunCodeContext)\n\n    @classmethod\n    async def run_text(cls, code) -> Tuple[str, str]:\n        try:\n            # We will document_store the result in this dictionary\n            namespace = {}\n            exec(code, namespace)\n        except Exception as e:\n            return \"\", str(e)\n        return namespace.get(\"result\", \"\"), \"\"\n\n    async def run_script(self, working_directory, additional_python_paths=[], command=[]) -> Tuple[str, str]:\n        working_directory = str(working_directory)\n        additional_python_paths = [str(path) for path in additional_python_paths]\n\n        # Copy the current environment variables\n        env = self.context.new_environ()\n\n        # Modify the PYTHONPATH environment variable\n        additional_python_paths = [working_directory] + additional_python_paths\n        additional_python_paths = \":\".join(additional_python_paths)\n        env[\"PYTHONPATH\"] = additional_python_paths + \":\" + env.get(\"PYTHONPATH\", \"\")\n        RunCode._install_dependencies(working_directory=working_directory, env=env)\n\n        # Start the subprocess\n        process = subprocess.Popen(\n            command, cwd=working_directory, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env\n        )\n        logger.info(\" \".join(command))\n\n        try:\n            # Wait for the process to complete, with a timeout\n            stdout, stderr = process.communicate(timeout=10)\n        except subprocess.TimeoutExpired:\n            logger.info(\"The command did not complete within the given timeout.\")\n            process.kill()  # Kill the process if it times out\n            stdout, stderr = process.communicate()\n        return stdout.decode(\"utf-8\"), stderr.decode(\"utf-8\")\n\n    async def run(self, *args, **kwargs) -> RunCodeResult:\n        logger.info(f\"Running {' '.join(self.i_context.command)}\")\n        if self.i_context.mode == \"script\":\n            outs, errs = await self.run_script(\n                command=self.i_context.command,\n                working_directory=self.i_context.working_directory,\n                additional_python_paths=self.i_context.additional_python_paths,\n            )\n        elif self.i_context.mode == \"text\":\n            outs, errs = await self.run_text(code=self.i_context.code)\n\n        logger.info(f\"{outs=}\")\n        logger.info(f\"{errs=}\")\n\n        context = TEMPLATE_CONTEXT.format(\n            code=self.i_context.code,\n            code_file_name=self.i_context.code_filename,\n            test_code=self.i_context.test_code,\n            test_file_name=self.i_context.test_filename,\n            command=\" \".join(self.i_context.command),\n            outs=outs[:500],  # outs might be long but they are not important, truncate them to avoid token overflow\n            errs=errs[:10000],  # truncate errors to avoid token overflow\n        )\n\n        prompt = PROMPT_TEMPLATE.format(context=context)\n        rsp = await self._aask(prompt)\n        return RunCodeResult(summary=rsp, stdout=outs, stderr=errs)\n\n    @staticmethod\n    @handle_exception(exception_type=subprocess.CalledProcessError)\n    def _install_via_subprocess(cmd, check, cwd, env):\n        return subprocess.run(cmd, check=check, cwd=cwd, env=env)\n\n    @staticmethod\n    def _install_requirements(working_directory, env):\n        file_path = Path(working_directory) / \"requirements.txt\"\n        if not file_path.exists():\n            return\n        if file_path.stat().st_size == 0:\n            return\n        install_command = [\"python\", \"-m\", \"pip\", \"install\", \"-r\", \"requirements.txt\"]\n        logger.info(\" \".join(install_command))\n        RunCode._install_via_subprocess(install_command, check=True, cwd=working_directory, env=env)\n\n    @staticmethod\n    def _install_pytest(working_directory, env):\n        install_pytest_command = [\"python\", \"-m\", \"pip\", \"install\", \"pytest\"]\n        logger.info(\" \".join(install_pytest_command))\n        RunCode._install_via_subprocess(install_pytest_command, check=True, cwd=working_directory, env=env)\n\n    @staticmethod\n    def _install_dependencies(working_directory, env):\n        RunCode._install_requirements(working_directory, env)\n        RunCode._install_pytest(working_directory, env)\n", "file_name": "173324.py", "cwe": ["CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"]}
{"source": "# -*- coding: utf-8 -*-\n# @Date    : 12/23/2023 4:51 PM\n# @Author  : stellahong (stellahong@fuzhi.ai)\n# @Desc    :\nfrom __future__ import annotations\n\nimport asyncio\nfrom typing import Any, List, Optional\n\nfrom pydantic import BaseModel, ConfigDict, Field\n\nfrom metagpt.llm import LLM\nfrom metagpt.logs import logger\nfrom metagpt.provider.base_llm import BaseLLM\nfrom metagpt.strategy.base import ThoughtNode, ThoughtTree\nfrom metagpt.strategy.tot_schema import MethodSelect, Strategy, ThoughtSolverConfig\nfrom metagpt.utils.common import CodeParser\n\nOUTPUT_FORMAT = \"\"\"\nEach output should be strictly a list of nodes, in json format, like this:\n```json\n    [\n        {\n            \"node_id\": str = \"unique identifier for a solution, can be an ordinal\",\n            \"node_state_instruction\": \"specified sample of solution\",\n        },\n        ...\n    ]\n```\n\"\"\"\n\n\nclass ThoughtSolverBase(BaseModel):\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    thought_tree: Optional[ThoughtTree] = Field(default=None)\n    llm: BaseLLM = Field(default_factory=LLM, exclude=True)\n    config: ThoughtSolverConfig = Field(default_factory=ThoughtSolverConfig)\n\n    def __init__(self, **kwargs: Any):\n        super().__init__(**kwargs)\n        self.llm.use_system_prompt = False\n\n    async def solve(self, init_prompt):\n        \"\"\"\n        Solve method for subclasses to implement.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement the solve method\")\n\n    async def generate_thoughts(self, current_state=\"\", current_node=None) -> List[ThoughtNode]:\n        \"\"\"\n        Generate children thoughts based on the current state.\n\n        Args:\n            current_state (str): The current state for which thoughts are generated.\n            current_node (ThoughtNode): The current node in the thought tree.\n\n        Returns:\n            List[ThoughtNode]: List of nodes representing the generated thoughts.\n        \"\"\"\n        state_prompt = self.config.parser.propose(\n            current_state=current_state, **{\"n_generate_sample\": self.config.n_generate_sample}\n        )\n        rsp = await self.llm.aask(msg=state_prompt + \"\\n\" + OUTPUT_FORMAT)\n        thoughts = CodeParser.parse_code(block=\"\", text=rsp)\n        thoughts = eval(thoughts)\n        # fixme \u907f\u514d\u4e0d\u8ddf\u968f\uff0c\u751f\u6210\u8fc7\u591anodes\n        # valid_thoughts = [_node for idx, _node in enumerate(thoughts) if idx < self.n_generate_sample]\n        return self.thought_tree.update_node(thoughts, current_node=current_node)\n\n    async def evaluate_node(self, node, parent_value) -> None:\n        \"\"\"\n        Evaluate a node and update its status and value.\n\n        Args:\n            node (ThoughtNode): The node to be evaluated.\n            parent_value (float): The parent node's value.\n\n        Returns:\n            None\n        \"\"\"\n        eval_prompt = self.config.parser.value(input=node.name, **{\"node_id\": node.id})\n        evaluation = await self.llm.aask(msg=eval_prompt)\n\n        value = self.config.evaluator(evaluation, **{\"node_id\": node.id})\n        status = self.config.evaluator.status_verify(value)\n\n        node.update_valid_status(status=status)\n        # \u7d2f\u8ba1\u5206\u6570\n        node.update_value(parent_value + value)\n\n    def select_nodes(self, thought_nodes: List[ThoughtNode]) -> List[ThoughtNode]:\n        \"\"\"\n        Select nodes based on the configured selection method.\n\n        Args:\n            thought_nodes (List[ThoughtNode]): List of nodes to be selected.\n\n        Returns:\n            List[ThoughtNode]: List of selected nodes.\n        \"\"\"\n        # nodes to be selected\n        nodes = []\n        if self.config.method_select == MethodSelect.SAMPLE:\n            raise NotImplementedError\n        elif self.config.method_select == MethodSelect.GREEDY:\n            nodes = sorted(thought_nodes, key=lambda x: x.value, reverse=True)[: self.config.n_select_sample]\n        for node in thought_nodes:\n            if node not in nodes:\n                node.parent = None  # \u4ece\u6811\u4e2d\u5220\u9664\u8282\u70b9\n        return nodes\n\n    def update_solution(self):\n        \"\"\"\n        Select the result with the highest score.\n\n        Returns:\n            - List[ThoughtNode]: List of nodes representing the best solution.\n            - List[str]: List of node names forming the best solution path.\n        \"\"\"\n        best_node = max(self.thought_tree.all_nodes, key=lambda x: x.value, default=None)\n        best_solution_path = self.thought_tree.parse_node_path(best_node)\n        return [best_node], best_solution_path\n\n\nclass BFSSolver(ThoughtSolverBase):\n    async def solve(self, init_prompt=\"\"):\n        \"\"\"\n        Solve the problem using Breadth-First Search (BFS) strategy.\n\n        Args:\n            init_prompt (str): The initial prompt for the solver.\n\n        Returns:\n            List[str]: The best solution path obtained through BFS.\n        \"\"\"\n        root = ThoughtNode(init_prompt)\n        self.thought_tree = ThoughtTree(root)\n        current_nodes = [root]\n        for step in range(self.config.max_steps):\n            solutions = await self._bfs_build(current_nodes)\n\n            selected_nodes = self.select_nodes(solutions)\n            current_nodes = selected_nodes\n\n            self.thought_tree.show()\n\n        best_solution, best_solution_path = self.update_solution()\n        logger.info(f\"best solution is: {best_solution_path}\")\n        return best_solution_path\n\n    async def _bfs_build(self, current_nodes):\n        \"\"\"\n        Build the thought tree using Breadth-First Search (BFS) strategy.\n\n        Args:\n            current_nodes (List[ThoughtNode]): Current nodes to expand.\n\n        Returns:\n            List[ThoughtNode]: The solutions obtained after expanding the current nodes.\n        \"\"\"\n        tasks = []\n        for node in current_nodes:\n            current_state = self.config.parser(node.name)\n            current_value = node.value\n            tasks.append(self.generate_and_evaluate_nodes(current_state, current_value, node))\n\n        thought_nodes_list = await asyncio.gather(*tasks)\n        solutions = [child_node for thought_nodes in thought_nodes_list for child_node in thought_nodes]\n        return solutions\n\n    async def generate_and_evaluate_nodes(self, current_state, current_value, node):\n        thought_nodes = await self.generate_thoughts(current_state, current_node=node)\n        await asyncio.gather(\n            *(self.evaluate_node(child_node, parent_value=current_value) for child_node in thought_nodes)\n        )\n        return thought_nodes\n\n\nclass DFSSolver(ThoughtSolverBase):\n    async def _dfs(self, root_node):\n        \"\"\"\n        Perform Depth-First Search (DFS) on the thought tree.\n\n        Args:\n            root_node (ThoughtNode): The root node of the thought tree.\n\n        Returns:\n            List[str]: The solution path obtained through DFS.\n        \"\"\"\n        impossible_state_cnt = 0\n        node = root_node\n        for step in range(self.max_steps):\n            current_state = self.config.parser(node.name)\n            current_value = node.value\n            thought_nodes = await self.generate_thoughts(current_state, current_node=node)\n            await self.evaluate_node(thought_nodes[0], parent_value=current_value)\n            if thought_nodes[0].valid_status is False:\n                impossible_state_cnt += 1\n            if impossible_state_cnt >= 2:\n                logger.info(\"impossible state reached, break\")\n                break\n            node = thought_nodes[0]\n        _solution_path = self.thought_tree.parse_node_path(node)\n        self.thought_tree.show()\n\n        return _solution_path\n\n    async def solve(self, init_prompt=\"\", root=ThoughtNode(\"\")):\n        \"\"\"\n        Solve the problem using Depth-First Search (DFS) strategy.\n\n        Args:\n            init_prompt (str): The initial prompt for the solver.\n\n        Returns:\n            List[str]: The best solution path obtained through DFS.\n        \"\"\"\n        root = ThoughtNode(init_prompt)\n        self.thought_tree = ThoughtTree(root)\n        for n in range(self.config.n_solution_sample):\n            # fixme: \u9700\u8981\u4ea7\u751f\u56de\u9000\uff0c\u5f53\u524d\u8282\u70b9\u4e0d\u53ef\u7528\u65f6\u56de\u9000\u5230\u7236\u8282\u70b9\uff0c\u4ea7\u751f\u65b0\u7684\u8282\u70b9\u7ee7\u7eed\u63a2\u7d22\n            await self._dfs(root)\n\n        best_solution, best_solution_path = self.update_solution()\n        logger.info(f\"best solution is: {best_solution_path}\")\n        return best_solution_path\n\n\nclass MCTSSolver(ThoughtSolverBase):\n    async def solve(self, init_prompt=\"\"):\n        raise NotImplementedError\n\n\nclass TreeofThought(BaseModel):\n    config: ThoughtSolverConfig = Field(default_factory=ThoughtSolverConfig)\n    solver: ThoughtSolverBase = Field(default_factory=ThoughtSolverBase)\n    strategy: Strategy = Field(default=Strategy.BFS)\n\n    class Config:\n        arbitrary_types_allowed = True\n\n    def __init__(self, **kwargs: Any):\n        super().__init__(**kwargs)\n        self._initialize_solver(self.strategy)\n\n    def _initialize_solver(self, strategy):\n        \"\"\"\n        Initialize the solver based on the chosen strategy.\n\n        Args:\n            strategy (Strategy): The strategy to use for solving.\n\n        Returns:\n            ThoughtSolverBase: An instance of the appropriate solver.\n        \"\"\"\n        if strategy == Strategy.BFS:\n            self.solver = BFSSolver(config=self.config)\n        elif strategy == Strategy.DFS:\n            self.solver = DFSSolver(config=self.config)\n        elif strategy == Strategy.MCTS:\n            self.solver = MCTSSolver(config=self.config)\n        else:\n            raise NotImplementedError(f\"Invalid strategy: {strategy}, only support BFS/DFS/MCTS currently!\")\n\n    async def solve(self, init_prompt=\"\"):\n        \"\"\"\n        Solve the problem using the specified strategy.\n\n        Args:\n            init_prompt (str): The initial prompt for the solver.\n            strategy (str): The strategy to use for solving.\n\n        Returns:\n            Any: The solution obtained using the selected strategy.\n        \"\"\"\n        await self.solver.solve(init_prompt)\n", "file_name": "387722.py", "cwe": ["CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"]}
{"source": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\n@Time    : 2023/4/29 16:19\n@Author  : alexanderwu\n@File    : test_common.py\n@Modified by: mashenquan, 2023/11/21. Add unit tests.\n\"\"\"\nimport importlib\nimport os\nimport platform\nimport uuid\nfrom pathlib import Path\nfrom typing import Any, Set\n\nimport pytest\nfrom pydantic import BaseModel\n\nfrom metagpt.actions import RunCode\nfrom metagpt.const import get_metagpt_root\nfrom metagpt.roles.tutorial_assistant import TutorialAssistant\nfrom metagpt.schema import Message\nfrom metagpt.utils.common import (\n    NoMoneyException,\n    OutputParser,\n    any_to_str,\n    any_to_str_set,\n    aread,\n    awrite,\n    check_cmd_exists,\n    concat_namespace,\n    import_class_inst,\n    parse_recipient,\n    print_members,\n    read_file_block,\n    read_json_file,\n    require_python_version,\n    split_namespace,\n)\n\n\nclass TestGetProjectRoot:\n    def change_etc_dir(self):\n        # current_directory = Path.cwd()\n        abs_root = \"/etc\"\n        os.chdir(abs_root)\n\n    def test_get_project_root(self):\n        project_root = get_metagpt_root()\n        src_path = project_root / \"metagpt\"\n        assert src_path.exists()\n\n    def test_get_root_exception(self):\n        self.change_etc_dir()\n        project_root = get_metagpt_root()\n        assert project_root\n\n    def test_any_to_str(self):\n        class Input(BaseModel):\n            x: Any = None\n            want: str\n\n        inputs = [\n            Input(x=TutorialAssistant, want=\"metagpt.roles.tutorial_assistant.TutorialAssistant\"),\n            Input(x=TutorialAssistant(), want=\"metagpt.roles.tutorial_assistant.TutorialAssistant\"),\n            Input(x=RunCode, want=\"metagpt.actions.run_code.RunCode\"),\n            Input(x=RunCode(), want=\"metagpt.actions.run_code.RunCode\"),\n            Input(x=Message, want=\"metagpt.schema.Message\"),\n            Input(x=Message(content=\"\"), want=\"metagpt.schema.Message\"),\n            Input(x=\"A\", want=\"A\"),\n        ]\n        for i in inputs:\n            v = any_to_str(i.x)\n            assert v == i.want\n\n    def test_any_to_str_set(self):\n        class Input(BaseModel):\n            x: Any = None\n            want: Set\n\n        inputs = [\n            Input(\n                x=[TutorialAssistant, RunCode(), \"a\"],\n                want={\"metagpt.roles.tutorial_assistant.TutorialAssistant\", \"metagpt.actions.run_code.RunCode\", \"a\"},\n            ),\n            Input(\n                x={TutorialAssistant, \"a\"},\n                want={\"metagpt.roles.tutorial_assistant.TutorialAssistant\", \"a\"},\n            ),\n            Input(\n                x=(TutorialAssistant, RunCode(), \"a\"),\n                want={\"metagpt.roles.tutorial_assistant.TutorialAssistant\", \"metagpt.actions.run_code.RunCode\", \"a\"},\n            ),\n            Input(\n                x={\"a\": TutorialAssistant, \"b\": RunCode(), \"c\": \"a\"},\n                want={\"a\", \"metagpt.roles.tutorial_assistant.TutorialAssistant\", \"metagpt.actions.run_code.RunCode\"},\n            ),\n        ]\n        for i in inputs:\n            v = any_to_str_set(i.x)\n            assert v == i.want\n\n    def test_check_cmd_exists(self):\n        class Input(BaseModel):\n            command: str\n            platform: str\n\n        inputs = [\n            {\"command\": \"cat\", \"platform\": \"linux\"},\n            {\"command\": \"ls\", \"platform\": \"linux\"},\n            {\"command\": \"mspaint\", \"platform\": \"windows\"},\n        ]\n        plat = \"windows\" if platform.system().lower() == \"windows\" else \"linux\"\n        for i in inputs:\n            seed = Input(**i)\n            result = check_cmd_exists(seed.command)\n            if plat == seed.platform:\n                assert result == 0\n            else:\n                assert result != 0\n\n    @pytest.mark.parametrize((\"filename\", \"want\"), [(\"1.md\", \"File list\"), (\"2.md\", \"Language\"), (\"3.md\", \"# TODOs\")])\n    @pytest.mark.asyncio\n    async def test_parse_data_exception(self, filename, want):\n        pathname = Path(__file__).parent.parent.parent / \"data/output_parser\" / filename\n        assert pathname.exists()\n        data = await aread(filename=pathname)\n        result = OutputParser.parse_data(data=data)\n        assert want in result\n\n    @pytest.mark.parametrize(\n        (\"ver\", \"want\", \"err\"), [((1, 2, 3, 4), False, True), ((2, 3, 9), True, False), ((3, 10, 18), False, False)]\n    )\n    def test_require_python_version(self, ver, want, err):\n        try:\n            res = require_python_version(ver)\n            assert res == want\n        except ValueError:\n            assert err\n\n    def test_no_money_exception(self):\n        val = NoMoneyException(3.10)\n        assert \"Amount required:\" in str(val)\n\n    @pytest.mark.parametrize(\"module_path\", [\"tests.metagpt.utils.test_common\"])\n    def test_print_members(self, module_path):\n        module = importlib.import_module(module_path)\n        with pytest.raises(Exception) as info:\n            print_members(module)\n            assert info is None\n\n    @pytest.mark.parametrize(\n        (\"words\", \"want\"), [(\"\", \"\"), (\"## Send To: Engineer\", \"Engineer\"), (\"Send To: \\nNone\", \"None\")]\n    )\n    def test_parse_recipient(self, words, want):\n        res = parse_recipient(words)\n        assert want == res\n\n    def test_concat_namespace(self):\n        assert concat_namespace(\"a\", \"b\", \"c\") == \"a:b:c\"\n        assert concat_namespace(\"a\", \"b\", \"c\", \"e\") == \"a:b:c:e\"\n        assert concat_namespace(\"a\", \"b\", \"c\", \"e\", \"f\") == \"a:b:c:e:f\"\n\n    @pytest.mark.parametrize(\n        (\"val\", \"want\"),\n        [\n            (\n                \"tests/metagpt/test_role.py:test_react:Input:subscription\",\n                [\"tests/metagpt/test_role.py\", \"test_react\", \"Input\", \"subscription\"],\n            ),\n            (\n                \"tests/metagpt/test_role.py:test_react:Input:goal\",\n                [\"tests/metagpt/test_role.py\", \"test_react\", \"Input\", \"goal\"],\n            ),\n        ],\n    )\n    def test_split_namespace(self, val, want):\n        res = split_namespace(val, maxsplit=-1)\n        assert res == want\n\n    def test_read_json_file(self):\n        assert read_json_file(str(Path(__file__).parent / \"../../data/ut_writer/yft_swaggerApi.json\"), encoding=\"utf-8\")\n        with pytest.raises(FileNotFoundError):\n            read_json_file(\"not_exists_file\", encoding=\"utf-8\")\n        with pytest.raises(ValueError):\n            read_json_file(__file__, encoding=\"utf-8\")\n\n    def test_import_class_inst(self):\n        rc = import_class_inst(\"RunCode\", \"metagpt.actions.run_code\", name=\"X\")\n        assert rc.name == \"X\"\n\n    @pytest.mark.asyncio\n    async def test_read_file_block(self):\n        assert await read_file_block(filename=__file__, lineno=6, end_lineno=6) == \"@File    : test_common.py\\n\"\n\n    @pytest.mark.asyncio\n    async def test_read_write(self):\n        pathname = Path(__file__).parent / f\"../../../workspace/unittest/{uuid.uuid4().hex}\" / \"test.tmp\"\n        await awrite(pathname, \"ABC\")\n        data = await aread(pathname)\n        assert data == \"ABC\"\n        pathname.unlink(missing_ok=True)\n\n    @pytest.mark.asyncio\n    async def test_read_write_error_charset(self):\n        pathname = Path(__file__).parent / f\"../../../workspace/unittest/{uuid.uuid4().hex}\" / \"test.txt\"\n        content = \"\u4e2d\u56fdabc123\\u27f6\"\n        await awrite(filename=pathname, data=content)\n        data = await aread(filename=pathname)\n        assert data == content\n\n        content = \"GB18030 \u662f\u4e2d\u56fd\u56fd\u5bb6\u6807\u51c6\u5c40\u53d1\u5e03\u7684\u65b0\u4e00\u4ee3\u4e2d\u6587\u5b57\u7b26\u96c6\u6807\u51c6\uff0c\u662f GBK \u7684\u5347\u7ea7\u7248\uff0c\u652f\u6301\u66f4\u5e7f\u6cdb\u7684\u5b57\u7b26\u8303\u56f4\u3002\"\n        await awrite(filename=pathname, data=content, encoding=\"gb2312\")\n        data = await aread(filename=pathname, encoding=\"utf-8\")\n        assert data == content\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-s\"])\n", "file_name": "082256.py", "cwe": ["CWE-706: Use of Incorrectly-Resolved Name or Reference"]}
{"source": "from __future__ import annotations\n\nimport importlib\nimport sys\nfrom typing import (\n    TYPE_CHECKING,\n    Literal,\n    overload,\n)\nimport warnings\n\nfrom pandas.util._exceptions import find_stack_level\n\nfrom pandas.util.version import Version\n\nif TYPE_CHECKING:\n    import types\n\n# Update install.rst, actions-310-minimum_versions.yaml,\n# deps_minimum.toml & pyproject.toml when updating versions!\n\nVERSIONS = {\n    \"adbc-driver-postgresql\": \"0.10.0\",\n    \"adbc-driver-sqlite\": \"0.8.0\",\n    \"bs4\": \"4.11.2\",\n    \"blosc\": \"1.21.3\",\n    \"bottleneck\": \"1.3.6\",\n    \"fastparquet\": \"2023.10.0\",\n    \"fsspec\": \"2022.11.0\",\n    \"html5lib\": \"1.1\",\n    \"hypothesis\": \"6.84.0\",\n    \"gcsfs\": \"2022.11.0\",\n    \"jinja2\": \"3.1.2\",\n    \"lxml.etree\": \"4.9.2\",\n    \"matplotlib\": \"3.6.3\",\n    \"numba\": \"0.56.4\",\n    \"numexpr\": \"2.8.4\",\n    \"odfpy\": \"1.4.1\",\n    \"openpyxl\": \"3.1.0\",\n    \"psycopg2\": \"2.9.6\",  # (dt dec pq3 ext lo64)\n    \"pymysql\": \"1.0.2\",\n    \"pyarrow\": \"10.0.1\",\n    \"pyreadstat\": \"1.2.0\",\n    \"pytest\": \"7.3.2\",\n    \"python-calamine\": \"0.1.7\",\n    \"pytz\": \"2023.4\",\n    \"pyxlsb\": \"1.0.10\",\n    \"s3fs\": \"2022.11.0\",\n    \"scipy\": \"1.10.0\",\n    \"sqlalchemy\": \"2.0.0\",\n    \"tables\": \"3.8.0\",\n    \"tabulate\": \"0.9.0\",\n    \"xarray\": \"2022.12.0\",\n    \"xlrd\": \"2.0.1\",\n    \"xlsxwriter\": \"3.0.5\",\n    \"zstandard\": \"0.19.0\",\n    \"tzdata\": \"2022.7\",\n    \"qtpy\": \"2.3.0\",\n    \"pyqt5\": \"5.15.9\",\n}\n\n# A mapping from import name to package name (on PyPI) for packages where\n# these two names are different.\n\nINSTALL_MAPPING = {\n    \"bs4\": \"beautifulsoup4\",\n    \"bottleneck\": \"Bottleneck\",\n    \"jinja2\": \"Jinja2\",\n    \"lxml.etree\": \"lxml\",\n    \"odf\": \"odfpy\",\n    \"python_calamine\": \"python-calamine\",\n    \"sqlalchemy\": \"SQLAlchemy\",\n    \"tables\": \"pytables\",\n}\n\n\ndef get_version(module: types.ModuleType) -> str:\n    version = getattr(module, \"__version__\", None)\n\n    if version is None:\n        raise ImportError(f\"Can't determine version for {module.__name__}\")\n    if module.__name__ == \"psycopg2\":\n        # psycopg2 appends \" (dt dec pq3 ext lo64)\" to it's version\n        version = version.split()[0]\n    return version\n\n\n@overload\ndef import_optional_dependency(\n    name: str,\n    extra: str = ...,\n    min_version: str | None = ...,\n    *,\n    errors: Literal[\"raise\"] = ...,\n) -> types.ModuleType: ...\n\n\n@overload\ndef import_optional_dependency(\n    name: str,\n    extra: str = ...,\n    min_version: str | None = ...,\n    *,\n    errors: Literal[\"warn\", \"ignore\"],\n) -> types.ModuleType | None: ...\n\n\ndef import_optional_dependency(\n    name: str,\n    extra: str = \"\",\n    min_version: str | None = None,\n    *,\n    errors: Literal[\"raise\", \"warn\", \"ignore\"] = \"raise\",\n) -> types.ModuleType | None:\n    \"\"\"\n    Import an optional dependency.\n\n    By default, if a dependency is missing an ImportError with a nice\n    message will be raised. If a dependency is present, but too old,\n    we raise.\n\n    Parameters\n    ----------\n    name : str\n        The module name.\n    extra : str\n        Additional text to include in the ImportError message.\n    errors : str {'raise', 'warn', 'ignore'}\n        What to do when a dependency is not found or its version is too old.\n\n        * raise : Raise an ImportError\n        * warn : Only applicable when a module's version is to old.\n          Warns that the version is too old and returns None\n        * ignore: If the module is not installed, return None, otherwise,\n          return the module, even if the version is too old.\n          It's expected that users validate the version locally when\n          using ``errors=\"ignore\"`` (see. ``io/html.py``)\n    min_version : str, default None\n        Specify a minimum version that is different from the global pandas\n        minimum version required.\n    Returns\n    -------\n    maybe_module : Optional[ModuleType]\n        The imported module, when found and the version is correct.\n        None is returned when the package is not found and `errors`\n        is False, or when the package's version is too old and `errors`\n        is ``'warn'`` or ``'ignore'``.\n    \"\"\"\n    assert errors in {\"warn\", \"raise\", \"ignore\"}\n\n    package_name = INSTALL_MAPPING.get(name)\n    install_name = package_name if package_name is not None else name\n\n    msg = (\n        f\"Missing optional dependency '{install_name}'. {extra} \"\n        f\"Use pip or conda to install {install_name}.\"\n    )\n    try:\n        module = importlib.import_module(name)\n    except ImportError as err:\n        if errors == \"raise\":\n            raise ImportError(msg) from err\n        return None\n\n    # Handle submodules: if we have submodule, grab parent module from sys.modules\n    parent = name.split(\".\")[0]\n    if parent != name:\n        install_name = parent\n        module_to_get = sys.modules[install_name]\n    else:\n        module_to_get = module\n    minimum_version = min_version if min_version is not None else VERSIONS.get(parent)\n    if minimum_version:\n        version = get_version(module_to_get)\n        if version and Version(version) < Version(minimum_version):\n            msg = (\n                f\"Pandas requires version '{minimum_version}' or newer of '{parent}' \"\n                f\"(version '{version}' currently installed).\"\n            )\n            if errors == \"warn\":\n                warnings.warn(\n                    msg,\n                    UserWarning,\n                    stacklevel=find_stack_level(),\n                )\n                return None\n            elif errors == \"raise\":\n                raise ImportError(msg)\n            else:\n                return None\n\n    return module\n", "file_name": "946124.py", "cwe": ["CWE-706: Use of Incorrectly-Resolved Name or Reference"]}
{"source": "import numpy as np\nimport pytest\n\nimport pandas as pd\nfrom pandas import (\n    Index,\n    MultiIndex,\n)\n\n\ndef test_repr_with_unicode_data():\n    with pd.option_context(\"display.encoding\", \"UTF-8\"):\n        d = {\"a\": [\"\\u05d0\", 2, 3], \"b\": [4, 5, 6], \"c\": [7, 8, 9]}\n        index = pd.DataFrame(d).set_index([\"a\", \"b\"]).index\n        assert \"\\\\\" not in repr(index)  # we don't want unicode-escaped\n\n\ndef test_repr_roundtrip_raises():\n    mi = MultiIndex.from_product([list(\"ab\"), range(3)], names=[\"first\", \"second\"])\n    msg = \"Must pass both levels and codes\"\n    with pytest.raises(TypeError, match=msg):\n        eval(repr(mi))\n\n\ndef test_unicode_string_with_unicode():\n    d = {\"a\": [\"\\u05d0\", 2, 3], \"b\": [4, 5, 6], \"c\": [7, 8, 9]}\n    idx = pd.DataFrame(d).set_index([\"a\", \"b\"]).index\n    str(idx)\n\n\ndef test_repr_max_seq_item_setting(idx):\n    # GH10182\n    idx = idx.repeat(50)\n    with pd.option_context(\"display.max_seq_items\", None):\n        repr(idx)\n        assert \"...\" not in str(idx)\n\n\nclass TestRepr:\n    def test_unicode_repr_issues(self):\n        levels = [Index([\"a/\\u03c3\", \"b/\\u03c3\", \"c/\\u03c3\"]), Index([0, 1])]\n        codes = [np.arange(3).repeat(2), np.tile(np.arange(2), 3)]\n        index = MultiIndex(levels=levels, codes=codes)\n\n        repr(index.levels)\n        repr(index.get_level_values(1))\n\n    def test_repr_max_seq_items_equal_to_n(self, idx):\n        # display.max_seq_items == n\n        with pd.option_context(\"display.max_seq_items\", 6):\n            result = idx.__repr__()\n            expected = \"\"\"\\\nMultiIndex([('foo', 'one'),\n            ('foo', 'two'),\n            ('bar', 'one'),\n            ('baz', 'two'),\n            ('qux', 'one'),\n            ('qux', 'two')],\n           names=['first', 'second'])\"\"\"\n            assert result == expected\n\n    def test_repr(self, idx):\n        result = idx[:1].__repr__()\n        expected = \"\"\"\\\nMultiIndex([('foo', 'one')],\n           names=['first', 'second'])\"\"\"\n        assert result == expected\n\n        result = idx.__repr__()\n        expected = \"\"\"\\\nMultiIndex([('foo', 'one'),\n            ('foo', 'two'),\n            ('bar', 'one'),\n            ('baz', 'two'),\n            ('qux', 'one'),\n            ('qux', 'two')],\n           names=['first', 'second'])\"\"\"\n        assert result == expected\n\n        with pd.option_context(\"display.max_seq_items\", 5):\n            result = idx.__repr__()\n            expected = \"\"\"\\\nMultiIndex([('foo', 'one'),\n            ('foo', 'two'),\n            ...\n            ('qux', 'one'),\n            ('qux', 'two')],\n           names=['first', 'second'], length=6)\"\"\"\n            assert result == expected\n\n        # display.max_seq_items == 1\n        with pd.option_context(\"display.max_seq_items\", 1):\n            result = idx.__repr__()\n            expected = \"\"\"\\\nMultiIndex([...\n            ('qux', 'two')],\n           names=['first', ...], length=6)\"\"\"\n            assert result == expected\n\n    def test_rjust(self):\n        n = 1000\n        ci = pd.CategoricalIndex(list(\"a\" * n) + ([\"abc\"] * n))\n        dti = pd.date_range(\"2000-01-01\", freq=\"s\", periods=n * 2)\n        mi = MultiIndex.from_arrays([ci, ci.codes + 9, dti], names=[\"a\", \"b\", \"dti\"])\n        result = mi[:1].__repr__()\n        expected = \"\"\"\\\nMultiIndex([('a', 9, '2000-01-01 00:00:00')],\n           names=['a', 'b', 'dti'])\"\"\"\n        assert result == expected\n\n        result = mi[::500].__repr__()\n        expected = \"\"\"\\\nMultiIndex([(  'a',  9, '2000-01-01 00:00:00'),\n            (  'a',  9, '2000-01-01 00:08:20'),\n            ('abc', 10, '2000-01-01 00:16:40'),\n            ('abc', 10, '2000-01-01 00:25:00')],\n           names=['a', 'b', 'dti'])\"\"\"\n        assert result == expected\n\n        result = mi.__repr__()\n        expected = \"\"\"\\\nMultiIndex([(  'a',  9, '2000-01-01 00:00:00'),\n            (  'a',  9, '2000-01-01 00:00:01'),\n            (  'a',  9, '2000-01-01 00:00:02'),\n            (  'a',  9, '2000-01-01 00:00:03'),\n            (  'a',  9, '2000-01-01 00:00:04'),\n            (  'a',  9, '2000-01-01 00:00:05'),\n            (  'a',  9, '2000-01-01 00:00:06'),\n            (  'a',  9, '2000-01-01 00:00:07'),\n            (  'a',  9, '2000-01-01 00:00:08'),\n            (  'a',  9, '2000-01-01 00:00:09'),\n            ...\n            ('abc', 10, '2000-01-01 00:33:10'),\n            ('abc', 10, '2000-01-01 00:33:11'),\n            ('abc', 10, '2000-01-01 00:33:12'),\n            ('abc', 10, '2000-01-01 00:33:13'),\n            ('abc', 10, '2000-01-01 00:33:14'),\n            ('abc', 10, '2000-01-01 00:33:15'),\n            ('abc', 10, '2000-01-01 00:33:16'),\n            ('abc', 10, '2000-01-01 00:33:17'),\n            ('abc', 10, '2000-01-01 00:33:18'),\n            ('abc', 10, '2000-01-01 00:33:19')],\n           names=['a', 'b', 'dti'], length=2000)\"\"\"\n        assert result == expected\n\n    def test_tuple_width(self):\n        n = 1000\n        ci = pd.CategoricalIndex(list(\"a\" * n) + ([\"abc\"] * n))\n        dti = pd.date_range(\"2000-01-01\", freq=\"s\", periods=n * 2)\n        levels = [ci, ci.codes + 9, dti, dti, dti]\n        names = [\"a\", \"b\", \"dti_1\", \"dti_2\", \"dti_3\"]\n        mi = MultiIndex.from_arrays(levels, names=names)\n        result = mi[:1].__repr__()\n        expected = \"\"\"MultiIndex([('a', 9, '2000-01-01 00:00:00', '2000-01-01 00:00:00', ...)],\n           names=['a', 'b', 'dti_1', 'dti_2', 'dti_3'])\"\"\"  # noqa: E501\n        assert result == expected\n\n        result = mi[:10].__repr__()\n        expected = \"\"\"\\\nMultiIndex([('a', 9, '2000-01-01 00:00:00', '2000-01-01 00:00:00', ...),\n            ('a', 9, '2000-01-01 00:00:01', '2000-01-01 00:00:01', ...),\n            ('a', 9, '2000-01-01 00:00:02', '2000-01-01 00:00:02', ...),\n            ('a', 9, '2000-01-01 00:00:03', '2000-01-01 00:00:03', ...),\n            ('a', 9, '2000-01-01 00:00:04', '2000-01-01 00:00:04', ...),\n            ('a', 9, '2000-01-01 00:00:05', '2000-01-01 00:00:05', ...),\n            ('a', 9, '2000-01-01 00:00:06', '2000-01-01 00:00:06', ...),\n            ('a', 9, '2000-01-01 00:00:07', '2000-01-01 00:00:07', ...),\n            ('a', 9, '2000-01-01 00:00:08', '2000-01-01 00:00:08', ...),\n            ('a', 9, '2000-01-01 00:00:09', '2000-01-01 00:00:09', ...)],\n           names=['a', 'b', 'dti_1', 'dti_2', 'dti_3'])\"\"\"\n        assert result == expected\n\n        result = mi.__repr__()\n        expected = \"\"\"\\\nMultiIndex([(  'a',  9, '2000-01-01 00:00:00', '2000-01-01 00:00:00', ...),\n            (  'a',  9, '2000-01-01 00:00:01', '2000-01-01 00:00:01', ...),\n            (  'a',  9, '2000-01-01 00:00:02', '2000-01-01 00:00:02', ...),\n            (  'a',  9, '2000-01-01 00:00:03', '2000-01-01 00:00:03', ...),\n            (  'a',  9, '2000-01-01 00:00:04', '2000-01-01 00:00:04', ...),\n            (  'a',  9, '2000-01-01 00:00:05', '2000-01-01 00:00:05', ...),\n            (  'a',  9, '2000-01-01 00:00:06', '2000-01-01 00:00:06', ...),\n            (  'a',  9, '2000-01-01 00:00:07', '2000-01-01 00:00:07', ...),\n            (  'a',  9, '2000-01-01 00:00:08', '2000-01-01 00:00:08', ...),\n            (  'a',  9, '2000-01-01 00:00:09', '2000-01-01 00:00:09', ...),\n            ...\n            ('abc', 10, '2000-01-01 00:33:10', '2000-01-01 00:33:10', ...),\n            ('abc', 10, '2000-01-01 00:33:11', '2000-01-01 00:33:11', ...),\n            ('abc', 10, '2000-01-01 00:33:12', '2000-01-01 00:33:12', ...),\n            ('abc', 10, '2000-01-01 00:33:13', '2000-01-01 00:33:13', ...),\n            ('abc', 10, '2000-01-01 00:33:14', '2000-01-01 00:33:14', ...),\n            ('abc', 10, '2000-01-01 00:33:15', '2000-01-01 00:33:15', ...),\n            ('abc', 10, '2000-01-01 00:33:16', '2000-01-01 00:33:16', ...),\n            ('abc', 10, '2000-01-01 00:33:17', '2000-01-01 00:33:17', ...),\n            ('abc', 10, '2000-01-01 00:33:18', '2000-01-01 00:33:18', ...),\n            ('abc', 10, '2000-01-01 00:33:19', '2000-01-01 00:33:19', ...)],\n           names=['a', 'b', 'dti_1', 'dti_2', 'dti_3'], length=2000)\"\"\"\n        assert result == expected\n\n    def test_multiindex_long_element(self):\n        # Non-regression test towards GH#52960\n        data = MultiIndex.from_tuples([(\"c\" * 62,)])\n\n        expected = (\n            \"MultiIndex([('cccccccccccccccccccccccccccccccccccccccc\"\n            \"cccccccccccccccccccccc',)],\\n           )\"\n        )\n        assert str(data) == expected\n", "file_name": "222094.py", "cwe": ["CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"]}
{"source": "\"\"\"\nself-contained to write legacy storage pickle files\n\nTo use this script. Create an environment where you want\ngenerate pickles, say its for 0.20.3, with your pandas clone\nin ~/pandas\n\n. activate pandas_0.20.3\ncd ~/pandas/pandas\n\n$ python -m tests.io.generate_legacy_storage_files \\\n    tests/io/data/legacy_pickle/0.20.3/ pickle\n\nThis script generates a storage file for the current arch, system,\nand python version\n  pandas version: 0.20.3\n  output dir    : pandas/pandas/tests/io/data/legacy_pickle/0.20.3/\n  storage format: pickle\ncreated pickle file: 0.20.3_x86_64_darwin_3.5.2.pickle\n\nThe idea here is you are using the *current* version of the\ngenerate_legacy_storage_files with an *older* version of pandas to\ngenerate a pickle file. We will then check this file into a current\nbranch, and test using test_pickle.py. This will load the *older*\npickles and test versus the current data that is generated\n(with main). These are then compared.\n\nIf we have cases where we changed the signature (e.g. we renamed\noffset -> freq in Timestamp). Then we have to conditionally execute\nin the generate_legacy_storage_files.py to make it\nrun under the older AND the newer version.\n\n\"\"\"\n\nfrom datetime import timedelta\nimport os\nimport pickle\nimport platform as pl\nimport sys\n\n# Remove script directory from path, otherwise Python will try to\n# import the JSON test directory as the json module\nsys.path.pop(0)\n\nimport numpy as np\n\nimport pandas\nfrom pandas import (\n    Categorical,\n    DataFrame,\n    Index,\n    MultiIndex,\n    NaT,\n    Period,\n    RangeIndex,\n    Series,\n    Timestamp,\n    bdate_range,\n    date_range,\n    interval_range,\n    period_range,\n    timedelta_range,\n)\nfrom pandas.arrays import SparseArray\n\nfrom pandas.tseries.offsets import (\n    FY5253,\n    BusinessDay,\n    BusinessHour,\n    CustomBusinessDay,\n    DateOffset,\n    Day,\n    Easter,\n    Hour,\n    LastWeekOfMonth,\n    Minute,\n    MonthBegin,\n    MonthEnd,\n    QuarterBegin,\n    QuarterEnd,\n    SemiMonthBegin,\n    SemiMonthEnd,\n    Week,\n    WeekOfMonth,\n    YearBegin,\n    YearEnd,\n)\n\n\ndef _create_sp_series():\n    nan = np.nan\n\n    # nan-based\n    arr = np.arange(15, dtype=np.float64)\n    arr[7:12] = nan\n    arr[-1:] = nan\n\n    bseries = Series(SparseArray(arr, kind=\"block\"))\n    bseries.name = \"bseries\"\n    return bseries\n\n\ndef _create_sp_tsseries():\n    nan = np.nan\n\n    # nan-based\n    arr = np.arange(15, dtype=np.float64)\n    arr[7:12] = nan\n    arr[-1:] = nan\n\n    date_index = bdate_range(\"1/1/2011\", periods=len(arr))\n    bseries = Series(SparseArray(arr, kind=\"block\"), index=date_index)\n    bseries.name = \"btsseries\"\n    return bseries\n\n\ndef _create_sp_frame():\n    nan = np.nan\n\n    data = {\n        \"A\": [nan, nan, nan, 0, 1, 2, 3, 4, 5, 6],\n        \"B\": [0, 1, 2, nan, nan, nan, 3, 4, 5, 6],\n        \"C\": np.arange(10).astype(np.int64),\n        \"D\": [0, 1, 2, 3, 4, 5, nan, nan, nan, nan],\n    }\n\n    dates = bdate_range(\"1/1/2011\", periods=10)\n    return DataFrame(data, index=dates).apply(SparseArray)\n\n\ndef create_pickle_data():\n    \"\"\"create the pickle data\"\"\"\n    data = {\n        \"A\": [0.0, 1.0, 2.0, 3.0, np.nan],\n        \"B\": [0, 1, 0, 1, 0],\n        \"C\": [\"foo1\", \"foo2\", \"foo3\", \"foo4\", \"foo5\"],\n        \"D\": date_range(\"1/1/2009\", periods=5),\n        \"E\": [0.0, 1, Timestamp(\"20100101\"), \"foo\", 2.0],\n    }\n\n    scalars = {\"timestamp\": Timestamp(\"20130101\"), \"period\": Period(\"2012\", \"M\")}\n\n    index = {\n        \"int\": Index(np.arange(10)),\n        \"date\": date_range(\"20130101\", periods=10),\n        \"period\": period_range(\"2013-01-01\", freq=\"M\", periods=10),\n        \"float\": Index(np.arange(10, dtype=np.float64)),\n        \"uint\": Index(np.arange(10, dtype=np.uint64)),\n        \"timedelta\": timedelta_range(\"00:00:00\", freq=\"30min\", periods=10),\n    }\n\n    index[\"range\"] = RangeIndex(10)\n\n    index[\"interval\"] = interval_range(0, periods=10)\n\n    mi = {\n        \"reg2\": MultiIndex.from_tuples(\n            tuple(\n                zip(\n                    *[\n                        [\"bar\", \"bar\", \"baz\", \"baz\", \"foo\", \"foo\", \"qux\", \"qux\"],\n                        [\"one\", \"two\", \"one\", \"two\", \"one\", \"two\", \"one\", \"two\"],\n                    ]\n                )\n            ),\n            names=[\"first\", \"second\"],\n        )\n    }\n\n    series = {\n        \"float\": Series(data[\"A\"]),\n        \"int\": Series(data[\"B\"]),\n        \"mixed\": Series(data[\"E\"]),\n        \"ts\": Series(\n            np.arange(10).astype(np.int64), index=date_range(\"20130101\", periods=10)\n        ),\n        \"mi\": Series(\n            np.arange(5).astype(np.float64),\n            index=MultiIndex.from_tuples(\n                tuple(zip(*[[1, 1, 2, 2, 2], [3, 4, 3, 4, 5]])), names=[\"one\", \"two\"]\n            ),\n        ),\n        \"dup\": Series(np.arange(5).astype(np.float64), index=[\"A\", \"B\", \"C\", \"D\", \"A\"]),\n        \"cat\": Series(Categorical([\"foo\", \"bar\", \"baz\"])),\n        \"dt\": Series(date_range(\"20130101\", periods=5)),\n        \"dt_tz\": Series(date_range(\"20130101\", periods=5, tz=\"US/Eastern\")),\n        \"period\": Series([Period(\"2000Q1\")] * 5),\n    }\n\n    mixed_dup_df = DataFrame(data)\n    mixed_dup_df.columns = list(\"ABCDA\")\n    frame = {\n        \"float\": DataFrame({\"A\": series[\"float\"], \"B\": series[\"float\"] + 1}),\n        \"int\": DataFrame({\"A\": series[\"int\"], \"B\": series[\"int\"] + 1}),\n        \"mixed\": DataFrame({k: data[k] for k in [\"A\", \"B\", \"C\", \"D\"]}),\n        \"mi\": DataFrame(\n            {\"A\": np.arange(5).astype(np.float64), \"B\": np.arange(5).astype(np.int64)},\n            index=MultiIndex.from_tuples(\n                tuple(\n                    zip(\n                        *[\n                            [\"bar\", \"bar\", \"baz\", \"baz\", \"baz\"],\n                            [\"one\", \"two\", \"one\", \"two\", \"three\"],\n                        ]\n                    )\n                ),\n                names=[\"first\", \"second\"],\n            ),\n        ),\n        \"dup\": DataFrame(\n            np.arange(15).reshape(5, 3).astype(np.float64), columns=[\"A\", \"B\", \"A\"]\n        ),\n        \"cat_onecol\": DataFrame({\"A\": Categorical([\"foo\", \"bar\"])}),\n        \"cat_and_float\": DataFrame(\n            {\n                \"A\": Categorical([\"foo\", \"bar\", \"baz\"]),\n                \"B\": np.arange(3).astype(np.int64),\n            }\n        ),\n        \"mixed_dup\": mixed_dup_df,\n        \"dt_mixed_tzs\": DataFrame(\n            {\n                \"A\": Timestamp(\"20130102\", tz=\"US/Eastern\"),\n                \"B\": Timestamp(\"20130603\", tz=\"CET\"),\n            },\n            index=range(5),\n        ),\n        \"dt_mixed2_tzs\": DataFrame(\n            {\n                \"A\": Timestamp(\"20130102\", tz=\"US/Eastern\"),\n                \"B\": Timestamp(\"20130603\", tz=\"CET\"),\n                \"C\": Timestamp(\"20130603\", tz=\"UTC\"),\n            },\n            index=range(5),\n        ),\n    }\n\n    cat = {\n        \"int8\": Categorical(list(\"abcdefg\")),\n        \"int16\": Categorical(np.arange(1000)),\n        \"int32\": Categorical(np.arange(10000)),\n    }\n\n    timestamp = {\n        \"normal\": Timestamp(\"2011-01-01\"),\n        \"nat\": NaT,\n        \"tz\": Timestamp(\"2011-01-01\", tz=\"US/Eastern\"),\n    }\n\n    off = {\n        \"DateOffset\": DateOffset(years=1),\n        \"DateOffset_h_ns\": DateOffset(hour=6, nanoseconds=5824),\n        \"BusinessDay\": BusinessDay(offset=timedelta(seconds=9)),\n        \"BusinessHour\": BusinessHour(normalize=True, n=6, end=\"15:14\"),\n        \"CustomBusinessDay\": CustomBusinessDay(weekmask=\"Mon Fri\"),\n        \"SemiMonthBegin\": SemiMonthBegin(day_of_month=9),\n        \"SemiMonthEnd\": SemiMonthEnd(day_of_month=24),\n        \"MonthBegin\": MonthBegin(1),\n        \"MonthEnd\": MonthEnd(1),\n        \"QuarterBegin\": QuarterBegin(1),\n        \"QuarterEnd\": QuarterEnd(1),\n        \"Day\": Day(1),\n        \"YearBegin\": YearBegin(1),\n        \"YearEnd\": YearEnd(1),\n        \"Week\": Week(1),\n        \"Week_Tues\": Week(2, normalize=False, weekday=1),\n        \"WeekOfMonth\": WeekOfMonth(week=3, weekday=4),\n        \"LastWeekOfMonth\": LastWeekOfMonth(n=1, weekday=3),\n        \"FY5253\": FY5253(n=2, weekday=6, startingMonth=7, variation=\"last\"),\n        \"Easter\": Easter(),\n        \"Hour\": Hour(1),\n        \"Minute\": Minute(1),\n    }\n\n    return {\n        \"series\": series,\n        \"frame\": frame,\n        \"index\": index,\n        \"scalars\": scalars,\n        \"mi\": mi,\n        \"sp_series\": {\"float\": _create_sp_series(), \"ts\": _create_sp_tsseries()},\n        \"sp_frame\": {\"float\": _create_sp_frame()},\n        \"cat\": cat,\n        \"timestamp\": timestamp,\n        \"offsets\": off,\n    }\n\n\ndef platform_name():\n    return \"_\".join(\n        [\n            str(pandas.__version__),\n            str(pl.machine()),\n            str(pl.system().lower()),\n            str(pl.python_version()),\n        ]\n    )\n\n\ndef write_legacy_pickles(output_dir):\n    version = pandas.__version__\n\n    print(\n        \"This script generates a storage file for the current arch, system, \"\n        \"and python version\"\n    )\n    print(f\"  pandas version: {version}\")\n    print(f\"  output dir    : {output_dir}\")\n    print(\"  storage format: pickle\")\n\n    pth = f\"{platform_name()}.pickle\"\n\n    with open(os.path.join(output_dir, pth), \"wb\") as fh:\n        pickle.dump(create_pickle_data(), fh, pickle.DEFAULT_PROTOCOL)\n\n    print(f\"created pickle file: {pth}\")\n\n\ndef write_legacy_file():\n    # force our cwd to be the first searched\n    sys.path.insert(0, \"\")\n\n    if not 3 <= len(sys.argv) <= 4:\n        sys.exit(\n            \"Specify output directory and storage type: generate_legacy_\"\n            \"storage_files.py <output_dir> <storage_type> \"\n        )\n\n    output_dir = str(sys.argv[1])\n    storage_type = str(sys.argv[2])\n\n    if not os.path.exists(output_dir):\n        os.mkdir(output_dir)\n\n    if storage_type == \"pickle\":\n        write_legacy_pickles(output_dir=output_dir)\n    else:\n        sys.exit(\"storage_type must be one of {'pickle'}\")\n\n\nif __name__ == \"__main__\":\n    write_legacy_file()\n", "file_name": "426331.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "# Copyright (c) 2023 PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport argparse\nimport time\nimport os\nimport sys\nimport cv2\nimport numpy as np\nimport paddle\nimport logging\nimport numpy as np\nimport argparse\nfrom tqdm import tqdm\nimport paddle\nfrom paddleslim.common import load_config as load_slim_config\nfrom paddleslim.common import get_logger\n\nimport sys\n\nsys.path.append(\"../../../\")\nfrom ppocr.data import build_dataloader\nfrom ppocr.postprocess import build_post_process\nfrom ppocr.metrics import build_metric\n\nfrom paddle.inference import create_predictor, PrecisionType\nfrom paddle.inference import Config as PredictConfig\n\nlogger = get_logger(__name__, level=logging.INFO)\n\n\ndef find_images_with_bounding_size(dataset: paddle.io.Dataset):\n    max_length_index = -1\n    max_width_index = -1\n    min_length_index = -1\n    min_width_index = -1\n\n    max_length = float(\"-inf\")\n    max_width = float(\"-inf\")\n    min_length = float(\"inf\")\n    min_width = float(\"inf\")\n    for idx, data in enumerate(dataset):\n        image = np.array(data[0])\n        h, w = image.shape[-2:]\n        if h > max_length:\n            max_length = h\n            max_length_index = idx\n        if w > max_width:\n            max_width = w\n            max_width_index = idx\n        if h < min_length:\n            min_length = h\n            min_length_index = idx\n        if w < min_width:\n            min_width = w\n            min_width_index = idx\n    print(f\"Found max image length: {max_length}, index: {max_length_index}\")\n    print(f\"Found max image width: {max_width}, index: {max_width_index}\")\n    print(f\"Found min image length: {min_length}, index: {min_length_index}\")\n    print(f\"Found min image width: {min_width}, index: {min_width_index}\")\n    return paddle.io.Subset(\n        dataset, [max_width_index, max_length_index, min_width_index, min_length_index]\n    )\n\n\ndef load_predictor(args):\n    \"\"\"\n    load predictor func\n    \"\"\"\n    rerun_flag = False\n    model_file = os.path.join(args.model_path, args.model_filename)\n    params_file = os.path.join(args.model_path, args.params_filename)\n    pred_cfg = PredictConfig(model_file, params_file)\n    pred_cfg.enable_memory_optim()\n    pred_cfg.switch_ir_optim(True)\n    if args.device == \"GPU\":\n        pred_cfg.enable_use_gpu(100, 0)\n    else:\n        pred_cfg.disable_gpu()\n        pred_cfg.set_cpu_math_library_num_threads(args.cpu_threads)\n        if args.use_mkldnn:\n            pred_cfg.enable_mkldnn()\n            if args.precision == \"int8\":\n                pred_cfg.enable_mkldnn_int8({\"conv2d\"})\n\n            if global_config[\"model_type\"] == \"rec\":\n                # delete pass which influence the accuracy, please refer to https://github.com/PaddlePaddle/Paddle/issues/55290\n                pred_cfg.delete_pass(\"fc_mkldnn_pass\")\n                pred_cfg.delete_pass(\"fc_act_mkldnn_fuse_pass\")\n\n    if args.use_trt:\n        # To collect the dynamic shapes of inputs for TensorRT engine\n        dynamic_shape_file = os.path.join(args.model_path, \"dynamic_shape.txt\")\n        if os.path.exists(dynamic_shape_file):\n            pred_cfg.enable_tuned_tensorrt_dynamic_shape(dynamic_shape_file, True)\n            print(\"trt set dynamic shape done!\")\n            precision_map = {\n                \"fp16\": PrecisionType.Half,\n                \"fp32\": PrecisionType.Float32,\n                \"int8\": PrecisionType.Int8,\n            }\n            if (\n                args.precision == \"int8\"\n                and \"ppocrv4_det_server_qat_dist.yaml\" in args.config_path\n            ):\n                # Use the following settings only when the hardware is a Tesla V100. If you are using\n                # a RTX 3090, use the settings in the else branch.\n                pred_cfg.enable_tensorrt_engine(\n                    workspace_size=1 << 30,\n                    max_batch_size=1,\n                    min_subgraph_size=30,\n                    precision_mode=precision_map[args.precision],\n                    use_static=True,\n                    use_calib_mode=False,\n                )\n                pred_cfg.exp_disable_tensorrt_ops([\"elementwise_add\"])\n            else:\n                pred_cfg.enable_tensorrt_engine(\n                    workspace_size=1 << 30,\n                    max_batch_size=1,\n                    min_subgraph_size=4,\n                    precision_mode=precision_map[args.precision],\n                    use_static=True,\n                    use_calib_mode=False,\n                )\n        else:\n            # pred_cfg.disable_gpu()\n            # pred_cfg.set_cpu_math_library_num_threads(24)\n            pred_cfg.collect_shape_range_info(dynamic_shape_file)\n            print(\"Start collect dynamic shape...\")\n            rerun_flag = True\n\n    predictor = create_predictor(pred_cfg)\n    return predictor, rerun_flag\n\n\ndef eval(args):\n    \"\"\"\n    eval mIoU func\n    \"\"\"\n    # DataLoader need run on cpu\n    paddle.set_device(\"cpu\")\n    devices = paddle.device.get_device().split(\":\")[0]\n\n    val_loader = build_dataloader(all_config, \"Eval\", devices, logger)\n    post_process_class = build_post_process(all_config[\"PostProcess\"], global_config)\n    eval_class = build_metric(all_config[\"Metric\"])\n    model_type = global_config[\"model_type\"]\n\n    predictor, rerun_flag = load_predictor(args)\n\n    if rerun_flag:\n        eval_dataset = find_images_with_bounding_size(val_loader.dataset)\n        batch_sampler = paddle.io.BatchSampler(\n            eval_dataset, batch_size=1, shuffle=False, drop_last=False\n        )\n        val_loader = paddle.io.DataLoader(\n            eval_dataset, batch_sampler=batch_sampler, num_workers=4, return_list=True\n        )\n\n    input_names = predictor.get_input_names()\n    input_handle = predictor.get_input_handle(input_names[0])\n    output_names = predictor.get_output_names()\n    output_handle = predictor.get_output_handle(output_names[0])\n    sample_nums = len(val_loader)\n    predict_time = 0.0\n    time_min = float(\"inf\")\n    time_max = float(\"-inf\")\n    print(\"Start evaluating ( total_iters: {}).\".format(sample_nums))\n\n    for batch_id, batch in enumerate(val_loader):\n        images = np.array(batch[0])\n\n        batch_numpy = []\n        for item in batch:\n            batch_numpy.append(np.array(item))\n\n        # ori_shape = np.array(batch_numpy).shape[-2:]\n        input_handle.reshape(images.shape)\n        input_handle.copy_from_cpu(images)\n        start_time = time.time()\n\n        predictor.run()\n        preds = output_handle.copy_to_cpu()\n\n        end_time = time.time()\n        timed = end_time - start_time\n        time_min = min(time_min, timed)\n        time_max = max(time_max, timed)\n        predict_time += timed\n\n        if model_type == \"det\":\n            preds_map = {\"maps\": preds}\n            post_result = post_process_class(preds_map, batch_numpy[1])\n            eval_class(post_result, batch_numpy)\n        elif model_type == \"rec\":\n            post_result = post_process_class(preds, batch_numpy[1])\n            eval_class(post_result, batch_numpy)\n\n        if rerun_flag:\n            if batch_id == 3:\n                print(\n                    \"***** Collect dynamic shape done, Please rerun the program to get correct results. *****\"\n                )\n                return\n        if batch_id % 100 == 0:\n            print(\"Eval iter:\", batch_id)\n            sys.stdout.flush()\n\n    metric = eval_class.get_metric()\n\n    time_avg = predict_time / sample_nums\n    print(\n        \"[Benchmark] Inference time(ms): min={}, max={}, avg={}\".format(\n            round(time_min * 1000, 2),\n            round(time_max * 1000, 1),\n            round(time_avg * 1000, 1),\n        )\n    )\n    for k, v in metric.items():\n        print(\"{}:{}\".format(k, v))\n    sys.stdout.flush()\n\n\ndef main():\n    global all_config, global_config\n    all_config = load_slim_config(args.config_path)\n    global_config = all_config[\"Global\"]\n    eval(args)\n\n\nif __name__ == \"__main__\":\n    paddle.enable_static()\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--model_path\", type=str, help=\"inference model filepath\")\n    parser.add_argument(\n        \"--config_path\",\n        type=str,\n        default=\"./configs/ppocrv3_det_qat_dist.yaml\",\n        help=\"path of compression strategy config.\",\n    )\n    parser.add_argument(\n        \"--model_filename\",\n        type=str,\n        default=\"inference.pdmodel\",\n        help=\"model file name\",\n    )\n    parser.add_argument(\n        \"--params_filename\",\n        type=str,\n        default=\"inference.pdiparams\",\n        help=\"params file name\",\n    )\n    parser.add_argument(\n        \"--device\",\n        type=str,\n        default=\"GPU\",\n        choices=[\"CPU\", \"GPU\"],\n        help=\"Choose the device you want to run, it can be: CPU/GPU, default is GPU\",\n    )\n    parser.add_argument(\n        \"--precision\",\n        type=str,\n        default=\"fp32\",\n        choices=[\"fp32\", \"fp16\", \"int8\"],\n        help=\"The precision of inference. It can be 'fp32', 'fp16' or 'int8'. Default is 'fp16'.\",\n    )\n    parser.add_argument(\n        \"--use_trt\",\n        type=bool,\n        default=False,\n        help=\"Whether to use tensorrt engine or not.\",\n    )\n    parser.add_argument(\n        \"--use_mkldnn\", type=bool, default=False, help=\"Whether use mkldnn or not.\"\n    )\n    parser.add_argument(\n        \"--cpu_threads\", type=int, default=10, help=\"Num of cpu threads.\"\n    )\n    args = parser.parse_args()\n    main()\n", "file_name": "938513.py", "cwe": ["CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"]}
{"source": "# copyright (c) 2024 PaddlePaddle Authors. All Rights Reserve.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nThis code is refer from:\nhttps://github.com/lukas-blecher/LaTeX-OCR/blob/main/pix2tex/dataset/dataset.py\n\"\"\"\n\nimport numpy as np\nimport cv2\nimport math\nimport os\nimport json\nimport pickle\nimport random\nimport traceback\nimport paddle\nfrom paddle.io import Dataset\nfrom .imaug.label_ops import LatexOCRLabelEncode\nfrom .imaug import transform, create_operators\n\n\nclass LaTeXOCRDataSet(Dataset):\n    def __init__(self, config, mode, logger, seed=None):\n        super(LaTeXOCRDataSet, self).__init__()\n        self.logger = logger\n        self.mode = mode.lower()\n\n        global_config = config[\"Global\"]\n        dataset_config = config[mode][\"dataset\"]\n        loader_config = config[mode][\"loader\"]\n\n        pkl_path = dataset_config.pop(\"data\")\n        self.data_dir = dataset_config[\"data_dir\"]\n        self.min_dimensions = dataset_config.pop(\"min_dimensions\")\n        self.max_dimensions = dataset_config.pop(\"max_dimensions\")\n        self.batchsize = dataset_config.pop(\"batch_size_per_pair\")\n        self.keep_smaller_batches = dataset_config.pop(\"keep_smaller_batches\")\n        self.max_seq_len = global_config.pop(\"max_seq_len\")\n        self.rec_char_dict_path = global_config.pop(\"rec_char_dict_path\")\n        self.tokenizer = LatexOCRLabelEncode(self.rec_char_dict_path)\n\n        file = open(pkl_path, \"rb\")\n        data = pickle.load(file)\n        temp = {}\n        for k in data:\n            if (\n                self.min_dimensions[0] <= k[0] <= self.max_dimensions[0]\n                and self.min_dimensions[1] <= k[1] <= self.max_dimensions[1]\n            ):\n                temp[k] = data[k]\n        self.data = temp\n        self.do_shuffle = loader_config[\"shuffle\"]\n        self.seed = seed\n\n        if self.mode == \"train\" and self.do_shuffle:\n            random.seed(self.seed)\n        self.pairs = []\n        for k in self.data:\n            info = np.array(self.data[k], dtype=object)\n            p = (\n                paddle.randperm(len(info))\n                if self.mode == \"train\" and self.do_shuffle\n                else paddle.arange(len(info))\n            )\n            for i in range(0, len(info), self.batchsize):\n                batch = info[p[i : i + self.batchsize]]\n                if len(batch.shape) == 1:\n                    batch = batch[None, :]\n                if len(batch) < self.batchsize and not self.keep_smaller_batches:\n                    continue\n                self.pairs.append(batch)\n        if self.do_shuffle:\n            self.pairs = np.random.permutation(np.array(self.pairs, dtype=object))\n        else:\n            self.pairs = np.array(self.pairs, dtype=object)\n\n        self.size = len(self.pairs)\n        self.set_epoch_as_seed(self.seed, dataset_config)\n\n        self.ops = create_operators(dataset_config[\"transforms\"], global_config)\n        self.ext_op_transform_idx = dataset_config.get(\"ext_op_transform_idx\", 2)\n        self.need_reset = True\n\n    def set_epoch_as_seed(self, seed, dataset_config):\n        if self.mode == \"train\":\n            try:\n                border_map_id = [\n                    index\n                    for index, dictionary in enumerate(dataset_config[\"transforms\"])\n                    if \"MakeBorderMap\" in dictionary\n                ][0]\n                shrink_map_id = [\n                    index\n                    for index, dictionary in enumerate(dataset_config[\"transforms\"])\n                    if \"MakeShrinkMap\" in dictionary\n                ][0]\n                dataset_config[\"transforms\"][border_map_id][\"MakeBorderMap\"][\n                    \"epoch\"\n                ] = (seed if seed is not None else 0)\n                dataset_config[\"transforms\"][shrink_map_id][\"MakeShrinkMap\"][\n                    \"epoch\"\n                ] = (seed if seed is not None else 0)\n            except Exception as E:\n                print(E)\n                return\n\n    def shuffle_data_random(self):\n        random.seed(self.seed)\n        random.shuffle(self.data_lines)\n        return\n\n    def __getitem__(self, idx):\n        batch = self.pairs[idx]\n        eqs, ims = batch.T\n        try:\n            max_width, max_height, max_length = 0, 0, 0\n\n            images_transform = []\n\n            for file_name in ims:\n                img_path = os.path.join(self.data_dir, file_name)\n                data = {\n                    \"img_path\": img_path,\n                }\n                with open(data[\"img_path\"], \"rb\") as f:\n                    img = f.read()\n                    data[\"image\"] = img\n                    item = transform(data, self.ops)\n                    images_transform.append(np.array(item[0]))\n            image_concat = np.concatenate(images_transform, axis=0)[:, np.newaxis, :, :]\n            images_transform = image_concat.astype(np.float32)\n            labels, attention_mask, max_length = self.tokenizer(list(eqs))\n            if self.max_seq_len < max_length:\n                rnd_idx = (\n                    np.random.randint(self.__len__())\n                    if self.mode == \"train\"\n                    else (idx + 1) % self.__len__()\n                )\n                return self.__getitem__(rnd_idx)\n            return (images_transform, labels, attention_mask)\n\n        except:\n\n            self.logger.error(\n                \"When parsing line {}, error happened with msg: {}\".format(\n                    data[\"img_path\"], traceback.format_exc()\n                )\n            )\n            outs = None\n\n        if outs is None:\n            # during evaluation, we should fix the idx to get same results for many times of evaluation.\n            rnd_idx = (\n                np.random.randint(self.__len__())\n                if self.mode == \"train\"\n                else (idx + 1) % self.__len__()\n            )\n            return self.__getitem__(rnd_idx)\n        return outs\n\n    def __len__(self):\n        return self.size\n", "file_name": "116843.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "import torch\nimport ldm_patched.modules.clip_vision\nimport safetensors.torch as sf\nimport ldm_patched.modules.model_management as model_management\nimport ldm_patched.ldm.modules.attention as attention\n\nfrom extras.resampler import Resampler\nfrom ldm_patched.modules.model_patcher import ModelPatcher\nfrom modules.core import numpy_to_pytorch\nfrom modules.ops import use_patched_ops\nfrom ldm_patched.modules.ops import manual_cast\n\n\nSD_V12_CHANNELS = [320] * 4 + [640] * 4 + [1280] * 4 + [1280] * 6 + [640] * 6 + [320] * 6 + [1280] * 2\nSD_XL_CHANNELS = [640] * 8 + [1280] * 40 + [1280] * 60 + [640] * 12 + [1280] * 20\n\n\ndef sdp(q, k, v, extra_options):\n    return attention.optimized_attention(q, k, v, heads=extra_options[\"n_heads\"], mask=None)\n\n\nclass ImageProjModel(torch.nn.Module):\n    def __init__(self, cross_attention_dim=1024, clip_embeddings_dim=1024, clip_extra_context_tokens=4):\n        super().__init__()\n\n        self.cross_attention_dim = cross_attention_dim\n        self.clip_extra_context_tokens = clip_extra_context_tokens\n        self.proj = torch.nn.Linear(clip_embeddings_dim, self.clip_extra_context_tokens * cross_attention_dim)\n        self.norm = torch.nn.LayerNorm(cross_attention_dim)\n\n    def forward(self, image_embeds):\n        embeds = image_embeds\n        clip_extra_context_tokens = self.proj(embeds).reshape(-1, self.clip_extra_context_tokens,\n                                                              self.cross_attention_dim)\n        clip_extra_context_tokens = self.norm(clip_extra_context_tokens)\n        return clip_extra_context_tokens\n\n\nclass To_KV(torch.nn.Module):\n    def __init__(self, cross_attention_dim):\n        super().__init__()\n\n        channels = SD_XL_CHANNELS if cross_attention_dim == 2048 else SD_V12_CHANNELS\n        self.to_kvs = torch.nn.ModuleList(\n            [torch.nn.Linear(cross_attention_dim, channel, bias=False) for channel in channels])\n\n    def load_state_dict_ordered(self, sd):\n        state_dict = []\n        for i in range(4096):\n            for k in ['k', 'v']:\n                key = f'{i}.to_{k}_ip.weight'\n                if key in sd:\n                    state_dict.append(sd[key])\n        for i, v in enumerate(state_dict):\n            self.to_kvs[i].weight = torch.nn.Parameter(v, requires_grad=False)\n\n\nclass IPAdapterModel(torch.nn.Module):\n    def __init__(self, state_dict, plus, cross_attention_dim=768, clip_embeddings_dim=1024, clip_extra_context_tokens=4,\n                 sdxl_plus=False):\n        super().__init__()\n        self.plus = plus\n        if self.plus:\n            self.image_proj_model = Resampler(\n                dim=1280 if sdxl_plus else cross_attention_dim,\n                depth=4,\n                dim_head=64,\n                heads=20 if sdxl_plus else 12,\n                num_queries=clip_extra_context_tokens,\n                embedding_dim=clip_embeddings_dim,\n                output_dim=cross_attention_dim,\n                ff_mult=4\n            )\n        else:\n            self.image_proj_model = ImageProjModel(\n                cross_attention_dim=cross_attention_dim,\n                clip_embeddings_dim=clip_embeddings_dim,\n                clip_extra_context_tokens=clip_extra_context_tokens\n            )\n\n        self.image_proj_model.load_state_dict(state_dict[\"image_proj\"])\n        self.ip_layers = To_KV(cross_attention_dim)\n        self.ip_layers.load_state_dict_ordered(state_dict[\"ip_adapter\"])\n\n\nclip_vision: ldm_patched.modules.clip_vision.ClipVisionModel = None\nip_negative: torch.Tensor = None\nip_adapters: dict = {}\n\n\ndef load_ip_adapter(clip_vision_path, ip_negative_path, ip_adapter_path):\n    global clip_vision, ip_negative, ip_adapters\n\n    if clip_vision is None and isinstance(clip_vision_path, str):\n        clip_vision = ldm_patched.modules.clip_vision.load(clip_vision_path)\n\n    if ip_negative is None and isinstance(ip_negative_path, str):\n        ip_negative = sf.load_file(ip_negative_path)['data']\n\n    if not isinstance(ip_adapter_path, str) or ip_adapter_path in ip_adapters:\n        return\n\n    load_device = model_management.get_torch_device()\n    offload_device = torch.device('cpu')\n\n    use_fp16 = model_management.should_use_fp16(device=load_device)\n    ip_state_dict = torch.load(ip_adapter_path, map_location=\"cpu\", weights_only=True)\n    plus = \"latents\" in ip_state_dict[\"image_proj\"]\n    cross_attention_dim = ip_state_dict[\"ip_adapter\"][\"1.to_k_ip.weight\"].shape[1]\n    sdxl = cross_attention_dim == 2048\n    sdxl_plus = sdxl and plus\n\n    if plus:\n        clip_extra_context_tokens = ip_state_dict[\"image_proj\"][\"latents\"].shape[1]\n        clip_embeddings_dim = ip_state_dict[\"image_proj\"][\"latents\"].shape[2]\n    else:\n        clip_extra_context_tokens = ip_state_dict[\"image_proj\"][\"proj.weight\"].shape[0] // cross_attention_dim\n        clip_embeddings_dim = None\n\n    with use_patched_ops(manual_cast):\n        ip_adapter = IPAdapterModel(\n            ip_state_dict,\n            plus=plus,\n            cross_attention_dim=cross_attention_dim,\n            clip_embeddings_dim=clip_embeddings_dim,\n            clip_extra_context_tokens=clip_extra_context_tokens,\n            sdxl_plus=sdxl_plus\n        )\n\n    ip_adapter.sdxl = sdxl\n    ip_adapter.load_device = load_device\n    ip_adapter.offload_device = offload_device\n    ip_adapter.dtype = torch.float16 if use_fp16 else torch.float32\n    ip_adapter.to(offload_device, dtype=ip_adapter.dtype)\n\n    image_proj_model = ModelPatcher(model=ip_adapter.image_proj_model, load_device=load_device,\n                                    offload_device=offload_device)\n    ip_layers = ModelPatcher(model=ip_adapter.ip_layers, load_device=load_device,\n                             offload_device=offload_device)\n\n    ip_adapters[ip_adapter_path] = dict(\n        ip_adapter=ip_adapter,\n        image_proj_model=image_proj_model,\n        ip_layers=ip_layers,\n        ip_unconds=None\n    )\n\n    return\n\n\n@torch.no_grad()\n@torch.inference_mode()\ndef clip_preprocess(image):\n    mean = torch.tensor([0.48145466, 0.4578275, 0.40821073], device=image.device, dtype=image.dtype).view([1, 3, 1, 1])\n    std = torch.tensor([0.26862954, 0.26130258, 0.27577711], device=image.device, dtype=image.dtype).view([1, 3, 1, 1])\n    image = image.movedim(-1, 1)\n\n    # https://github.com/tencent-ailab/IP-Adapter/blob/d580c50a291566bbf9fc7ac0f760506607297e6d/README.md?plain=1#L75\n    B, C, H, W = image.shape\n    assert H == 224 and W == 224\n\n    return (image - mean) / std\n\n\n@torch.no_grad()\n@torch.inference_mode()\ndef preprocess(img, ip_adapter_path):\n    global ip_adapters\n    entry = ip_adapters[ip_adapter_path]\n\n    ldm_patched.modules.model_management.load_model_gpu(clip_vision.patcher)\n    pixel_values = clip_preprocess(numpy_to_pytorch(img).to(clip_vision.load_device))\n    outputs = clip_vision.model(pixel_values=pixel_values, output_hidden_states=True)\n\n    ip_adapter = entry['ip_adapter']\n    ip_layers = entry['ip_layers']\n    image_proj_model = entry['image_proj_model']\n    ip_unconds = entry['ip_unconds']\n\n    if ip_adapter.plus:\n        cond = outputs.hidden_states[-2]\n    else:\n        cond = outputs.image_embeds\n\n    cond = cond.to(device=ip_adapter.load_device, dtype=ip_adapter.dtype)\n\n    ldm_patched.modules.model_management.load_model_gpu(image_proj_model)\n    cond = image_proj_model.model(cond).to(device=ip_adapter.load_device, dtype=ip_adapter.dtype)\n\n    ldm_patched.modules.model_management.load_model_gpu(ip_layers)\n\n    if ip_unconds is None:\n        uncond = ip_negative.to(device=ip_adapter.load_device, dtype=ip_adapter.dtype)\n        ip_unconds = [m(uncond).cpu() for m in ip_layers.model.to_kvs]\n        entry['ip_unconds'] = ip_unconds\n\n    ip_conds = [m(cond).cpu() for m in ip_layers.model.to_kvs]\n\n    return ip_conds, ip_unconds\n\n\n@torch.no_grad()\n@torch.inference_mode()\ndef patch_model(model, tasks):\n    new_model = model.clone()\n\n    def make_attn_patcher(ip_index):\n        def patcher(n, context_attn2, value_attn2, extra_options):\n            org_dtype = n.dtype\n            current_step = float(model.model.diffusion_model.current_step.detach().cpu().numpy()[0])\n            cond_or_uncond = extra_options['cond_or_uncond']\n\n            q = n\n            k = [context_attn2]\n            v = [value_attn2]\n            b, _, _ = q.shape\n\n            for (cs, ucs), cn_stop, cn_weight in tasks:\n                if current_step < cn_stop:\n                    ip_k_c = cs[ip_index * 2].to(q)\n                    ip_v_c = cs[ip_index * 2 + 1].to(q)\n                    ip_k_uc = ucs[ip_index * 2].to(q)\n                    ip_v_uc = ucs[ip_index * 2 + 1].to(q)\n\n                    ip_k = torch.cat([(ip_k_c, ip_k_uc)[i] for i in cond_or_uncond], dim=0)\n                    ip_v = torch.cat([(ip_v_c, ip_v_uc)[i] for i in cond_or_uncond], dim=0)\n\n                    # Midjourney's attention formulation of image prompt (non-official reimplementation)\n                    # Written by Lvmin Zhang at Stanford University, 2023 Dec\n                    # For non-commercial use only - if you use this in commercial project then\n                    # probably it has some intellectual property issues.\n                    # Contact lvminzhang@acm.org if you are not sure.\n\n                    # Below is the sensitive part with potential intellectual property issues.\n\n                    ip_v_mean = torch.mean(ip_v, dim=1, keepdim=True)\n                    ip_v_offset = ip_v - ip_v_mean\n\n                    B, F, C = ip_k.shape\n                    channel_penalty = float(C) / 1280.0\n                    weight = cn_weight * channel_penalty\n\n                    ip_k = ip_k * weight\n                    ip_v = ip_v_offset + ip_v_mean * weight\n\n                    k.append(ip_k)\n                    v.append(ip_v)\n\n            k = torch.cat(k, dim=1)\n            v = torch.cat(v, dim=1)\n            out = sdp(q, k, v, extra_options)\n\n\n            return out.to(dtype=org_dtype)\n        return patcher\n\n    def set_model_patch_replace(model, number, key):\n        to = model.model_options[\"transformer_options\"]\n        if \"patches_replace\" not in to:\n            to[\"patches_replace\"] = {}\n        if \"attn2\" not in to[\"patches_replace\"]:\n            to[\"patches_replace\"][\"attn2\"] = {}\n        if key not in to[\"patches_replace\"][\"attn2\"]:\n            to[\"patches_replace\"][\"attn2\"][key] = make_attn_patcher(number)\n\n    number = 0\n\n    for id in [4, 5, 7, 8]:\n        block_indices = range(2) if id in [4, 5] else range(10)\n        for index in block_indices:\n            set_model_patch_replace(new_model, number, (\"input\", id, index))\n            number += 1\n\n    for id in range(6):\n        block_indices = range(2) if id in [3, 4, 5] else range(10)\n        for index in block_indices:\n            set_model_patch_replace(new_model, number, (\"output\", id, index))\n            number += 1\n\n    for index in range(10):\n        set_model_patch_replace(new_model, number, (\"middle\", 0, index))\n        number += 1\n\n    return new_model\n", "file_name": "791267.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "import torch\nfrom ldm_patched.ldm.modules.diffusionmodules.util import make_beta_schedule\nimport math\nimport numpy as np\n\nclass EPS:\n    def calculate_input(self, sigma, noise):\n        sigma = sigma.view(sigma.shape[:1] + (1,) * (noise.ndim - 1))\n        return noise / (sigma ** 2 + self.sigma_data ** 2) ** 0.5\n\n    def calculate_denoised(self, sigma, model_output, model_input):\n        sigma = sigma.view(sigma.shape[:1] + (1,) * (model_output.ndim - 1))\n        return model_input - model_output * sigma\n\n    def noise_scaling(self, sigma, noise, latent_image, max_denoise=False):\n        if max_denoise:\n            noise = noise * torch.sqrt(1.0 + sigma ** 2.0)\n        else:\n            noise = noise * sigma\n\n        noise += latent_image\n        return noise\n\n    def inverse_noise_scaling(self, sigma, latent):\n        return latent\n\nclass V_PREDICTION(EPS):\n    def calculate_denoised(self, sigma, model_output, model_input):\n        sigma = sigma.view(sigma.shape[:1] + (1,) * (model_output.ndim - 1))\n        return model_input * self.sigma_data ** 2 / (sigma ** 2 + self.sigma_data ** 2) - model_output * sigma * self.sigma_data / (sigma ** 2 + self.sigma_data ** 2) ** 0.5\n\nclass EDM(V_PREDICTION):\n    def calculate_denoised(self, sigma, model_output, model_input):\n        sigma = sigma.view(sigma.shape[:1] + (1,) * (model_output.ndim - 1))\n        return model_input * self.sigma_data ** 2 / (sigma ** 2 + self.sigma_data ** 2) + model_output * sigma * self.sigma_data / (sigma ** 2 + self.sigma_data ** 2) ** 0.5\n\n\nclass ModelSamplingDiscrete(torch.nn.Module):\n    def __init__(self, model_config=None):\n        super().__init__()\n\n        if model_config is not None:\n            sampling_settings = model_config.sampling_settings\n        else:\n            sampling_settings = {}\n\n        beta_schedule = sampling_settings.get(\"beta_schedule\", \"linear\")\n        linear_start = sampling_settings.get(\"linear_start\", 0.00085)\n        linear_end = sampling_settings.get(\"linear_end\", 0.012)\n\n        self._register_schedule(given_betas=None, beta_schedule=beta_schedule, timesteps=1000, linear_start=linear_start, linear_end=linear_end, cosine_s=8e-3)\n        self.sigma_data = 1.0\n\n    def _register_schedule(self, given_betas=None, beta_schedule=\"linear\", timesteps=1000,\n                          linear_start=1e-4, linear_end=2e-2, cosine_s=8e-3):\n        if given_betas is not None:\n            betas = given_betas\n        else:\n            betas = make_beta_schedule(beta_schedule, timesteps, linear_start=linear_start, linear_end=linear_end, cosine_s=cosine_s)\n        alphas = 1. - betas\n        alphas_cumprod = torch.cumprod(alphas, dim=0)\n\n        timesteps, = betas.shape\n        self.num_timesteps = int(timesteps)\n        self.linear_start = linear_start\n        self.linear_end = linear_end\n\n        # self.register_buffer('betas', torch.tensor(betas, dtype=torch.float32))\n        # self.register_buffer('alphas_cumprod', torch.tensor(alphas_cumprod, dtype=torch.float32))\n        # self.register_buffer('alphas_cumprod_prev', torch.tensor(alphas_cumprod_prev, dtype=torch.float32))\n\n        sigmas = ((1 - alphas_cumprod) / alphas_cumprod) ** 0.5\n        alphas_cumprod = torch.tensor(np.cumprod(alphas, axis=0), dtype=torch.float32)\n        self.set_sigmas(sigmas)\n        self.set_alphas_cumprod(alphas_cumprod.float())\n\n    def set_sigmas(self, sigmas):\n        self.register_buffer('sigmas', sigmas.float())\n        self.register_buffer('log_sigmas', sigmas.log().float())\n\n    def set_alphas_cumprod(self, alphas_cumprod):\n        self.register_buffer(\"alphas_cumprod\", alphas_cumprod.float())\n\n    @property\n    def sigma_min(self):\n        return self.sigmas[0]\n\n    @property\n    def sigma_max(self):\n        return self.sigmas[-1]\n\n    def timestep(self, sigma):\n        log_sigma = sigma.log()\n        dists = log_sigma.to(self.log_sigmas.device) - self.log_sigmas[:, None]\n        return dists.abs().argmin(dim=0).view(sigma.shape).to(sigma.device)\n\n    def sigma(self, timestep):\n        t = torch.clamp(timestep.float().to(self.log_sigmas.device), min=0, max=(len(self.sigmas) - 1))\n        low_idx = t.floor().long()\n        high_idx = t.ceil().long()\n        w = t.frac()\n        log_sigma = (1 - w) * self.log_sigmas[low_idx] + w * self.log_sigmas[high_idx]\n        return log_sigma.exp().to(timestep.device)\n\n    def percent_to_sigma(self, percent):\n        if percent <= 0.0:\n            return 999999999.9\n        if percent >= 1.0:\n            return 0.0\n        percent = 1.0 - percent\n        return self.sigma(torch.tensor(percent * 999.0)).item()\n\n\nclass ModelSamplingContinuousEDM(torch.nn.Module):\n    def __init__(self, model_config=None):\n        super().__init__()\n        if model_config is not None:\n            sampling_settings = model_config.sampling_settings\n        else:\n            sampling_settings = {}\n\n        sigma_min = sampling_settings.get(\"sigma_min\", 0.002)\n        sigma_max = sampling_settings.get(\"sigma_max\", 120.0)\n        sigma_data = sampling_settings.get(\"sigma_data\", 1.0)\n        self.set_parameters(sigma_min, sigma_max, sigma_data)\n\n    def set_parameters(self, sigma_min, sigma_max, sigma_data):\n        self.sigma_data = sigma_data\n        sigmas = torch.linspace(math.log(sigma_min), math.log(sigma_max), 1000).exp()\n\n        self.register_buffer('sigmas', sigmas) #for compatibility with some schedulers\n        self.register_buffer('log_sigmas', sigmas.log())\n\n    @property\n    def sigma_min(self):\n        return self.sigmas[0]\n\n    @property\n    def sigma_max(self):\n        return self.sigmas[-1]\n\n    def timestep(self, sigma):\n        return 0.25 * sigma.log()\n\n    def sigma(self, timestep):\n        return (timestep / 0.25).exp()\n\n    def percent_to_sigma(self, percent):\n        if percent <= 0.0:\n            return 999999999.9\n        if percent >= 1.0:\n            return 0.0\n        percent = 1.0 - percent\n\n        log_sigma_min = math.log(self.sigma_min)\n        return math.exp((math.log(self.sigma_max) - log_sigma_min) * percent + log_sigma_min)\n\nclass StableCascadeSampling(ModelSamplingDiscrete):\n    def __init__(self, model_config=None):\n        super().__init__()\n\n        if model_config is not None:\n            sampling_settings = model_config.sampling_settings\n        else:\n            sampling_settings = {}\n\n        self.set_parameters(sampling_settings.get(\"shift\", 1.0))\n\n    def set_parameters(self, shift=1.0, cosine_s=8e-3):\n        self.shift = shift\n        self.cosine_s = torch.tensor(cosine_s)\n        self._init_alpha_cumprod = torch.cos(self.cosine_s / (1 + self.cosine_s) * torch.pi * 0.5) ** 2\n\n        #This part is just for compatibility with some schedulers in the codebase\n        self.num_timesteps = 10000\n        sigmas = torch.empty((self.num_timesteps), dtype=torch.float32)\n        for x in range(self.num_timesteps):\n            t = (x + 1) / self.num_timesteps\n            sigmas[x] = self.sigma(t)\n\n        self.set_sigmas(sigmas)\n\n    def sigma(self, timestep):\n        alpha_cumprod = (torch.cos((timestep + self.cosine_s) / (1 + self.cosine_s) * torch.pi * 0.5) ** 2 / self._init_alpha_cumprod)\n\n        if self.shift != 1.0:\n            var = alpha_cumprod\n            logSNR = (var/(1-var)).log()\n            logSNR += 2 * torch.log(1.0 / torch.tensor(self.shift))\n            alpha_cumprod = logSNR.sigmoid()\n\n        alpha_cumprod = alpha_cumprod.clamp(0.0001, 0.9999)\n        return ((1 - alpha_cumprod) / alpha_cumprod) ** 0.5\n\n    def timestep(self, sigma):\n        var = 1 / ((sigma * sigma) + 1)\n        var = var.clamp(0, 1.0)\n        s, min_var = self.cosine_s.to(var.device), self._init_alpha_cumprod.to(var.device)\n        t = (((var * min_var) ** 0.5).acos() / (torch.pi * 0.5)) * (1 + s) - s\n        return t\n\n    def percent_to_sigma(self, percent):\n        if percent <= 0.0:\n            return 999999999.9\n        if percent >= 1.0:\n            return 0.0\n\n        percent = 1.0 - percent\n        return self.sigma(torch.tensor(percent))", "file_name": "032394.py", "cwe": ["Unknown"]}
{"source": "import os\nimport einops\nimport torch\nimport numpy as np\n\nimport ldm_patched.modules.model_management\nimport ldm_patched.modules.model_detection\nimport ldm_patched.modules.model_patcher\nimport ldm_patched.modules.utils\nimport ldm_patched.modules.controlnet\nimport modules.sample_hijack\nimport ldm_patched.modules.samplers\nimport ldm_patched.modules.latent_formats\n\nfrom ldm_patched.modules.sd import load_checkpoint_guess_config\nfrom ldm_patched.contrib.external import VAEDecode, EmptyLatentImage, VAEEncode, VAEEncodeTiled, VAEDecodeTiled, \\\n    ControlNetApplyAdvanced\nfrom ldm_patched.contrib.external_freelunch import FreeU_V2\nfrom ldm_patched.modules.sample import prepare_mask\nfrom modules.lora import match_lora\nfrom modules.util import get_file_from_folder_list\nfrom ldm_patched.modules.lora import model_lora_keys_unet, model_lora_keys_clip\nfrom modules.config import path_embeddings\nfrom ldm_patched.contrib.external_model_advanced import ModelSamplingDiscrete, ModelSamplingContinuousEDM\n\nopEmptyLatentImage = EmptyLatentImage()\nopVAEDecode = VAEDecode()\nopVAEEncode = VAEEncode()\nopVAEDecodeTiled = VAEDecodeTiled()\nopVAEEncodeTiled = VAEEncodeTiled()\nopControlNetApplyAdvanced = ControlNetApplyAdvanced()\nopFreeU = FreeU_V2()\nopModelSamplingDiscrete = ModelSamplingDiscrete()\nopModelSamplingContinuousEDM = ModelSamplingContinuousEDM()\n\n\nclass StableDiffusionModel:\n    def __init__(self, unet=None, vae=None, clip=None, clip_vision=None, filename=None, vae_filename=None):\n        self.unet = unet\n        self.vae = vae\n        self.clip = clip\n        self.clip_vision = clip_vision\n        self.filename = filename\n        self.vae_filename = vae_filename\n        self.unet_with_lora = unet\n        self.clip_with_lora = clip\n        self.visited_loras = ''\n\n        self.lora_key_map_unet = {}\n        self.lora_key_map_clip = {}\n\n        if self.unet is not None:\n            self.lora_key_map_unet = model_lora_keys_unet(self.unet.model, self.lora_key_map_unet)\n            self.lora_key_map_unet.update({x: x for x in self.unet.model.state_dict().keys()})\n\n        if self.clip is not None:\n            self.lora_key_map_clip = model_lora_keys_clip(self.clip.cond_stage_model, self.lora_key_map_clip)\n            self.lora_key_map_clip.update({x: x for x in self.clip.cond_stage_model.state_dict().keys()})\n\n    @torch.no_grad()\n    @torch.inference_mode()\n    def refresh_loras(self, loras):\n        assert isinstance(loras, list)\n\n        if self.visited_loras == str(loras):\n            return\n\n        self.visited_loras = str(loras)\n\n        if self.unet is None:\n            return\n\n        print(f'Request to load LoRAs {str(loras)} for model [{self.filename}].')\n\n        loras_to_load = []\n\n        for filename, weight in loras:\n            if filename == 'None':\n                continue\n\n            if os.path.exists(filename):\n                lora_filename = filename\n            else:\n                lora_filename = get_file_from_folder_list(filename, modules.config.paths_loras)\n\n            if not os.path.exists(lora_filename):\n                print(f'Lora file not found: {lora_filename}')\n                continue\n\n            loras_to_load.append((lora_filename, weight))\n\n        self.unet_with_lora = self.unet.clone() if self.unet is not None else None\n        self.clip_with_lora = self.clip.clone() if self.clip is not None else None\n\n        for lora_filename, weight in loras_to_load:\n            lora_unmatch = ldm_patched.modules.utils.load_torch_file(lora_filename, safe_load=False)\n            lora_unet, lora_unmatch = match_lora(lora_unmatch, self.lora_key_map_unet)\n            lora_clip, lora_unmatch = match_lora(lora_unmatch, self.lora_key_map_clip)\n\n            if len(lora_unmatch) > 12:\n                # model mismatch\n                continue\n\n            if len(lora_unmatch) > 0:\n                print(f'Loaded LoRA [{lora_filename}] for model [{self.filename}] '\n                      f'with unmatched keys {list(lora_unmatch.keys())}')\n\n            if self.unet_with_lora is not None and len(lora_unet) > 0:\n                loaded_keys = self.unet_with_lora.add_patches(lora_unet, weight)\n                print(f'Loaded LoRA [{lora_filename}] for UNet [{self.filename}] '\n                      f'with {len(loaded_keys)} keys at weight {weight}.')\n                for item in lora_unet:\n                    if item not in loaded_keys:\n                        print(\"UNet LoRA key skipped: \", item)\n\n            if self.clip_with_lora is not None and len(lora_clip) > 0:\n                loaded_keys = self.clip_with_lora.add_patches(lora_clip, weight)\n                print(f'Loaded LoRA [{lora_filename}] for CLIP [{self.filename}] '\n                      f'with {len(loaded_keys)} keys at weight {weight}.')\n                for item in lora_clip:\n                    if item not in loaded_keys:\n                        print(\"CLIP LoRA key skipped: \", item)\n\n\n@torch.no_grad()\n@torch.inference_mode()\ndef apply_freeu(model, b1, b2, s1, s2):\n    return opFreeU.patch(model=model, b1=b1, b2=b2, s1=s1, s2=s2)[0]\n\n\n@torch.no_grad()\n@torch.inference_mode()\ndef load_controlnet(ckpt_filename):\n    return ldm_patched.modules.controlnet.load_controlnet(ckpt_filename)\n\n\n@torch.no_grad()\n@torch.inference_mode()\ndef apply_controlnet(positive, negative, control_net, image, strength, start_percent, end_percent):\n    return opControlNetApplyAdvanced.apply_controlnet(positive=positive, negative=negative, control_net=control_net,\n        image=image, strength=strength, start_percent=start_percent, end_percent=end_percent)\n\n\n@torch.no_grad()\n@torch.inference_mode()\ndef load_model(ckpt_filename, vae_filename=None):\n    unet, clip, vae, vae_filename, clip_vision = load_checkpoint_guess_config(ckpt_filename, embedding_directory=path_embeddings,\n                                                                vae_filename_param=vae_filename)\n    return StableDiffusionModel(unet=unet, clip=clip, vae=vae, clip_vision=clip_vision, filename=ckpt_filename, vae_filename=vae_filename)\n\n\n@torch.no_grad()\n@torch.inference_mode()\ndef generate_empty_latent(width=1024, height=1024, batch_size=1):\n    return opEmptyLatentImage.generate(width=width, height=height, batch_size=batch_size)[0]\n\n\n@torch.no_grad()\n@torch.inference_mode()\ndef decode_vae(vae, latent_image, tiled=False):\n    if tiled:\n        return opVAEDecodeTiled.decode(samples=latent_image, vae=vae, tile_size=512)[0]\n    else:\n        return opVAEDecode.decode(samples=latent_image, vae=vae)[0]\n\n\n@torch.no_grad()\n@torch.inference_mode()\ndef encode_vae(vae, pixels, tiled=False):\n    if tiled:\n        return opVAEEncodeTiled.encode(pixels=pixels, vae=vae, tile_size=512)[0]\n    else:\n        return opVAEEncode.encode(pixels=pixels, vae=vae)[0]\n\n\n@torch.no_grad()\n@torch.inference_mode()\ndef encode_vae_inpaint(vae, pixels, mask):\n    assert mask.ndim == 3 and pixels.ndim == 4\n    assert mask.shape[-1] == pixels.shape[-2]\n    assert mask.shape[-2] == pixels.shape[-3]\n\n    w = mask.round()[..., None]\n    pixels = pixels * (1 - w) + 0.5 * w\n\n    latent = vae.encode(pixels)\n    B, C, H, W = latent.shape\n\n    latent_mask = mask[:, None, :, :]\n    latent_mask = torch.nn.functional.interpolate(latent_mask, size=(H * 8, W * 8), mode=\"bilinear\").round()\n    latent_mask = torch.nn.functional.max_pool2d(latent_mask, (8, 8)).round().to(latent)\n\n    return latent, latent_mask\n\n\nclass VAEApprox(torch.nn.Module):\n    def __init__(self):\n        super(VAEApprox, self).__init__()\n        self.conv1 = torch.nn.Conv2d(4, 8, (7, 7))\n        self.conv2 = torch.nn.Conv2d(8, 16, (5, 5))\n        self.conv3 = torch.nn.Conv2d(16, 32, (3, 3))\n        self.conv4 = torch.nn.Conv2d(32, 64, (3, 3))\n        self.conv5 = torch.nn.Conv2d(64, 32, (3, 3))\n        self.conv6 = torch.nn.Conv2d(32, 16, (3, 3))\n        self.conv7 = torch.nn.Conv2d(16, 8, (3, 3))\n        self.conv8 = torch.nn.Conv2d(8, 3, (3, 3))\n        self.current_type = None\n\n    def forward(self, x):\n        extra = 11\n        x = torch.nn.functional.interpolate(x, (x.shape[2] * 2, x.shape[3] * 2))\n        x = torch.nn.functional.pad(x, (extra, extra, extra, extra))\n        for layer in [self.conv1, self.conv2, self.conv3, self.conv4, self.conv5, self.conv6, self.conv7, self.conv8]:\n            x = layer(x)\n            x = torch.nn.functional.leaky_relu(x, 0.1)\n        return x\n\n\nVAE_approx_models = {}\n\n\n@torch.no_grad()\n@torch.inference_mode()\ndef get_previewer(model):\n    global VAE_approx_models\n\n    from modules.config import path_vae_approx\n    is_sdxl = isinstance(model.model.latent_format, ldm_patched.modules.latent_formats.SDXL)\n    vae_approx_filename = os.path.join(path_vae_approx, 'xlvaeapp.pth' if is_sdxl else 'vaeapp_sd15.pth')\n\n    if vae_approx_filename in VAE_approx_models:\n        VAE_approx_model = VAE_approx_models[vae_approx_filename]\n    else:\n        sd = torch.load(vae_approx_filename, map_location='cpu', weights_only=True)\n        VAE_approx_model = VAEApprox()\n        VAE_approx_model.load_state_dict(sd)\n        del sd\n        VAE_approx_model.eval()\n\n        if ldm_patched.modules.model_management.should_use_fp16():\n            VAE_approx_model.half()\n            VAE_approx_model.current_type = torch.float16\n        else:\n            VAE_approx_model.float()\n            VAE_approx_model.current_type = torch.float32\n\n        VAE_approx_model.to(ldm_patched.modules.model_management.get_torch_device())\n        VAE_approx_models[vae_approx_filename] = VAE_approx_model\n\n    @torch.no_grad()\n    @torch.inference_mode()\n    def preview_function(x0, step, total_steps):\n        with torch.no_grad():\n            x_sample = x0.to(VAE_approx_model.current_type)\n            x_sample = VAE_approx_model(x_sample) * 127.5 + 127.5\n            x_sample = einops.rearrange(x_sample, 'b c h w -> b h w c')[0]\n            x_sample = x_sample.cpu().numpy().clip(0, 255).astype(np.uint8)\n            return x_sample\n\n    return preview_function\n\n\n@torch.no_grad()\n@torch.inference_mode()\ndef ksampler(model, positive, negative, latent, seed=None, steps=30, cfg=7.0, sampler_name='dpmpp_2m_sde_gpu',\n             scheduler='karras', denoise=1.0, disable_noise=False, start_step=None, last_step=None,\n             force_full_denoise=False, callback_function=None, refiner=None, refiner_switch=-1,\n             previewer_start=None, previewer_end=None, sigmas=None, noise_mean=None, disable_preview=False):\n\n    if sigmas is not None:\n        sigmas = sigmas.clone().to(ldm_patched.modules.model_management.get_torch_device())\n\n    latent_image = latent[\"samples\"]\n\n    if disable_noise:\n        noise = torch.zeros(latent_image.size(), dtype=latent_image.dtype, layout=latent_image.layout, device=\"cpu\")\n    else:\n        batch_inds = latent[\"batch_index\"] if \"batch_index\" in latent else None\n        noise = ldm_patched.modules.sample.prepare_noise(latent_image, seed, batch_inds)\n\n    if isinstance(noise_mean, torch.Tensor):\n        noise = noise + noise_mean - torch.mean(noise, dim=1, keepdim=True)\n\n    noise_mask = None\n    if \"noise_mask\" in latent:\n        noise_mask = latent[\"noise_mask\"]\n\n    previewer = get_previewer(model)\n\n    if previewer_start is None:\n        previewer_start = 0\n\n    if previewer_end is None:\n        previewer_end = steps\n\n    def callback(step, x0, x, total_steps):\n        ldm_patched.modules.model_management.throw_exception_if_processing_interrupted()\n        y = None\n        if previewer is not None and not disable_preview:\n            y = previewer(x0, previewer_start + step, previewer_end)\n        if callback_function is not None:\n            callback_function(previewer_start + step, x0, x, previewer_end, y)\n\n    disable_pbar = False\n    modules.sample_hijack.current_refiner = refiner\n    modules.sample_hijack.refiner_switch_step = refiner_switch\n    ldm_patched.modules.samplers.sample = modules.sample_hijack.sample_hacked\n\n    try:\n        samples = ldm_patched.modules.sample.sample(model,\n                                                    noise, steps, cfg, sampler_name, scheduler,\n                                                    positive, negative, latent_image,\n                                                    denoise=denoise, disable_noise=disable_noise,\n                                                    start_step=start_step,\n                                                    last_step=last_step,\n                                                    force_full_denoise=force_full_denoise, noise_mask=noise_mask,\n                                                    callback=callback,\n                                                    disable_pbar=disable_pbar, seed=seed, sigmas=sigmas)\n\n        out = latent.copy()\n        out[\"samples\"] = samples\n    finally:\n        modules.sample_hijack.current_refiner = None\n\n    return out\n\n\n@torch.no_grad()\n@torch.inference_mode()\ndef pytorch_to_numpy(x):\n    return [np.clip(255. * y.cpu().numpy(), 0, 255).astype(np.uint8) for y in x]\n\n\n@torch.no_grad()\n@torch.inference_mode()\ndef numpy_to_pytorch(x):\n    y = x.astype(np.float32) / 255.0\n    y = y[None]\n    y = np.ascontiguousarray(y.copy())\n    y = torch.from_numpy(y).float()\n    return y\n", "file_name": "192634.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "import time\nfrom abc import abstractmethod\nfrom typing import List, Tuple\n\nimport torch\nfrom huggingface_hub import hf_hub_download\nfrom PIL import Image\nfrom transformers import CLIPImageProcessor, CLIPVisionModel\n\nfrom extensions.multimodal.abstract_pipeline import AbstractMultimodalPipeline\nfrom modules import shared\nfrom modules.logging_colors import logger\nfrom modules.text_generation import encode\n\n\ndef expand2square(pil_img: Image.Image, background_color: Tuple[int]) -> Image.Image:\n    width, height = pil_img.size\n    if width == height:\n        return pil_img\n    elif width > height:\n        result = Image.new(pil_img.mode, (width, width), background_color)\n        result.paste(pil_img, (0, (width - height) // 2))\n        return result\n    else:\n        result = Image.new(pil_img.mode, (height, height), background_color)\n        result.paste(pil_img, ((height - width) // 2, 0))\n        return result\n\n\nclass LLaVA_v0_Pipeline(AbstractMultimodalPipeline):\n    CLIP_REPO = \"openai/clip-vit-large-patch14\"\n\n    def __init__(self, params: dict) -> None:\n        super().__init__()\n        self.clip_device = self._get_device(\"vision_device\", params)\n        self.clip_dtype = self._get_dtype(\"vision_bits\", params)\n        self.projector_device = self._get_device(\"projector_device\", params)\n        self.projector_dtype = self._get_dtype(\"projector_bits\", params)\n        self.image_processor, self.vision_tower, self.mm_projector = self._load_models()\n\n    def _load_models(self):\n        start_ts = time.time()\n\n        logger.info(f\"LLaVA - Loading CLIP from {self.CLIP_REPO} as {self.clip_dtype} on {self.clip_device}...\")\n        image_processor = CLIPImageProcessor.from_pretrained(self.CLIP_REPO, torch_dtype=self.clip_dtype)\n        vision_tower = CLIPVisionModel.from_pretrained(self.CLIP_REPO, torch_dtype=self.clip_dtype).to(self.clip_device)\n\n        logger.info(f\"LLaVA - Loading projector from {self.llava_projector_repo()} as {self.projector_dtype} on {self.projector_device}...\")\n        projector_path = hf_hub_download(self.llava_projector_repo(), self.llava_projector_filename())\n        mm_projector = self.build_mm_projector()\n        projector_data = torch.load(projector_path)\n        projector_data = {k[19:]: v for k, v in projector_data.items() if k.startswith('model.mm_projector.')}\n        mm_projector.load_state_dict(projector_data)\n        mm_projector = mm_projector.to(self.projector_device)\n\n        logger.info(f\"LLaVA supporting models loaded, took {time.time() - start_ts:.2f} seconds\")\n        return image_processor, vision_tower, mm_projector\n\n    def build_mm_projector(self) -> torch.nn.Module:\n        projector_shape = self.llava_projector_shape()\n        if len(projector_shape) == 2:\n            return torch.nn.Linear(*projector_shape)\n        else:\n            modules = []\n            modules.append(torch.nn.Linear(projector_shape[0], projector_shape[1]))\n            for i in range(2, len(projector_shape)):\n                modules.append(torch.nn.GELU())\n                modules.append(torch.nn.Linear(projector_shape[i-1], projector_shape[i]))\n            return torch.nn.Sequential(*modules)\n\n    @staticmethod\n    def image_start() -> str:\n        return \"<im_start>\"\n\n    @staticmethod\n    def image_end() -> str:\n        return \"<im_end>\"\n\n    @staticmethod\n    def num_image_embeds() -> int:\n        return 256\n\n    @staticmethod\n    def embed_tokens(input_ids: torch.Tensor) -> torch.Tensor:\n        for attr in ['', 'model', 'model.model', 'model.model.model']:\n            tmp = getattr(shared.model, attr, None) if attr != '' else shared.model\n            if tmp is not None and hasattr(tmp, 'embed_tokens'):\n                func = tmp.embed_tokens\n                break\n        else:\n            raise ValueError('The embed_tokens method has not been found for this loader.')\n\n        return func(input_ids).to(shared.model.device, dtype=shared.model.dtype)\n\n    @staticmethod\n    def placeholder_embeddings() -> torch.Tensor:\n        return LLaVA_v0_Pipeline.embed_tokens(encode(\"<im_patch>\"*256, add_bos_token=False)[0])\n\n    def embed_images(self, images: List[Image.Image]) -> torch.Tensor:\n        images = self.image_processor(images, return_tensors='pt')['pixel_values']\n        images = images.to(self.clip_device, dtype=self.clip_dtype)\n\n        with torch.no_grad():\n            image_forward_outs = self.vision_tower(images, output_hidden_states=True)\n            select_hidden_state_layer = -2\n            select_hidden_state = image_forward_outs.hidden_states[select_hidden_state_layer]\n            image_features = select_hidden_state[:, 1:].to(self.projector_device, dtype=self.projector_dtype)\n            image_features = self.mm_projector(image_features)\n        return image_features.to(shared.model.device, dtype=shared.model.dtype)\n\n    @staticmethod\n    @abstractmethod\n    def llava_projector_repo() -> str:\n        pass\n\n    @staticmethod\n    @abstractmethod\n    def llava_projector_filename() -> str:\n        pass\n\n    @staticmethod\n    @abstractmethod\n    def llava_projector_shape() -> Tuple[int, int]:\n        pass\n\n\nclass LLaVA_v0_13B_Pipeline(LLaVA_v0_Pipeline):\n    def __init__(self, params: dict) -> None:\n        super().__init__(params)\n\n    @staticmethod\n    def name() -> str:\n        return \"llava-13b\"\n\n    @staticmethod\n    def placeholder_token_id() -> int:\n        return 32000\n\n    @staticmethod\n    def llava_projector_shape() -> Tuple[int, int]:\n        return (1024, 5120)\n\n    @staticmethod\n    def llava_projector_filename() -> str:\n        return \"mm_projector.bin\"\n\n    @staticmethod\n    def llava_projector_repo() -> str:\n        return \"liuhaotian/LLaVA-13b-delta-v0\"\n\n\nclass LLaVA_v0_7B_Pipeline(LLaVA_v0_Pipeline):\n    def __init__(self, params: dict) -> None:\n        super().__init__(params)\n\n    @staticmethod\n    def name() -> str:\n        return \"llava-7b\"\n\n    @staticmethod\n    def placeholder_token_id() -> int:\n        return 32001\n\n    @staticmethod\n    def llava_projector_shape() -> Tuple[int, int]:\n        return (1024, 4096)\n\n    @staticmethod\n    def llava_projector_filename() -> str:\n        return \"mm_projector.bin\"\n\n    @staticmethod\n    def llava_projector_repo() -> str:\n        return \"liuhaotian/LLaVA-7b-delta-v0\"\n\n\nclass LLaVA_LLaMA_2_13B_Pipeline(LLaVA_v0_13B_Pipeline):\n    def __init__(self, params: dict) -> None:\n        super().__init__(params)\n\n    @staticmethod\n    def name() -> str:\n        return \"llava-llama-2-13b\"\n\n    @staticmethod\n    def placeholder_token_id() -> int:\n        return 0\n\n    @staticmethod\n    def llava_projector_repo() -> str:\n        return \"liuhaotian/llava-llama-2-13b-chat-lightning-preview\"\n\n    @staticmethod\n    def image_start() -> str:\n        return \"\"\n\n    @staticmethod\n    def image_end() -> str:\n        return \"\"\n\n    @staticmethod\n    def placeholder_embeddings() -> torch.Tensor:\n        return LLaVA_v0_Pipeline.embed_tokens(encode(\"<unk>\"*256, add_bos_token=False)[0])\n\n\nclass LLaVA_v1_5_13B_Pipeline(LLaVA_v0_13B_Pipeline):\n    CLIP_REPO = \"openai/clip-vit-large-patch14-336\"\n\n    def __init__(self, params: dict) -> None:\n        super().__init__(params)\n\n    @staticmethod\n    def name() -> str:\n        return \"llava-v1.5-13b\"\n\n    @staticmethod\n    def llava_projector_shape() -> Tuple[int, int]:\n        return (1024, 5120, 5120)\n\n    @staticmethod\n    def placeholder_token_id() -> int:\n        return 0\n\n    @staticmethod\n    def llava_projector_repo() -> str:\n        return \"liuhaotian/llava-v1.5-13b\"\n\n    @staticmethod\n    def image_start() -> str:\n        return \"\"\n\n    @staticmethod\n    def image_end() -> str:\n        return \"\"\n\n    @staticmethod\n    def num_image_embeds() -> int:\n        return 576\n\n    def embed_images(self, images: List[Image.Image]) -> torch.Tensor:\n        # pad it to square first\n        images = [\n            expand2square(image, tuple(int(x*255) for x in self.image_processor.image_mean))\n            for image in images\n        ]\n        return super().embed_images(images)\n\n    @staticmethod\n    def placeholder_embeddings() -> torch.Tensor:\n        return LLaVA_v0_Pipeline.embed_tokens(encode(\"<unk>\"*576, add_bos_token=False)[0])\n\nclass LLaVA_v1_5_7B_Pipeline(LLaVA_v1_5_13B_Pipeline):\n    @staticmethod\n    def name() -> str:\n        return \"llava-v1.5-7b\"\n\n    @staticmethod\n    def llava_projector_shape() -> Tuple[int, int]:\n        return (1024, 4096, 4096)\n    @staticmethod\n    def llava_projector_repo() -> str:\n        return \"liuhaotian/llava-v1.5-7b\"", "file_name": "490297.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "import asyncio\nimport json\nimport logging\nimport os\nimport traceback\nfrom collections import deque\nfrom threading import Thread\n\nimport speech_recognition as sr\nimport uvicorn\nfrom fastapi import Depends, FastAPI, Header, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.requests import Request\nfrom fastapi.responses import JSONResponse\nfrom pydub import AudioSegment\nfrom sse_starlette import EventSourceResponse\n\nimport extensions.openai.completions as OAIcompletions\nimport extensions.openai.embeddings as OAIembeddings\nimport extensions.openai.images as OAIimages\nimport extensions.openai.logits as OAIlogits\nimport extensions.openai.models as OAImodels\nimport extensions.openai.moderations as OAImoderations\nfrom extensions.openai.errors import ServiceUnavailableError\nfrom extensions.openai.tokens import token_count, token_decode, token_encode\nfrom extensions.openai.utils import _start_cloudflared\nfrom modules import shared\nfrom modules.logging_colors import logger\nfrom modules.models import unload_model\nfrom modules.text_generation import stop_everything_event\n\nfrom .typing import (\n    ChatCompletionRequest,\n    ChatCompletionResponse,\n    ChatPromptResponse,\n    CompletionRequest,\n    CompletionResponse,\n    DecodeRequest,\n    DecodeResponse,\n    EmbeddingsRequest,\n    EmbeddingsResponse,\n    EncodeRequest,\n    EncodeResponse,\n    LoadLorasRequest,\n    LoadModelRequest,\n    LogitsRequest,\n    LogitsResponse,\n    LoraListResponse,\n    ModelInfoResponse,\n    ModelListResponse,\n    TokenCountResponse,\n    to_dict\n)\n\nparams = {\n    'embedding_device': 'cpu',\n    'embedding_model': 'sentence-transformers/all-mpnet-base-v2',\n    'sd_webui_url': '',\n    'debug': 0\n}\n\n\nstreaming_semaphore = asyncio.Semaphore(1)\n\n\ndef verify_api_key(authorization: str = Header(None)) -> None:\n    expected_api_key = shared.args.api_key\n    if expected_api_key and (authorization is None or authorization != f\"Bearer {expected_api_key}\"):\n        raise HTTPException(status_code=401, detail=\"Unauthorized\")\n\n\ndef verify_admin_key(authorization: str = Header(None)) -> None:\n    expected_api_key = shared.args.admin_key\n    if expected_api_key and (authorization is None or authorization != f\"Bearer {expected_api_key}\"):\n        raise HTTPException(status_code=401, detail=\"Unauthorized\")\n\n\napp = FastAPI()\ncheck_key = [Depends(verify_api_key)]\ncheck_admin_key = [Depends(verify_admin_key)]\n\n# Configure CORS settings to allow all origins, methods, and headers\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"]\n)\n\n\n@app.options(\"/\", dependencies=check_key)\nasync def options_route():\n    return JSONResponse(content=\"OK\")\n\n\n@app.post('/v1/completions', response_model=CompletionResponse, dependencies=check_key)\nasync def openai_completions(request: Request, request_data: CompletionRequest):\n    path = request.url.path\n    is_legacy = \"/generate\" in path\n\n    if request_data.stream:\n        async def generator():\n            async with streaming_semaphore:\n                response = OAIcompletions.stream_completions(to_dict(request_data), is_legacy=is_legacy)\n                for resp in response:\n                    disconnected = await request.is_disconnected()\n                    if disconnected:\n                        break\n\n                    yield {\"data\": json.dumps(resp)}\n\n        return EventSourceResponse(generator())  # SSE streaming\n\n    else:\n        response = OAIcompletions.completions(to_dict(request_data), is_legacy=is_legacy)\n        return JSONResponse(response)\n\n\n@app.post('/v1/chat/completions', response_model=ChatCompletionResponse, dependencies=check_key)\nasync def openai_chat_completions(request: Request, request_data: ChatCompletionRequest):\n    path = request.url.path\n    is_legacy = \"/generate\" in path\n\n    if request_data.stream:\n        async def generator():\n            async with streaming_semaphore:\n                response = OAIcompletions.stream_chat_completions(to_dict(request_data), is_legacy=is_legacy)\n                for resp in response:\n                    disconnected = await request.is_disconnected()\n                    if disconnected:\n                        break\n\n                    yield {\"data\": json.dumps(resp)}\n\n        return EventSourceResponse(generator())  # SSE streaming\n\n    else:\n        response = OAIcompletions.chat_completions(to_dict(request_data), is_legacy=is_legacy)\n        return JSONResponse(response)\n\n\n@app.get(\"/v1/models\", dependencies=check_key)\n@app.get(\"/v1/models/{model}\", dependencies=check_key)\nasync def handle_models(request: Request):\n    path = request.url.path\n    is_list = request.url.path.split('?')[0].split('#')[0] == '/v1/models'\n\n    if is_list:\n        response = OAImodels.list_dummy_models()\n    else:\n        model_name = path[len('/v1/models/'):]\n        response = OAImodels.model_info_dict(model_name)\n\n    return JSONResponse(response)\n\n\n@app.get('/v1/billing/usage', dependencies=check_key)\ndef handle_billing_usage():\n    '''\n    Ex. /v1/dashboard/billing/usage?start_date=2023-05-01&end_date=2023-05-31\n    '''\n    return JSONResponse(content={\"total_usage\": 0})\n\n\n@app.post('/v1/audio/transcriptions', dependencies=check_key)\nasync def handle_audio_transcription(request: Request):\n    r = sr.Recognizer()\n\n    form = await request.form()\n    audio_file = await form[\"file\"].read()\n    audio_data = AudioSegment.from_file(audio_file)\n\n    # Convert AudioSegment to raw data\n    raw_data = audio_data.raw_data\n\n    # Create AudioData object\n    audio_data = sr.AudioData(raw_data, audio_data.frame_rate, audio_data.sample_width)\n    whisper_language = form.getvalue('language', None)\n    whisper_model = form.getvalue('model', 'tiny')  # Use the model from the form data if it exists, otherwise default to tiny\n\n    transcription = {\"text\": \"\"}\n\n    try:\n        transcription[\"text\"] = r.recognize_whisper(audio_data, language=whisper_language, model=whisper_model)\n    except sr.UnknownValueError:\n        print(\"Whisper could not understand audio\")\n        transcription[\"text\"] = \"Whisper could not understand audio UnknownValueError\"\n    except sr.RequestError as e:\n        print(\"Could not request results from Whisper\", e)\n        transcription[\"text\"] = \"Whisper could not understand audio RequestError\"\n\n    return JSONResponse(content=transcription)\n\n\n@app.post('/v1/images/generations', dependencies=check_key)\nasync def handle_image_generation(request: Request):\n\n    if not os.environ.get('SD_WEBUI_URL', params.get('sd_webui_url', '')):\n        raise ServiceUnavailableError(\"Stable Diffusion not available. SD_WEBUI_URL not set.\")\n\n    body = await request.json()\n    prompt = body['prompt']\n    size = body.get('size', '1024x1024')\n    response_format = body.get('response_format', 'url')  # or b64_json\n    n = body.get('n', 1)  # ignore the batch limits of max 10\n\n    response = await OAIimages.generations(prompt=prompt, size=size, response_format=response_format, n=n)\n    return JSONResponse(response)\n\n\n@app.post(\"/v1/embeddings\", response_model=EmbeddingsResponse, dependencies=check_key)\nasync def handle_embeddings(request: Request, request_data: EmbeddingsRequest):\n    input = request_data.input\n    if not input:\n        raise HTTPException(status_code=400, detail=\"Missing required argument input\")\n\n    if type(input) is str:\n        input = [input]\n\n    response = OAIembeddings.embeddings(input, request_data.encoding_format)\n    return JSONResponse(response)\n\n\n@app.post(\"/v1/moderations\", dependencies=check_key)\nasync def handle_moderations(request: Request):\n    body = await request.json()\n    input = body[\"input\"]\n    if not input:\n        raise HTTPException(status_code=400, detail=\"Missing required argument input\")\n\n    response = OAImoderations.moderations(input)\n    return JSONResponse(response)\n\n\n@app.post(\"/v1/internal/encode\", response_model=EncodeResponse, dependencies=check_key)\nasync def handle_token_encode(request_data: EncodeRequest):\n    response = token_encode(request_data.text)\n    return JSONResponse(response)\n\n\n@app.post(\"/v1/internal/decode\", response_model=DecodeResponse, dependencies=check_key)\nasync def handle_token_decode(request_data: DecodeRequest):\n    response = token_decode(request_data.tokens)\n    return JSONResponse(response)\n\n\n@app.post(\"/v1/internal/token-count\", response_model=TokenCountResponse, dependencies=check_key)\nasync def handle_token_count(request_data: EncodeRequest):\n    response = token_count(request_data.text)\n    return JSONResponse(response)\n\n\n@app.post(\"/v1/internal/logits\", response_model=LogitsResponse, dependencies=check_key)\nasync def handle_logits(request_data: LogitsRequest):\n    '''\n    Given a prompt, returns the top 50 most likely logits as a dict.\n    The keys are the tokens, and the values are the probabilities.\n    '''\n    response = OAIlogits._get_next_logits(to_dict(request_data))\n    return JSONResponse(response)\n\n\n@app.post('/v1/internal/chat-prompt', response_model=ChatPromptResponse, dependencies=check_key)\nasync def handle_chat_prompt(request: Request, request_data: ChatCompletionRequest):\n    path = request.url.path\n    is_legacy = \"/generate\" in path\n    generator = OAIcompletions.chat_completions_common(to_dict(request_data), is_legacy=is_legacy, prompt_only=True)\n    response = deque(generator, maxlen=1).pop()\n    return JSONResponse(response)\n\n\n@app.post(\"/v1/internal/stop-generation\", dependencies=check_key)\nasync def handle_stop_generation(request: Request):\n    stop_everything_event()\n    return JSONResponse(content=\"OK\")\n\n\n@app.get(\"/v1/internal/model/info\", response_model=ModelInfoResponse, dependencies=check_key)\nasync def handle_model_info():\n    payload = OAImodels.get_current_model_info()\n    return JSONResponse(content=payload)\n\n\n@app.get(\"/v1/internal/model/list\", response_model=ModelListResponse, dependencies=check_admin_key)\nasync def handle_list_models():\n    payload = OAImodels.list_models()\n    return JSONResponse(content=payload)\n\n\n@app.post(\"/v1/internal/model/load\", dependencies=check_admin_key)\nasync def handle_load_model(request_data: LoadModelRequest):\n    '''\n    This endpoint is experimental and may change in the future.\n\n    The \"args\" parameter can be used to modify flags like \"--load-in-4bit\"\n    or \"--n-gpu-layers\" before loading a model. Example:\n\n    ```\n    \"args\": {\n      \"load_in_4bit\": true,\n      \"n_gpu_layers\": 12\n    }\n    ```\n\n    Note that those settings will remain after loading the model. So you\n    may need to change them back to load a second model.\n\n    The \"settings\" parameter is also a dict but with keys for the\n    shared.settings object. It can be used to modify the default instruction\n    template like this:\n\n    ```\n    \"settings\": {\n      \"instruction_template\": \"Alpaca\"\n    }\n    ```\n    '''\n\n    try:\n        OAImodels._load_model(to_dict(request_data))\n        return JSONResponse(content=\"OK\")\n    except:\n        traceback.print_exc()\n        return HTTPException(status_code=400, detail=\"Failed to load the model.\")\n\n\n@app.post(\"/v1/internal/model/unload\", dependencies=check_admin_key)\nasync def handle_unload_model():\n    unload_model()\n\n\n@app.get(\"/v1/internal/lora/list\", response_model=LoraListResponse, dependencies=check_admin_key)\nasync def handle_list_loras():\n    response = OAImodels.list_loras()\n    return JSONResponse(content=response)\n\n\n@app.post(\"/v1/internal/lora/load\", dependencies=check_admin_key)\nasync def handle_load_loras(request_data: LoadLorasRequest):\n    try:\n        OAImodels.load_loras(request_data.lora_names)\n        return JSONResponse(content=\"OK\")\n    except:\n        traceback.print_exc()\n        return HTTPException(status_code=400, detail=\"Failed to apply the LoRA(s).\")\n\n\n@app.post(\"/v1/internal/lora/unload\", dependencies=check_admin_key)\nasync def handle_unload_loras():\n    OAImodels.unload_all_loras()\n    return JSONResponse(content=\"OK\")\n\n\ndef run_server():\n    server_addr = '0.0.0.0' if shared.args.listen else '127.0.0.1'\n    port = int(os.environ.get('OPENEDAI_PORT', shared.args.api_port))\n\n    ssl_certfile = os.environ.get('OPENEDAI_CERT_PATH', shared.args.ssl_certfile)\n    ssl_keyfile = os.environ.get('OPENEDAI_KEY_PATH', shared.args.ssl_keyfile)\n\n    if shared.args.public_api:\n        def on_start(public_url: str):\n            logger.info(f'OpenAI-compatible API URL:\\n\\n{public_url}\\n')\n\n        _start_cloudflared(port, shared.args.public_api_id, max_attempts=3, on_start=on_start)\n    else:\n        if ssl_keyfile and ssl_certfile:\n            logger.info(f'OpenAI-compatible API URL:\\n\\nhttps://{server_addr}:{port}\\n')\n        else:\n            logger.info(f'OpenAI-compatible API URL:\\n\\nhttp://{server_addr}:{port}\\n')\n\n    if shared.args.api_key:\n        if not shared.args.admin_key:\n            shared.args.admin_key = shared.args.api_key\n\n        logger.info(f'OpenAI API key:\\n\\n{shared.args.api_key}\\n')\n\n    if shared.args.admin_key and shared.args.admin_key != shared.args.api_key:\n        logger.info(f'OpenAI API admin key (for loading/unloading models):\\n\\n{shared.args.admin_key}\\n')\n\n    logging.getLogger(\"uvicorn.error\").propagate = False\n    uvicorn.run(app, host=server_addr, port=port, ssl_certfile=ssl_certfile, ssl_keyfile=ssl_keyfile)\n\n\ndef setup():\n    if shared.args.nowebui:\n        run_server()\n    else:\n        Thread(target=run_server, daemon=True).start()\n", "file_name": "204197.py", "cwe": ["CWE-942: Permissive Cross-domain Policy with Untrusted Domains"]}
{"source": "import importlib\nimport traceback\nfrom functools import partial\nfrom inspect import signature\n\nimport gradio as gr\n\nimport extensions\nimport modules.shared as shared\nfrom modules.logging_colors import logger\n\nstate = {}\navailable_extensions = []\nsetup_called = set()\n\n\ndef apply_settings(extension, name):\n    if not hasattr(extension, 'params'):\n        return\n\n    for param in extension.params:\n        _id = f\"{name}-{param}\"\n        shared.default_settings[_id] = extension.params[param]\n        if _id in shared.settings:\n            extension.params[param] = shared.settings[_id]\n\n\ndef load_extensions():\n    global state, setup_called\n    state = {}\n    for i, name in enumerate(shared.args.extensions):\n        if name in available_extensions:\n            if name != 'api':\n                logger.info(f'Loading the extension \"{name}\"')\n            try:\n                try:\n                    extension = importlib.import_module(f\"extensions.{name}.script\")\n                except ModuleNotFoundError:\n                    logger.error(f\"Could not import the requirements for '{name}'. Make sure to install the requirements for the extension.\\n\\n* To install requirements for all available extensions, launch the\\n  update_wizard script for your OS and choose the B option.\\n\\n* To install the requirements for this extension alone, launch the\\n  cmd script for your OS and paste the following command in the\\n  terminal window that appears:\\n\\nLinux / Mac:\\n\\npip install -r extensions/{name}/requirements.txt --upgrade\\n\\nWindows:\\n\\npip install -r extensions\\\\{name}\\\\requirements.txt --upgrade\\n\")\n                    raise\n\n                # Only run setup() and apply settings from settings.yaml once\n                if extension not in setup_called:\n                    apply_settings(extension, name)\n                    if hasattr(extension, \"setup\"):\n                        extension.setup()\n\n                    setup_called.add(extension)\n\n                state[name] = [True, i]\n            except:\n                logger.error(f'Failed to load the extension \"{name}\".')\n                traceback.print_exc()\n\n\n# This iterator returns the extensions in the order specified in the command-line\ndef iterator():\n    for name in sorted(state, key=lambda x: state[x][1]):\n        if state[name][0]:\n            yield getattr(extensions, name).script, name\n\n\n# Extension functions that map string -> string\ndef _apply_string_extensions(function_name, text, state, is_chat=False):\n    for extension, _ in iterator():\n        if hasattr(extension, function_name):\n            func = getattr(extension, function_name)\n\n            # Handle old extensions without the 'state' arg or\n            # the 'is_chat' kwarg\n            count = 0\n            has_chat = False\n            for k in signature(func).parameters:\n                if k == 'is_chat':\n                    has_chat = True\n                else:\n                    count += 1\n\n            if count == 2:\n                args = [text, state]\n            else:\n                args = [text]\n\n            if has_chat:\n                kwargs = {'is_chat': is_chat}\n            else:\n                kwargs = {}\n\n            text = func(*args, **kwargs)\n\n    return text\n\n\n# Extension functions that map string -> string\ndef _apply_chat_input_extensions(text, visible_text, state):\n    for extension, _ in iterator():\n        if hasattr(extension, 'chat_input_modifier'):\n            text, visible_text = extension.chat_input_modifier(text, visible_text, state)\n\n    return text, visible_text\n\n\n# custom_generate_chat_prompt handling - currently only the first one will work\ndef _apply_custom_generate_chat_prompt(text, state, **kwargs):\n    for extension, _ in iterator():\n        if hasattr(extension, 'custom_generate_chat_prompt'):\n            return extension.custom_generate_chat_prompt(text, state, **kwargs)\n\n    return None\n\n\n# Extension that modifies the input parameters before they are used\ndef _apply_state_modifier_extensions(state):\n    for extension, _ in iterator():\n        if hasattr(extension, \"state_modifier\"):\n            state = getattr(extension, \"state_modifier\")(state)\n\n    return state\n\n\n# Extension that modifies the chat history before it is used\ndef _apply_history_modifier_extensions(history):\n    for extension, _ in iterator():\n        if hasattr(extension, \"history_modifier\"):\n            history = getattr(extension, \"history_modifier\")(history)\n\n    return history\n\n\n# Extension functions that override the default tokenizer output - The order of execution is not defined\ndef _apply_tokenizer_extensions(function_name, state, prompt, input_ids, input_embeds):\n    for extension, _ in iterator():\n        if hasattr(extension, function_name):\n            prompt, input_ids, input_embeds = getattr(extension, function_name)(state, prompt, input_ids, input_embeds)\n\n    return prompt, input_ids, input_embeds\n\n\n# Allow extensions to add their own logits processors to the stack being run.\n# Each extension would call `processor_list.append({their LogitsProcessor}())`.\ndef _apply_logits_processor_extensions(function_name, processor_list, input_ids):\n    for extension, _ in iterator():\n        if hasattr(extension, function_name):\n            result = getattr(extension, function_name)(processor_list, input_ids)\n            if type(result) is list:\n                processor_list = result\n\n    return processor_list\n\n\n# Get prompt length in tokens after applying extension functions which override the default tokenizer output\n# currently only the first one will work\ndef _apply_custom_tokenized_length(prompt):\n    for extension, _ in iterator():\n        if hasattr(extension, 'custom_tokenized_length'):\n            return getattr(extension, 'custom_tokenized_length')(prompt)\n\n    return None\n\n\n# Custom generate reply handling - currently only the first one will work\ndef _apply_custom_generate_reply():\n    for extension, _ in iterator():\n        if hasattr(extension, 'custom_generate_reply'):\n            return getattr(extension, 'custom_generate_reply')\n\n    return None\n\n\ndef _apply_custom_css():\n    all_css = ''\n    for extension, _ in iterator():\n        if hasattr(extension, 'custom_css'):\n            all_css += getattr(extension, 'custom_css')()\n\n    return all_css\n\n\ndef _apply_custom_js():\n    all_js = ''\n    for extension, _ in iterator():\n        if hasattr(extension, 'custom_js'):\n            all_js += getattr(extension, 'custom_js')()\n\n    return all_js\n\n\ndef create_extensions_block():\n    to_display = []\n    for extension, name in iterator():\n        if hasattr(extension, \"ui\") and not (hasattr(extension, 'params') and extension.params.get('is_tab', False)):\n            to_display.append((extension, name))\n\n    # Creating the extension ui elements\n    if len(to_display) > 0:\n        with gr.Column(elem_id=\"extensions\"):\n            for row in to_display:\n                extension, _ = row\n                extension.ui()\n\n\ndef create_extensions_tabs():\n    for extension, name in iterator():\n        if hasattr(extension, \"ui\") and (hasattr(extension, 'params') and extension.params.get('is_tab', False)):\n            display_name = getattr(extension, 'params', {}).get('display_name', name)\n            with gr.Tab(display_name, elem_classes=\"extension-tab\"):\n                extension.ui()\n\n\nEXTENSION_MAP = {\n    \"input\": partial(_apply_string_extensions, \"input_modifier\"),\n    \"output\": partial(_apply_string_extensions, \"output_modifier\"),\n    \"chat_input\": _apply_chat_input_extensions,\n    \"state\": _apply_state_modifier_extensions,\n    \"history\": _apply_history_modifier_extensions,\n    \"bot_prefix\": partial(_apply_string_extensions, \"bot_prefix_modifier\"),\n    \"tokenizer\": partial(_apply_tokenizer_extensions, \"tokenizer_modifier\"),\n    'logits_processor': partial(_apply_logits_processor_extensions, 'logits_processor_modifier'),\n    \"custom_generate_chat_prompt\": _apply_custom_generate_chat_prompt,\n    \"custom_generate_reply\": _apply_custom_generate_reply,\n    \"tokenized_length\": _apply_custom_tokenized_length,\n    \"css\": _apply_custom_css,\n    \"js\": _apply_custom_js\n}\n\n\ndef apply_extensions(typ, *args, **kwargs):\n    if typ not in EXTENSION_MAP:\n        raise ValueError(f\"Invalid extension type {typ}\")\n\n    return EXTENSION_MAP[typ](*args, **kwargs)\n", "file_name": "813380.py", "cwe": ["CWE-706: Use of Incorrectly-Resolved Name or Reference"]}
{"source": "import argparse\nimport os\nfrom threading import Lock\nfrom typing import Generator, List, Optional\n\nimport torch\nimport uvicorn\nfrom coati.models import generate_streaming\nfrom coati.quant import llama_load_quant, low_resource_init\nfrom fastapi import FastAPI, Request\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, Field\nfrom slowapi import Limiter, _rate_limit_exceeded_handler\nfrom slowapi.errors import RateLimitExceeded\nfrom slowapi.util import get_remote_address\nfrom sse_starlette.sse import EventSourceResponse\nfrom transformers import AutoConfig, AutoModelForCausalLM, AutoTokenizer\nfrom utils import ChatPromptProcessor, Dialogue, LockedIterator, load_json, update_model_kwargs_fn\n\nMAX_LEN = 512\nrunning_lock = Lock()\n\n\nclass GenerationTaskReq(BaseModel):\n    max_new_tokens: int = Field(gt=0, le=512, example=64)\n    history: List[Dialogue] = Field(min_items=1)\n    top_k: Optional[int] = Field(default=None, gt=0, example=50)\n    top_p: Optional[float] = Field(default=None, gt=0.0, lt=1.0, example=0.5)\n    temperature: Optional[float] = Field(default=None, gt=0.0, lt=1.0, example=0.7)\n    repetition_penalty: Optional[float] = Field(default=None, gt=1.0, example=1.2)\n\n\nlimiter = Limiter(key_func=get_remote_address)\napp = FastAPI()\napp.state.limiter = limiter\napp.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)\n\n# set CORS\norigin_spec_from_env = os.environ.get(\"CORS_ORIGIN\", None)\n\nif origin_spec_from_env is not None:\n    # allow CORS from the specified origins\n    origins = os.environ[\"CORS_ORIGIN\"].split(\",\")\nelse:\n    # allow CORS from all origins\n    origins = [\"*\"]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\ndef generate_streamingly(prompt, max_length, max_new_tokens, top_k, top_p, temperature):\n    input_ids = tokenizer(prompt, return_tensors=\"pt\")[\"input_ids\"]\n    # TODO(ver217): streaming generation does not support repetition_penalty now\n    model_kwargs = {\n        \"max_new_tokens\": max_new_tokens,\n        \"early_stopping\": True,\n        \"top_k\": top_k,\n        \"top_p\": top_p,\n        \"temperature\": temperature,\n        \"prepare_inputs_fn\": None,\n        \"update_model_kwargs_fn\": update_model_kwargs_fn,\n    }\n    is_first_word = True\n    generator = LockedIterator(\n        generate_streaming(model, input_ids, tokenizer, max_length, **model_kwargs), running_lock\n    )\n    for output in generator:\n        output = output.cpu()\n        tokens = tokenizer.convert_ids_to_tokens(output, skip_special_tokens=True)\n        current_sub_tokens = []\n        for token in tokens:\n            if token in tokenizer.all_special_tokens:\n                continue\n            current_sub_tokens.append(token)\n        if current_sub_tokens:\n            out_string = tokenizer.sp_model.decode(current_sub_tokens)\n            if is_first_word:\n                out_string = out_string.lstrip()\n                is_first_word = False\n            elif current_sub_tokens[0].startswith(\"\u2581\"):\n                # whitespace will be ignored by the frontend\n                out_string = \" \" + out_string\n            yield out_string\n\n\nasync def event_generator(request: Request, generator: Generator):\n    while True:\n        if await request.is_disconnected():\n            break\n        try:\n            yield {\"event\": \"generate\", \"data\": next(generator)}\n        except StopIteration:\n            yield {\"event\": \"end\", \"data\": \"\"}\n            break\n\n\n@app.post(\"/generate/stream\")\n@limiter.limit(\"1/second\")\ndef generate(data: GenerationTaskReq, request: Request):\n    prompt = prompt_processor.preprocess_prompt(data.history)\n    event_source = event_generator(\n        request,\n        generate_streamingly(prompt, data.max_length, data.max_new_tokens, data.top_k, data.top_p, data.temperature),\n    )\n    return EventSourceResponse(event_source)\n\n\n@app.post(\"/generate\")\n@limiter.limit(\"1/second\")\ndef generate_no_stream(data: GenerationTaskReq, request: Request):\n    prompt = prompt_processor.preprocess_prompt(data.history, data.max_new_tokens)\n    if prompt_processor.has_censored_words(prompt):\n        return prompt_processor.SAFE_RESPONSE\n    inputs = {k: v.cuda() for k, v in tokenizer(prompt, return_tensors=\"pt\").items()}\n    with running_lock:\n        output = model.generate(**inputs, **data.dict(exclude={\"history\"}))\n    output = output.cpu()\n    prompt_len = inputs[\"input_ids\"].size(1)\n    response = output[0, prompt_len:]\n    out_string = tokenizer.decode(response, skip_special_tokens=True)\n    out_string = prompt_processor.postprocess_output(out_string)\n    if prompt_processor.has_censored_words(out_string):\n        return prompt_processor.SAFE_RESPONSE\n    return out_string\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"pretrained\",\n        help=\"Path to pretrained model. Can be a local path or a model name from the HuggingFace model hub.\",\n    )\n    parser.add_argument(\n        \"--tokenizer_path\",\n        help=\"Path to pretrained tokenizer. Can be a local path or a model name from the HuggingFace model hub.\",\n        default=None,\n    )\n    parser.add_argument(\n        \"--quant\",\n        choices=[\"8bit\", \"4bit\"],\n        default=None,\n        help=\"Quantization mode. Default: None (no quantization, fp16).\",\n    )\n    parser.add_argument(\n        \"--gptq_checkpoint\",\n        default=None,\n        help=\"Path to GPTQ checkpoint. This is only useful when quantization mode is 4bit. Default: None.\",\n    )\n    parser.add_argument(\n        \"--gptq_group_size\",\n        type=int,\n        default=128,\n        help=\"Group size for GPTQ. This is only useful when quantization mode is 4bit. Default: 128.\",\n    )\n    parser.add_argument(\"--http_host\", default=\"0.0.0.0\")\n    parser.add_argument(\"--http_port\", type=int, default=7070)\n    parser.add_argument(\n        \"--profanity_file\",\n        default=None,\n        help=\"Path to profanity words list. It should be a JSON file containing a list of words.\",\n    )\n    args = parser.parse_args()\n\n    if args.quant == \"4bit\":\n        assert args.gptq_checkpoint is not None, \"Please specify a GPTQ checkpoint.\"\n\n    if args.tokenizer_path is None:\n        args.tokenizer_path = args.pretrained\n    tokenizer = AutoTokenizer.from_pretrained(args.tokenizer_path, local_files_only=True)\n\n    if args.profanity_file is not None:\n        censored_words = load_json(args.profanity_file)\n    else:\n        censored_words = []\n    prompt_processor = ChatPromptProcessor(censored_words=censored_words)\n\n    if args.quant == \"4bit\":\n        with low_resource_init():\n            config = AutoConfig.from_pretrained(args.pretrained)\n            model = AutoModelForCausalLM(config)\n        model = llama_load_quant(model, args.gptq_checkpoint, 4, args.gptq_group_size)\n        model.cuda()\n    else:\n        model = AutoModelForCausalLM.from_pretrained(\n            args.pretrained,\n            load_in_8bit=(args.quant == \"8bit\"),\n            torch_dtype=torch.float16,\n            device_map=\"auto\",\n            local_files_only=True,\n        )\n        if args.quant != \"8bit\":\n            model.half()  # seems to fix bugs for some users.\n        model.eval()\n\n    config = uvicorn.Config(app, host=args.http_host, port=args.http_port)\n    server = uvicorn.Server(config=config)\n    server.run()\n\n\n\"\"\"\npython server.py /home/lcyab/data/models/experiments5/checkpoint/experiment5-2023-10-20-21-53-51/modeling/ --tokenizer_path /mnt/vepfs/lcxyc/leaderboard_models/Colossal-LLaMA-2-7b-base/\n\"\"\"\n", "file_name": "041528.py", "cwe": ["CWE-942: Permissive Cross-domain Policy with Untrusted Domains"]}
{"source": "\"\"\"\nAPI and LLM warpper class for running LLMs locally\n\nUsage:\n\nimport os\nmodel_path = os.environ.get(\"ZH_MODEL_PATH\")\nmodel_name = \"chatglm2\"\ncolossal_api = ColossalAPI(model_name, model_path)\nllm = ColossalLLM(n=1, api=colossal_api)\nTEST_PROMPT_CHATGLM=\"\u7eed\u5199\u6587\u7ae0\uff1a\u60ca\u86f0\u4e00\u8fc7\uff0c\u6625\u5bd2\u52a0\u5267\u3002\u5148\u662f\u6599\u6599\u5ced\u5ced\uff0c\u7ee7\u800c\u96e8\u5b63\u5f00\u59cb\uff0c\"\nlogger.info(llm(TEST_PROMPT_CHATGLM, max_new_tokens=100), verbose=True)\n\n\"\"\"\n\nfrom typing import Any, List, Mapping, Optional\n\nimport torch\nfrom colossalqa.local.utils import get_response, post_http_request\nfrom colossalqa.mylogging import get_logger\nfrom langchain.callbacks.manager import CallbackManagerForLLMRun\nfrom langchain.llms.base import LLM\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\nlogger = get_logger()\n\n\nclass ColossalAPI:\n    \"\"\"\n    API for calling LLM.generate\n    \"\"\"\n\n    __instances = dict()\n\n    def __init__(self, model_type: str, model_path: str, ckpt_path: str = None) -> None:\n        \"\"\"\n        Configure model\n        \"\"\"\n        if model_type + model_path + (ckpt_path or \"\") in ColossalAPI.__instances:\n            return\n        else:\n            ColossalAPI.__instances[model_type + model_path + (ckpt_path or \"\")] = self\n        self.model_type = model_type\n        self.model = AutoModelForCausalLM.from_pretrained(model_path, torch_dtype=torch.float16, trust_remote_code=True)\n\n        if ckpt_path is not None:\n            state_dict = torch.load(ckpt_path)\n            self.model.load_state_dict(state_dict)\n        self.model.to(torch.cuda.current_device())\n\n        # Configure tokenizer\n        self.tokenizer = AutoTokenizer.from_pretrained(model_path, trust_remote_code=True)\n\n        self.model.eval()\n\n    @staticmethod\n    def get_api(model_type: str, model_path: str, ckpt_path: str = None):\n        if model_type + model_path + (ckpt_path or \"\") in ColossalAPI.__instances:\n            return ColossalAPI.__instances[model_type + model_path + (ckpt_path or \"\")]\n        else:\n            return ColossalAPI(model_type, model_path, ckpt_path)\n\n    def generate(self, input: str, **kwargs) -> str:\n        \"\"\"\n        Generate response given the prompt\n        Args:\n            input: input string\n            **kwargs: language model keyword type arguments, such as top_k, top_p, temperature, max_new_tokens...\n        Returns:\n            output: output string\n        \"\"\"\n        if self.model_type in [\"chatglm\", \"chatglm2\"]:\n            inputs = {\n                k: v.to(torch.cuda.current_device()) for k, v in self.tokenizer(input, return_tensors=\"pt\").items()\n            }\n        else:\n            inputs = {\n                \"input_ids\": self.tokenizer(input, return_tensors=\"pt\")[\"input_ids\"].to(torch.cuda.current_device())\n            }\n\n        output = self.model.generate(**inputs, **kwargs)\n        output = output.cpu()\n        prompt_len = inputs[\"input_ids\"].size(1)\n        response = output[0, prompt_len:]\n        output = self.tokenizer.decode(response, skip_special_tokens=True)\n        return output\n\n\nclass VllmAPI:\n    def __init__(self, host: str = \"localhost\", port: int = 8077) -> None:\n        # Configure api for model served through web\n        self.host = host\n        self.port = port\n        self.url = f\"http://{self.host}:{self.port}/generate\"\n\n    def generate(self, input: str, **kwargs):\n        output = get_response(post_http_request(input, self.url, **kwargs))[0]\n        return output[len(input) :]\n\n\nclass ColossalLLM(LLM):\n    \"\"\"\n    Langchain LLM wrapper for a local LLM\n    \"\"\"\n\n    n: int\n    api: Any\n    kwargs = {\"max_new_tokens\": 100}\n\n    @property\n    def _llm_type(self) -> str:\n        return \"custom\"\n\n    def _call(\n        self,\n        prompt: str,\n        stop: Optional[List[str]] = None,\n        run_manager: Optional[CallbackManagerForLLMRun] = None,\n        **kwargs: Any,\n    ) -> str:\n        logger.info(f\"kwargs:{kwargs}\\nstop:{stop}\\nprompt:{prompt}\", verbose=self.verbose)\n        for k in self.kwargs:\n            if k not in kwargs:\n                kwargs[k] = self.kwargs[k]\n\n        generate_args = {k: kwargs[k] for k in kwargs if k not in [\"stop\", \"n\"]}\n        out = self.api.generate(prompt, **generate_args)\n        if isinstance(stop, list) and len(stop) != 0:\n            for stopping_words in stop:\n                if stopping_words in out:\n                    out = out.split(stopping_words)[0]\n        logger.info(f\"{prompt}{out}\", verbose=self.verbose)\n        return out\n\n    @property\n    def _identifying_params(self) -> Mapping[str, int]:\n        \"\"\"Get the identifying parameters.\"\"\"\n        return {\"n\": self.n}\n\n    def get_token_ids(self, text: str) -> List[int]:\n        \"\"\"Return the ordered ids of the tokens in a text.\n\n        Args:\n            text: The string input to tokenize.\n\n        Returns:\n            A list of ids corresponding to the tokens in the text, in order they occur\n                in the text.\n        \"\"\"\n        # use the colossal llm's tokenizer instead of langchain's cached GPT2 tokenizer\n        return self.api.tokenizer.encode(text)\n\n\nclass VllmLLM(LLM):\n    \"\"\"\n    Langchain LLM wrapper for a local LLM\n    \"\"\"\n\n    n: int\n    api: Any\n    kwargs = {\"max_new_tokens\": 100}\n\n    @property\n    def _llm_type(self) -> str:\n        return \"custom\"\n\n    def _call(\n        self,\n        prompt: str,\n        stop: Optional[List[str]] = None,\n        run_manager: Optional[CallbackManagerForLLMRun] = None,\n        **kwargs: Any,\n    ) -> str:\n        for k in self.kwargs:\n            if k not in kwargs:\n                kwargs[k] = self.kwargs[k]\n        logger.info(f\"kwargs:{kwargs}\\nstop:{stop}\\nprompt:{prompt}\", verbose=self.verbose)\n        generate_args = {k: kwargs[k] for k in kwargs if k in [\"n\", \"max_tokens\", \"temperature\", \"stream\"]}\n        out = self.api.generate(prompt, **generate_args)\n        if len(stop) != 0:\n            for stopping_words in stop:\n                if stopping_words in out:\n                    out = out.split(stopping_words)[0]\n        logger.info(f\"{prompt}{out}\", verbose=self.verbose)\n        return out\n\n    def set_host_port(self, host: str = \"localhost\", port: int = 8077, **kwargs) -> None:\n        if \"max_tokens\" not in kwargs:\n            kwargs[\"max_tokens\"] = 100\n        self.kwargs = kwargs\n        self.api = VllmAPI(host=host, port=port)\n\n    @property\n    def _identifying_params(self) -> Mapping[str, int]:\n        \"\"\"Get the identifying parameters.\"\"\"\n        return {\"n\": self.n}\n", "file_name": "693973.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "import linecache\nimport os\nimport sys\nimport traceback\nimport warnings\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional, Union\n\nimport torch\nimport torch.fx\nimport torch.nn as nn\nfrom torch.fx.graph import PythonCode\n\ntry:\n    from torch.fx.graph import _PyTreeCodeGen\n\n    SUPPORT_PT_CODEGEN = True\nexcept ImportError:\n    SUPPORT_PT_CODEGEN = False\n\nfrom torch.fx.graph_module import _exec_with_source, _forward_from_src\nfrom torch.nn.modules.module import _addindent\n\n\n# This is a copy of torch.fx.graph_module._WrappedCall.\n# It should be removed when we stop supporting torch < 1.12.0.\nclass _WrappedCall:\n    def __init__(self, cls, cls_call):\n        self.cls = cls\n        self.cls_call = cls_call\n\n    # Previously, if an error occurred when valid\n    # symbolically-traced code was run with an invalid input, the\n    # user would see the source of the error as coming from\n    # `File \"<eval_with_key_N\">`, where N is some number. We use\n    # this function to generate a more informative error message. We\n    # return the traceback itself, a message explaining that the\n    # error occurred in a traced Module's generated forward\n    # function, and five lines of context surrounding the faulty\n    # line\n    @staticmethod\n    def _generate_error_message(frame_summary: traceback.FrameSummary) -> str:\n        # auxiliary variables (for readability)\n        err_lineno = frame_summary.lineno\n        assert err_lineno is not None\n        line = frame_summary.line\n        assert line is not None\n        err_line_len = len(line)\n        all_src_lines = linecache.getlines(frame_summary.filename)\n\n        # constituent substrings of the error message\n        tb_repr = traceback.format_exc()\n        custom_msg = (\n            \"Call using an FX-traced Module, \"\n            f\"line {err_lineno} of the traced Module's \"\n            \"generated forward function:\"\n        )\n        before_err = \"\".join(all_src_lines[err_lineno - 2 : err_lineno])\n        marker = \"~\" * err_line_len + \"~~~ <--- HERE\"\n        err_and_after_err = \"\\n\".join(all_src_lines[err_lineno : err_lineno + 2])\n\n        # joined message\n        return \"\\n\".join([tb_repr, custom_msg, before_err, marker, err_and_after_err])\n\n    def __call__(self, obj, *args, **kwargs):\n        try:\n            if self.cls_call is not None:\n                return self.cls_call(obj, *args, **kwargs)\n            else:\n                return super(self.cls, obj).__call__(*args, **kwargs)  # type: ignore[misc]\n        except Exception as e:\n            assert e.__traceback__\n            topmost_framesummary: traceback.FrameSummary = traceback.StackSummary.extract(\n                traceback.walk_tb(e.__traceback__)\n            )[\n                -1\n            ]  # type: ignore[arg-type]\n            if \"eval_with_key\" in topmost_framesummary.filename:\n                print(_WrappedCall._generate_error_message(topmost_framesummary), file=sys.stderr)\n                raise e.with_traceback(None)\n            else:\n                raise e\n\n\nclass ColoGraphModule(torch.fx.GraphModule):\n    \"\"\"\n    ColoGraphGraphModule is an nn.Module generated from an fx.Graph.\n    ColoGraphmodule has a ``graph`` attribute, as well as ``code`` and ``forward``\n    attributes generated from that ``graph``.\n\n    The difference between ``ColoGraphModule`` and ``torch.fx.GraphModule`` is that\n    ``ColoGraphModule`` has a ``bind()`` function to bind customized functions\n    (i.e. activation checkpoint) to ``code`` of ``nn.Module``. If you want to use\n    specific features in Colossal-AI that are not supported by ``torch.fx.GraphModule``,\n    you can use ``ColoGraphModule`` instead.\n\n    ``colossalai.fx.symbolic_trace()`` will return a ``ColoGraphModule`` as default.\n\n    .. warning::\n\n        When ``graph`` is reassigned, ``code`` and ``forward`` will be automatically\n        regenerated. However, if you edit the contents of the ``graph`` without reassigning\n        the ``graph`` attribute itself, you must call ``recompile()`` to update the generated\n        code.\n    \"\"\"\n\n    def __init__(\n        self, root: Union[torch.nn.Module, Dict[str, Any]], graph: torch.fx.Graph, class_name: str = \"GraphModule\"\n    ):\n        super().__init__(root, graph, class_name)\n\n    def bind(self, ckpt_def, globals):\n        \"\"\"Bind function needed for correctly execute ``GraphModule.forward()``\n\n        We need to bind checkpoint functions to ``ColoGraphModule`` so that we could\n        correctly execute ``GraphModule.forward()``\n\n        Args:\n            ckpt_def (List[str]): definition before the forward function\n            globals (Dict[str, Any]): global variables\n        \"\"\"\n\n        ckpt_code = \"\\n\".join(ckpt_def)\n        globals_copy = globals.copy()\n        _exec_with_source(ckpt_code, globals_copy)\n        func_list = [func for func in globals_copy.keys() if \"checkpoint\" in func or \"pack\" in func]\n        for func in func_list:\n            tmp_func = globals_copy[func]\n            setattr(self, func, tmp_func.__get__(self, self.__class__))\n            del globals_copy[func]\n\n    def recompile(self) -> PythonCode:\n        \"\"\"\n        Recompile this GraphModule from its ``graph`` attribute. This should be\n        called after editing the contained ``graph``, otherwise the generated\n        code of this ``GraphModule`` will be out of date.\n        \"\"\"\n        if SUPPORT_PT_CODEGEN and isinstance(self._graph._codegen, _PyTreeCodeGen):\n            self._in_spec = self._graph._codegen.pytree_info.in_spec\n            self._out_spec = self._graph._codegen.pytree_info.out_spec\n        python_code = self._graph.python_code(root_module=\"self\")\n        self._code = python_code.src\n\n        # To split ckpt functions code and forward code\n        _code_list = self._code.split(\"\\n\")\n        _fwd_def = [item for item in _code_list if \"def forward\" in item][0]\n        _fwd_idx = _code_list.index(_fwd_def)\n        ckpt_def = _code_list[:_fwd_idx]\n        self._code = \"\\n\".join(_code_list[_fwd_idx:])\n\n        self.bind(ckpt_def, python_code.globals)\n\n        cls = type(self)\n        cls.forward = _forward_from_src(self._code, python_code.globals)\n\n        # Determine whether this class explicitly defines a __call__ implementation\n        # to wrap. If it does, save it in order to have wrapped_call invoke it.\n        # If it does not, wrapped_call can use a dynamic call to super() instead.\n        # In most cases, super().__call__ should be torch.nn.Module.__call__.\n        # We do not want to hold a reference to Module.__call__ here; doing so will\n        # bypass patching of torch.nn.Module.__call__ done while symbolic tracing.\n        cls_call = cls.__call__ if \"__call__\" in vars(cls) else None\n\n        if \"_wrapped_call\" not in vars(cls):\n            cls._wrapped_call = _WrappedCall(cls, cls_call)  # type: ignore[attr-defined]\n\n        def call_wrapped(self, *args, **kwargs):\n            return self._wrapped_call(self, *args, **kwargs)\n\n        cls.__call__ = call_wrapped\n\n        # reset self._code to original src, otherwise to_folder will be wrong\n        self._code = python_code.src\n        return python_code\n\n    def to_folder(self, folder: Union[str, os.PathLike], module_name: str = \"FxModule\"):\n        \"\"\"Dumps out module to ``folder`` with ``module_name`` so that it can be\n        imported with ``from <folder> import <module_name>``\n\n        Args:\n\n            folder (Union[str, os.PathLike]): The folder to write the code out to\n\n            module_name (str): Top-level name to use for the ``Module`` while\n                writing out the code\n        \"\"\"\n        folder = Path(folder)\n        Path(folder).mkdir(exist_ok=True)\n        torch.save(self.state_dict(), folder / \"state_dict.pt\")\n        tab = \" \" * 4\n\n        # we add import colossalai here\n        model_str = f\"\"\"\nimport torch\nfrom torch.nn import *\nimport colossalai\n\n\nclass {module_name}(torch.nn.Module):\n    def __init__(self):\n        super().__init__()\n\"\"\"\n\n        def _gen_model_repr(module_name: str, module: torch.nn.Module) -> Optional[str]:\n            safe_reprs = [nn.Linear, nn.Conv1d, nn.Conv2d, nn.Conv3d, nn.BatchNorm1d, nn.BatchNorm2d, nn.BatchNorm3d]\n            if type(module) in safe_reprs:\n                return f\"{module.__repr__()}\"\n            else:\n                return None\n\n        blobified_modules = []\n        for module_name, module in self.named_children():\n            module_str = _gen_model_repr(module_name, module)\n            if module_str is None:\n                module_file = folder / f\"{module_name}.pt\"\n                torch.save(module, module_file)\n                blobified_modules.append(module_name)\n                module_repr = module.__repr__().replace(\"\\r\", \" \").replace(\"\\n\", \" \")\n                module_str = f\"torch.load(r'{module_file}') # {module_repr}\"\n            model_str += f\"{tab*2}self.{module_name} = {module_str}\\n\"\n\n        for buffer_name, buffer in self._buffers.items():\n            if buffer is None:\n                continue\n            model_str += f\"{tab*2}self.register_buffer('{buffer_name}', torch.empty({list(buffer.shape)}, dtype={buffer.dtype}))\\n\"\n\n        for param_name, param in self._parameters.items():\n            if param is None:\n                continue\n            model_str += f\"{tab*2}self.{param_name} = torch.nn.Parameter(torch.empty({list(param.shape)}, dtype={param.dtype}))\\n\"\n\n        model_str += f\"{tab*2}self.load_state_dict(torch.load(r'{folder}/state_dict.pt'))\\n\"\n        model_str += f\"{_addindent(self.code, 4)}\\n\"\n\n        module_file = folder / \"module.py\"\n        module_file.write_text(model_str)\n\n        init_file = folder / \"__init__.py\"\n        init_file.write_text(\"from .module import *\")\n\n        if len(blobified_modules) > 0:\n            warnings.warn(\n                \"Was not able to save the following children modules as reprs -\"\n                f\"saved as pickled files instead: {blobified_modules}\"\n            )\n", "file_name": "514256.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "from __future__ import annotations\n\nimport logging\nfrom collections.abc import Iterable\nfrom typing import NotRequired, TypedDict\n\nfrom django.db.models.query import QuerySet\nfrom django.http import Http404, HttpResponse, StreamingHttpResponse\nfrom rest_framework.request import Request\nfrom rest_framework.response import Response\nfrom symbolic.debuginfo import normalize_debug_id\nfrom symbolic.exceptions import SymbolicError\n\nfrom sentry import ratelimits\nfrom sentry.api.api_owners import ApiOwner\nfrom sentry.api.api_publish_status import ApiPublishStatus\nfrom sentry.api.base import region_silo_endpoint\nfrom sentry.api.bases.project import ProjectEndpoint, ProjectReleasePermission\nfrom sentry.api.endpoints.debug_files import has_download_permission\nfrom sentry.api.serializers import serialize\nfrom sentry.auth.system import is_system_auth\nfrom sentry.debug_files.artifact_bundles import (\n    MAX_BUNDLES_QUERY,\n    query_artifact_bundles_containing_file,\n)\nfrom sentry.lang.native.sources import get_internal_artifact_lookup_source_url\nfrom sentry.models.artifactbundle import NULL_STRING, ArtifactBundle\nfrom sentry.models.distribution import Distribution\nfrom sentry.models.project import Project\nfrom sentry.models.release import Release\nfrom sentry.models.releasefile import ReleaseFile\nfrom sentry.utils import metrics\n\nlogger = logging.getLogger(\"sentry.api\")\n\n# The marker for \"release\" bundles\nRELEASE_BUNDLE_TYPE = \"release.bundle\"\n# The number of files returned by the `get_releasefiles` query\nMAX_RELEASEFILES_QUERY = 10\n\n\nclass _Artifact(TypedDict):\n    id: str\n    type: str\n    url: str\n    resolved_with: str\n    abs_path: NotRequired[str]\n    headers: NotRequired[dict[str, object]]\n\n\n@region_silo_endpoint\nclass ProjectArtifactLookupEndpoint(ProjectEndpoint):\n    owner = ApiOwner.OWNERS_INGEST\n    publish_status = {\n        \"GET\": ApiPublishStatus.PRIVATE,\n    }\n    permission_classes = (ProjectReleasePermission,)\n\n    def download_file(self, download_id, project: Project):\n        split = download_id.split(\"/\")\n        if len(split) < 2:\n            raise Http404\n        ty, ty_id, *_rest = split\n\n        rate_limited = ratelimits.backend.is_limited(\n            project=project,\n            key=f\"rl:ArtifactLookupEndpoint:download:{download_id}:{project.id}\",\n            limit=10,\n        )\n        if rate_limited:\n            logger.info(\n                \"notification.rate_limited\",\n                extra={\"project_id\": project.id, \"file_id\": download_id},\n            )\n            return HttpResponse({\"Too many download requests\"}, status=429)\n\n        file_m: ArtifactBundle | ReleaseFile | None = None\n        if ty == \"artifact_bundle\":\n            file_m = (\n                ArtifactBundle.objects.filter(\n                    id=ty_id,\n                    projectartifactbundle__project_id=project.id,\n                )\n                .select_related(\"file\")\n                .first()\n            )\n            metrics.incr(\"sourcemaps.download.artifact_bundle\")\n        elif ty == \"release_file\":\n            # NOTE: `ReleaseFile` does have a `project_id`, but that seems to\n            # be always empty, so using the `organization_id` instead.\n            file_m = (\n                ReleaseFile.objects.filter(id=ty_id, organization_id=project.organization.id)\n                .select_related(\"file\")\n                .first()\n            )\n            metrics.incr(\"sourcemaps.download.release_file\")\n\n        if file_m is None:\n            raise Http404\n        file = file_m.file\n\n        try:\n            fp = file.getfile()\n            response = StreamingHttpResponse(\n                iter(lambda: fp.read(4096), b\"\"), content_type=\"application/octet-stream\"\n            )\n            response[\"Content-Length\"] = file.size\n            response[\"Content-Disposition\"] = f'attachment; filename=\"{file.name}\"'\n            return response\n        except OSError:\n            raise Http404\n\n    def get(self, request: Request, project: Project) -> Response:\n        \"\"\"\n        List a Project's Individual Artifacts or Bundles\n        ````````````````````````````````````````\n\n        Retrieve a list of individual artifacts or artifact bundles for a given project.\n\n        :pparam string organization_id_or_slug: the id or slug of the organization to query.\n        :pparam string project_id_or_slug: the id or slug of the project to query.\n        :qparam string debug_id: if set, will query and return the artifact\n                                 bundle that matches the given `debug_id`.\n        :qparam string url: if set, will query and return all the individual\n                            artifacts, or artifact bundles that contain files\n                            that match the `url`. This is using a substring-match.\n        :qparam string release: used in conjunction with `url`.\n        :qparam string dist: used in conjunction with `url`.\n\n        :auth: required\n        \"\"\"\n        if (download_id := request.GET.get(\"download\")) is not None:\n            if has_download_permission(request, project):\n                return self.download_file(download_id, project)\n            else:\n                return Response(status=403)\n\n        debug_id = request.GET.get(\"debug_id\")\n        try:\n            debug_id = normalize_debug_id(debug_id)\n        except SymbolicError:\n            pass\n        url = request.GET.get(\"url\") or NULL_STRING\n        release_name = request.GET.get(\"release\") or NULL_STRING\n        dist_name = request.GET.get(\"dist\") or NULL_STRING\n\n        # First query all the files:\n        # We first do that using the `ArtifactBundle` infrastructure.\n        artifact_bundles = query_artifact_bundles_containing_file(\n            project, release_name, dist_name, url, debug_id\n        )\n        all_bundles: dict[str, str] = {\n            f\"artifact_bundle/{bundle_id}\": resolved for bundle_id, resolved in artifact_bundles\n        }\n\n        # If no `ArtifactBundle`s were found matching the file, we fall back to\n        # looking up the file using the legacy `ReleaseFile` infrastructure.\n        individual_files: Iterable[ReleaseFile] = []\n        if not artifact_bundles:\n            release, dist = try_resolve_release_dist(project, release_name, dist_name)\n            if release:\n                metrics.incr(\"sourcemaps.lookup.release_file\")\n                for releasefile_id in get_legacy_release_bundles(release, dist):\n                    all_bundles[f\"release_file/{releasefile_id}\"] = \"release-old\"\n                individual_files = get_legacy_releasefile_by_file_url(release, dist, url)\n\n        # Then: Construct our response\n        url_constructor = UrlConstructor(request, project)\n\n        found_artifacts: list[_Artifact] = []\n        for download_id, resolved_with in all_bundles.items():\n            found_artifacts.append(\n                {\n                    \"id\": download_id,\n                    \"type\": \"bundle\",\n                    \"url\": url_constructor.url_for_file_id(download_id),\n                    \"resolved_with\": resolved_with,\n                }\n            )\n\n        for release_file in individual_files:\n            download_id = f\"release_file/{release_file.id}\"\n            found_artifacts.append(\n                {\n                    \"id\": download_id,\n                    \"type\": \"file\",\n                    \"url\": url_constructor.url_for_file_id(download_id),\n                    # The `name` is the url/abs_path of the file,\n                    # as in: `\"~/path/to/file.min.js\"`.\n                    \"abs_path\": release_file.name,\n                    # These headers should ideally include the `Sourcemap` reference\n                    \"headers\": release_file.file.headers,\n                    \"resolved_with\": \"release-old\",\n                }\n            )\n\n        # make sure we have a stable sort order for tests\n        def natural_sort(key: str) -> tuple[str, int]:\n            split = key.split(\"/\")\n            if len(split) > 1:\n                ty, ty_id = split\n                return (ty, int(ty_id))\n            else:\n                return (\"\", int(split[0]))\n\n        found_artifacts.sort(key=lambda x: natural_sort(x[\"id\"]))\n\n        # NOTE: We do not paginate this response, as we have very tight limits on all the individual queries.\n        return Response(serialize(found_artifacts, request.user))\n\n\ndef try_resolve_release_dist(\n    project: Project, release_name: str, dist_name: str\n) -> tuple[Release | None, Distribution | None]:\n    release = None\n    dist = None\n    try:\n        release = Release.objects.get(\n            organization_id=project.organization_id,\n            projects=project,\n            version=release_name,\n        )\n\n        # We cannot query for dist without a release anyway\n        if dist_name:\n            dist = Distribution.objects.get(release=release, name=dist_name)\n    except (Release.DoesNotExist, Distribution.DoesNotExist):\n        pass\n    except Exception:\n        logger.exception(\"Failed to read\")\n\n    return release, dist\n\n\ndef get_legacy_release_bundles(release: Release, dist: Distribution | None) -> set[int]:\n    return set(\n        ReleaseFile.objects.filter(\n            release_id=release.id,\n            dist_id=dist.id if dist else None,\n            # a `ReleaseFile` with `0` artifacts represents a release archive,\n            # see the comment above the definition of `artifact_count`.\n            artifact_count=0,\n            # similarly the special `type` is also used for release archives.\n            file__type=RELEASE_BUNDLE_TYPE,\n        ).values_list(\"id\", flat=True)\n        # TODO: this `order_by` might be incredibly slow\n        # we want to have a hard limit on the returned bundles here. and we would\n        # want to pick the most recently uploaded ones. that should mostly be\n        # relevant for customers that upload multiple bundles, or are uploading\n        # newer files for existing releases. In that case the symbolication is\n        # already degraded, so meh...\n        # .order_by(\"-file__timestamp\")\n        [:MAX_BUNDLES_QUERY]\n    )\n\n\ndef get_legacy_releasefile_by_file_url(\n    release: Release, dist: Distribution | None, url: str\n) -> QuerySet[ReleaseFile]:\n    # Exclude files which are also present in archive:\n    return (\n        ReleaseFile.public_objects.filter(\n            release_id=release.id,\n            dist_id=dist.id if dist else None,\n        )\n        .exclude(artifact_count=0)\n        .select_related(\"file\")\n    ).filter(name__icontains=url)[:MAX_RELEASEFILES_QUERY]\n\n\nclass UrlConstructor:\n    def __init__(self, request: Request, project: Project):\n        if is_system_auth(request.auth):\n            self.base_url = get_internal_artifact_lookup_source_url(project)\n        else:\n            self.base_url = request.build_absolute_uri(request.path)\n\n    def url_for_file_id(self, download_id: str) -> str:\n        # NOTE: Returning a self-route that requires authentication (via Bearer token)\n        # is not really forward compatible with a pre-signed URL that does not\n        # require any authentication or headers whatsoever.\n        # This also requires a workaround in Symbolicator, as its generic http\n        # downloader blocks \"internal\" IPs, whereas the internal Sentry downloader\n        # is explicitly exempt.\n        return f\"{self.base_url}?download={download_id}\"\n", "file_name": "610060.py", "cwe": ["CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"]}
{"source": "from __future__ import annotations\n\nfrom collections import defaultdict\nfrom collections.abc import Sequence\nfrom datetime import timedelta\nfrom email.headerregistry import Address\nfrom functools import reduce\nfrom typing import Any\n\nfrom django.db.models import Q\nfrom django.utils import timezone\nfrom rest_framework import status\nfrom rest_framework.request import Request\nfrom rest_framework.response import Response\n\nfrom sentry import roles\nfrom sentry.api.api_owners import ApiOwner\nfrom sentry.api.api_publish_status import ApiPublishStatus\nfrom sentry.api.base import region_silo_endpoint\nfrom sentry.api.bases.organization import OrganizationEndpoint, OrganizationPermission\nfrom sentry.api.serializers import Serializer, serialize\nfrom sentry.constants import ObjectStatus\nfrom sentry.integrations.base import IntegrationFeatures\nfrom sentry.integrations.services.integration import integration_service\nfrom sentry.models.commitauthor import CommitAuthor\nfrom sentry.models.organization import Organization\n\nFILTERED_EMAILS = {\n    \"%%@gmail.com\",\n    \"%%@yahoo.com\",\n    \"%%@icloud.com\",\n    \"%%@hotmail.com\",\n    \"%%@outlook.com\",\n    \"%%@noreply.github.com\",\n    \"%%@localhost\",\n    \"action@github.com\",\n}\n\nFILTERED_CHARACTERS = {\"+\"}\n\n\nclass MissingOrgMemberSerializer(Serializer):\n    def serialize(self, obj, attrs, user, **kwargs):\n        formatted_external_id = _format_external_id(obj.external_id)\n\n        return {\n            \"email\": obj.email,\n            \"externalId\": formatted_external_id,\n            \"commitCount\": obj.commit__count,\n        }\n\n\nclass MissingMembersPermission(OrganizationPermission):\n    scope_map = {\"GET\": [\"org:write\"]}\n\n\ndef _format_external_id(external_id: str | None) -> str | None:\n    formatted_external_id = external_id\n\n    if external_id is not None and \":\" in external_id:\n        formatted_external_id = external_id.split(\":\")[1]\n\n    return formatted_external_id\n\n\ndef _get_missing_organization_members(\n    organization: Organization,\n    provider: str,\n    integration_ids: Sequence[int],\n    shared_domain: str | None,\n) -> list[Any]:\n    org_id = organization.id\n    domain_query = \"\"\n    if shared_domain:\n        domain_query = (\n            f\"AND (UPPER(sentry_commitauthor.email::text) LIKE UPPER('%%{shared_domain}'))\"\n        )\n    else:\n        for filtered_email in FILTERED_EMAILS:\n            domain_query += (\n                f\"AND (UPPER(sentry_commitauthor.email::text) NOT LIKE UPPER('{filtered_email}')) \"\n            )\n\n    date_added = (timezone.now() - timedelta(days=30)).strftime(\"%Y-%m-%d, %H:%M:%S\")\n\n    query = \"\"\"\n        SELECT sentry_commitauthor.id, sentry_commitauthor.organization_id, sentry_commitauthor.name, sentry_commitauthor.email, sentry_commitauthor.external_id, COUNT(sentry_commit.id) AS commit__count FROM sentry_commitauthor\n        INNER JOIN (\n            select * from sentry_commit\n            WHERE sentry_commit.organization_id = %(org_id)s\n            AND date_added >= %(date_added)s\n            order by date_added desc limit 1000\n        ) as sentry_commit ON sentry_commitauthor.id = sentry_commit.author_id\n\n        WHERE sentry_commit.repository_id IN\n        (\n            select id\n            from sentry_repository\n            where provider = %(provider)s\n            and organization_id = %(org_id)s\n            and integration_id in %(integration_ids)s\n        )\n        AND sentry_commit.author_id IN\n            (select id from sentry_commitauthor\n                WHERE sentry_commitauthor.organization_id = %(org_id)s\n                AND NOT (\n                    (UPPER(sentry_commitauthor.email::text) IN (select coalesce(UPPER(email), UPPER(user_email)) from sentry_organizationmember where organization_id = %(org_id)s and (email is not null or user_email is not null)\n                )\n        OR sentry_commitauthor.external_id IS NULL))\n    \"\"\"\n    # adding the extra domain query here prevents django raw from putting extra quotations around it\n    query += domain_query\n    query += \"\"\"\n        AND NOT (UPPER(sentry_commitauthor.email::text) LIKE UPPER('%%+%%'))\n        )\n\n        GROUP BY sentry_commitauthor.id ORDER BY commit__count DESC limit 50\"\"\"\n\n    param_dict = {\n        \"org_id\": org_id,\n        \"date_added\": date_added,\n        \"provider\": \"integrations:\" + provider,\n        \"integration_ids\": tuple(integration_ids),\n    }\n\n    return list(CommitAuthor.objects.raw(query, param_dict))\n\n\ndef _get_shared_email_domain(organization: Organization) -> str | None:\n    # if a member has user_email=None, then they have yet to accept an invite\n    org_owners = organization.get_members_with_org_roles(roles=[roles.get_top_dog().id]).exclude(\n        Q(user_email=None) | Q(user_email=\"\")\n    )\n\n    def _get_email_domain(email: str) -> str | None:\n        try:\n            domain = Address(addr_spec=email).domain\n        except Exception:\n            return None\n\n        return domain\n\n    owner_email_domains = {_get_email_domain(owner.user_email) for owner in org_owners}\n\n    # all owners have the same email domain\n    if len(owner_email_domains) == 1:\n        return owner_email_domains.pop()\n\n    return None\n\n\n@region_silo_endpoint\nclass OrganizationMissingMembersEndpoint(OrganizationEndpoint):\n    owner = ApiOwner.ECOSYSTEM\n    publish_status = {\n        \"GET\": ApiPublishStatus.EXPERIMENTAL,\n    }\n\n    permission_classes = (MissingMembersPermission,)\n\n    def get(self, request: Request, organization: Organization) -> Response:\n        # ensure the organization has an integration with the commit feature\n        integrations = integration_service.get_integrations(\n            organization_id=organization.id, status=ObjectStatus.ACTIVE\n        )\n\n        def provider_reducer(dict, integration):\n            if not integration.has_feature(feature=IntegrationFeatures.COMMITS):\n                return dict\n            if dict.get(integration.provider):\n                dict[integration.provider].append(integration.id)\n            else:\n                dict[integration.provider] = [integration.id]\n\n            return dict\n\n        integration_provider_to_ids: dict[str, Sequence[int]] = reduce(\n            provider_reducer, integrations, defaultdict(list)\n        )\n\n        shared_domain = _get_shared_email_domain(organization)\n\n        missing_org_members = []\n\n        for integration_provider, integration_ids in integration_provider_to_ids.items():\n            # TODO(cathy): allow other integration providers\n            if integration_provider != \"github\":\n                continue\n\n            queryset = _get_missing_organization_members(\n                organization, integration_provider, integration_ids, shared_domain\n            )\n\n            missing_members_for_integration = {\n                \"integration\": integration_provider,\n                \"users\": serialize(queryset, request.user, serializer=MissingOrgMemberSerializer()),\n            }\n\n            missing_org_members.append(missing_members_for_integration)\n\n        return Response(\n            missing_org_members,\n            status=status.HTTP_200_OK,\n        )\n", "file_name": "239585.py", "cwe": ["CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"]}
{"source": "from typing import Any\n\nfrom django.db.models import Q\nfrom drf_spectacular.utils import extend_schema\nfrom rest_framework.exceptions import ParseError\nfrom rest_framework.request import Request\nfrom rest_framework.response import Response\n\nfrom sentry.api.api_publish_status import ApiPublishStatus\nfrom sentry.api.base import EnvironmentMixin, region_silo_endpoint\nfrom sentry.api.bases.organization import OrganizationAndStaffPermission, OrganizationEndpoint\nfrom sentry.api.paginator import OffsetPaginator\nfrom sentry.api.serializers import serialize\nfrom sentry.api.serializers.models.project import (\n    OrganizationProjectResponse,\n    ProjectSummarySerializer,\n)\nfrom sentry.apidocs.constants import RESPONSE_FORBIDDEN, RESPONSE_NOT_FOUND, RESPONSE_UNAUTHORIZED\nfrom sentry.apidocs.examples.organization_examples import OrganizationExamples\nfrom sentry.apidocs.parameters import CursorQueryParam, GlobalParams\nfrom sentry.apidocs.utils import inline_sentry_response_serializer\nfrom sentry.constants import ObjectStatus\nfrom sentry.models.project import Project\nfrom sentry.models.team import Team\nfrom sentry.search.utils import tokenize_query\nfrom sentry.snuba import discover, metrics_enhanced_performance, metrics_performance\n\nERR_INVALID_STATS_PERIOD = \"Invalid stats_period. Valid choices are '', '24h', '14d', and '30d'\"\n\nDATASETS = {\n    \"\": discover,  # in case they pass an empty query string fall back on default\n    \"discover\": discover,\n    \"metricsEnhanced\": metrics_enhanced_performance,\n    \"metrics\": metrics_performance,\n}\n\n\ndef get_dataset(dataset_label: str) -> Any:\n    if dataset_label not in DATASETS:\n        raise ParseError(detail=f\"dataset must be one of: {', '.join(DATASETS.keys())}\")\n    return DATASETS[dataset_label]\n\n\n@extend_schema(tags=[\"Organizations\"])\n@region_silo_endpoint\nclass OrganizationProjectsEndpoint(OrganizationEndpoint, EnvironmentMixin):\n    publish_status = {\n        \"GET\": ApiPublishStatus.PUBLIC,\n    }\n    permission_classes = (OrganizationAndStaffPermission,)\n\n    @extend_schema(\n        operation_id=\"List an Organization's Projects\",\n        parameters=[GlobalParams.ORG_ID_OR_SLUG, CursorQueryParam],\n        request=None,\n        responses={\n            200: inline_sentry_response_serializer(\n                \"OrganizationProjectResponseDict\", list[OrganizationProjectResponse]\n            ),\n            401: RESPONSE_UNAUTHORIZED,\n            403: RESPONSE_FORBIDDEN,\n            404: RESPONSE_NOT_FOUND,\n        },\n        examples=OrganizationExamples.LIST_PROJECTS,\n    )\n    def get(self, request: Request, organization) -> Response:\n        \"\"\"\n        Return a list of projects bound to a organization.\n        \"\"\"\n        stats_period = request.GET.get(\"statsPeriod\")\n        collapse = request.GET.getlist(\"collapse\", [])\n        if stats_period not in (None, \"\", \"1h\", \"24h\", \"7d\", \"14d\", \"30d\"):\n            return Response(\n                {\"error\": {\"params\": {\"stats_period\": {\"message\": ERR_INVALID_STATS_PERIOD}}}},\n                status=400,\n            )\n        elif not stats_period:\n            # disable stats\n            stats_period = None\n\n        datasetName = request.GET.get(\"dataset\", \"discover\")\n        dataset = get_dataset(datasetName)\n\n        if request.auth and not request.user.is_authenticated:\n            # TODO: remove this, no longer supported probably\n            if hasattr(request.auth, \"project\"):\n                queryset = Project.objects.filter(id=request.auth.project.id)\n            elif request.auth.organization_id is not None:\n                org = request.auth.organization_id\n                team_list = list(Team.objects.filter(organization_id=org))\n                queryset = Project.objects.filter(teams__in=team_list)\n            else:\n                return Response(\n                    {\"detail\": \"Current access does not point to \" \"organization.\"}, status=400\n                )\n        else:\n            queryset = Project.objects.filter(organization=organization)\n\n        order_by = [\"slug\"]\n\n        if request.user.is_authenticated:\n            queryset = queryset.extra(\n                select={\n                    \"is_bookmarked\": \"\"\"exists (\n                        select *\n                        from sentry_projectbookmark spb\n                        where spb.project_id = sentry_project.id and spb.user_id = %s\n                    )\"\"\"\n                },\n                select_params=(request.user.id,),\n            )\n            order_by.insert(0, \"-is_bookmarked\")\n\n        query = request.GET.get(\"query\")\n        if query:\n            tokens = tokenize_query(query)\n            for key, value in tokens.items():\n                if key == \"query\":\n                    value = \" \".join(value)\n                    queryset = queryset.filter(Q(name__icontains=value) | Q(slug__icontains=value))\n                elif key == \"id\":\n                    if all(v.isdigit() for v in value):\n                        queryset = queryset.filter(id__in=value)\n                    else:\n                        return Response(\n                            {\n                                \"error\": {\n                                    \"params\": {\n                                        \"stats_period\": {\n                                            \"message\": \"All 'id' values must be integers.\"\n                                        }\n                                    }\n                                }\n                            },\n                            status=400,\n                        )\n                elif key == \"slug\":\n                    queryset = queryset.filter(slug__in=value)\n                elif key == \"team\":\n                    team_list = list(Team.objects.filter(organization=organization, slug__in=value))\n                    queryset = queryset.filter(teams__in=team_list)\n                elif key == \"!team\":\n                    team_list = list(Team.objects.filter(organization=organization, slug__in=value))\n                    queryset = queryset.exclude(teams__in=team_list)\n                elif key == \"is_member\":\n                    queryset = queryset.filter(teams__organizationmember__user_id=request.user.id)\n                else:\n                    queryset = queryset.none()\n\n        queryset = queryset.filter(status=ObjectStatus.ACTIVE).distinct()\n\n        # TODO(davidenwang): remove this after frontend requires only paginated projects\n        get_all_projects = request.GET.get(\"all_projects\") == \"1\"\n\n        if get_all_projects:\n            queryset = queryset.order_by(\"slug\").select_related(\"organization\")\n            return Response(\n                serialize(\n                    list(queryset),\n                    request.user,\n                    ProjectSummarySerializer(collapse=collapse, dataset=dataset),\n                )\n            )\n        else:\n            expand = set()\n            if request.GET.get(\"transactionStats\"):\n                expand.add(\"transaction_stats\")\n            if request.GET.get(\"sessionStats\"):\n                expand.add(\"session_stats\")\n\n            expand_context = {\"options\": request.GET.getlist(\"options\") or []}\n            if expand_context:\n                expand.add(\"options\")\n\n            def serialize_on_result(result):\n                environment_id = self._get_environment_id_from_request(request, organization.id)\n                serializer = ProjectSummarySerializer(\n                    environment_id=environment_id,\n                    stats_period=stats_period,\n                    expand=expand,\n                    expand_context=expand_context,\n                    collapse=collapse,\n                    dataset=dataset,\n                )\n                return serialize(result, request.user, serializer)\n\n            return self.paginate(\n                request=request,\n                queryset=queryset,\n                order_by=order_by,\n                on_results=serialize_on_result,\n                paginator_cls=OffsetPaginator,\n            )\n\n\n@region_silo_endpoint\nclass OrganizationProjectsCountEndpoint(OrganizationEndpoint, EnvironmentMixin):\n    publish_status = {\n        \"GET\": ApiPublishStatus.PRIVATE,\n    }\n\n    def get(self, request: Request, organization) -> Response:\n        queryset = Project.objects.filter(organization=organization)\n\n        all_projects = queryset.count()\n        my_projects = queryset.filter(teams__organizationmember__user_id=request.user.id).count()\n\n        return Response({\"allProjects\": all_projects, \"myProjects\": my_projects})\n", "file_name": "557095.py", "cwe": ["CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"]}
{"source": "import torch\nimport pytorch_lightning as pl\nimport torch.nn.functional as F\nfrom contextlib import contextmanager\n\nfrom ldm.modules.diffusionmodules.model import Encoder, Decoder\nfrom ldm.modules.distributions.distributions import DiagonalGaussianDistribution\n\nfrom ldm.util import instantiate_from_config\nfrom ldm.modules.ema import LitEma\n\n\nclass AutoencoderKL(pl.LightningModule):\n    def __init__(self,\n                 ddconfig,\n                 lossconfig,\n                 embed_dim,\n                 ckpt_path=None,\n                 ignore_keys=[],\n                 image_key=\"image\",\n                 colorize_nlabels=None,\n                 monitor=None,\n                 ema_decay=None,\n                 learn_logvar=False\n                 ):\n        super().__init__()\n        self.learn_logvar = learn_logvar\n        self.image_key = image_key\n        self.encoder = Encoder(**ddconfig)\n        self.decoder = Decoder(**ddconfig)\n        self.loss = instantiate_from_config(lossconfig)\n        assert ddconfig[\"double_z\"]\n        self.quant_conv = torch.nn.Conv2d(2*ddconfig[\"z_channels\"], 2*embed_dim, 1)\n        self.post_quant_conv = torch.nn.Conv2d(embed_dim, ddconfig[\"z_channels\"], 1)\n        self.embed_dim = embed_dim\n        if colorize_nlabels is not None:\n            assert type(colorize_nlabels)==int\n            self.register_buffer(\"colorize\", torch.randn(3, colorize_nlabels, 1, 1))\n        if monitor is not None:\n            self.monitor = monitor\n\n        self.use_ema = ema_decay is not None\n        if self.use_ema:\n            self.ema_decay = ema_decay\n            assert 0. < ema_decay < 1.\n            self.model_ema = LitEma(self, decay=ema_decay)\n            print(f\"Keeping EMAs of {len(list(self.model_ema.buffers()))}.\")\n\n        if ckpt_path is not None:\n            self.init_from_ckpt(ckpt_path, ignore_keys=ignore_keys)\n\n    def init_from_ckpt(self, path, ignore_keys=list()):\n        sd = torch.load(path, map_location=\"cpu\")[\"state_dict\"]\n        keys = list(sd.keys())\n        for k in keys:\n            for ik in ignore_keys:\n                if k.startswith(ik):\n                    print(\"Deleting key {} from state_dict.\".format(k))\n                    del sd[k]\n        self.load_state_dict(sd, strict=False)\n        print(f\"Restored from {path}\")\n\n    @contextmanager\n    def ema_scope(self, context=None):\n        if self.use_ema:\n            self.model_ema.store(self.parameters())\n            self.model_ema.copy_to(self)\n            if context is not None:\n                print(f\"{context}: Switched to EMA weights\")\n        try:\n            yield None\n        finally:\n            if self.use_ema:\n                self.model_ema.restore(self.parameters())\n                if context is not None:\n                    print(f\"{context}: Restored training weights\")\n\n    def on_train_batch_end(self, *args, **kwargs):\n        if self.use_ema:\n            self.model_ema(self)\n\n    def encode(self, x):\n        h = self.encoder(x)\n        moments = self.quant_conv(h)\n        posterior = DiagonalGaussianDistribution(moments)\n        return posterior\n\n    def decode(self, z):\n        z = self.post_quant_conv(z)\n        dec = self.decoder(z)\n        return dec\n\n    def forward(self, input, sample_posterior=True):\n        posterior = self.encode(input)\n        if sample_posterior:\n            z = posterior.sample()\n        else:\n            z = posterior.mode()\n        dec = self.decode(z)\n        return dec, posterior\n\n    def get_input(self, batch, k):\n        x = batch[k]\n        if len(x.shape) == 3:\n            x = x[..., None]\n        x = x.permute(0, 3, 1, 2).to(memory_format=torch.contiguous_format).float()\n        return x\n\n    def training_step(self, batch, batch_idx, optimizer_idx):\n        inputs = self.get_input(batch, self.image_key)\n        reconstructions, posterior = self(inputs)\n\n        if optimizer_idx == 0:\n            # train encoder+decoder+logvar\n            aeloss, log_dict_ae = self.loss(inputs, reconstructions, posterior, optimizer_idx, self.global_step,\n                                            last_layer=self.get_last_layer(), split=\"train\")\n            self.log(\"aeloss\", aeloss, prog_bar=True, logger=True, on_step=True, on_epoch=True)\n            self.log_dict(log_dict_ae, prog_bar=False, logger=True, on_step=True, on_epoch=False)\n            return aeloss\n\n        if optimizer_idx == 1:\n            # train the discriminator\n            discloss, log_dict_disc = self.loss(inputs, reconstructions, posterior, optimizer_idx, self.global_step,\n                                                last_layer=self.get_last_layer(), split=\"train\")\n\n            self.log(\"discloss\", discloss, prog_bar=True, logger=True, on_step=True, on_epoch=True)\n            self.log_dict(log_dict_disc, prog_bar=False, logger=True, on_step=True, on_epoch=False)\n            return discloss\n\n    def validation_step(self, batch, batch_idx):\n        log_dict = self._validation_step(batch, batch_idx)\n        with self.ema_scope():\n            log_dict_ema = self._validation_step(batch, batch_idx, postfix=\"_ema\")\n        return log_dict\n\n    def _validation_step(self, batch, batch_idx, postfix=\"\"):\n        inputs = self.get_input(batch, self.image_key)\n        reconstructions, posterior = self(inputs)\n        aeloss, log_dict_ae = self.loss(inputs, reconstructions, posterior, 0, self.global_step,\n                                        last_layer=self.get_last_layer(), split=\"val\"+postfix)\n\n        discloss, log_dict_disc = self.loss(inputs, reconstructions, posterior, 1, self.global_step,\n                                            last_layer=self.get_last_layer(), split=\"val\"+postfix)\n\n        self.log(f\"val{postfix}/rec_loss\", log_dict_ae[f\"val{postfix}/rec_loss\"])\n        self.log_dict(log_dict_ae)\n        self.log_dict(log_dict_disc)\n        return self.log_dict\n\n    def configure_optimizers(self):\n        lr = self.learning_rate\n        ae_params_list = list(self.encoder.parameters()) + list(self.decoder.parameters()) + list(\n            self.quant_conv.parameters()) + list(self.post_quant_conv.parameters())\n        if self.learn_logvar:\n            print(f\"{self.__class__.__name__}: Learning logvar\")\n            ae_params_list.append(self.loss.logvar)\n        opt_ae = torch.optim.Adam(ae_params_list,\n                                  lr=lr, betas=(0.5, 0.9))\n        opt_disc = torch.optim.Adam(self.loss.discriminator.parameters(),\n                                    lr=lr, betas=(0.5, 0.9))\n        return [opt_ae, opt_disc], []\n\n    def get_last_layer(self):\n        return self.decoder.conv_out.weight\n\n    @torch.no_grad()\n    def log_images(self, batch, only_inputs=False, log_ema=False, **kwargs):\n        log = dict()\n        x = self.get_input(batch, self.image_key)\n        x = x.to(self.device)\n        if not only_inputs:\n            xrec, posterior = self(x)\n            if x.shape[1] > 3:\n                # colorize with random projection\n                assert xrec.shape[1] > 3\n                x = self.to_rgb(x)\n                xrec = self.to_rgb(xrec)\n            log[\"samples\"] = self.decode(torch.randn_like(posterior.sample()))\n            log[\"reconstructions\"] = xrec\n            if log_ema or self.use_ema:\n                with self.ema_scope():\n                    xrec_ema, posterior_ema = self(x)\n                    if x.shape[1] > 3:\n                        # colorize with random projection\n                        assert xrec_ema.shape[1] > 3\n                        xrec_ema = self.to_rgb(xrec_ema)\n                    log[\"samples_ema\"] = self.decode(torch.randn_like(posterior_ema.sample()))\n                    log[\"reconstructions_ema\"] = xrec_ema\n        log[\"inputs\"] = x\n        return log\n\n    def to_rgb(self, x):\n        assert self.image_key == \"segmentation\"\n        if not hasattr(self, \"colorize\"):\n            self.register_buffer(\"colorize\", torch.randn(3, x.shape[1], 1, 1).to(x))\n        x = F.conv2d(x, weight=self.colorize)\n        x = 2.*(x-x.min())/(x.max()-x.min()) - 1.\n        return x\n\n\nclass IdentityFirstStage(torch.nn.Module):\n    def __init__(self, *args, vq_interface=False, **kwargs):\n        self.vq_interface = vq_interface\n        super().__init__()\n\n    def encode(self, x, *args, **kwargs):\n        return x\n\n    def decode(self, x, *args, **kwargs):\n        return x\n\n    def quantize(self, x, *args, **kwargs):\n        if self.vq_interface:\n            return x, None, [None, None, None]\n        return x\n\n    def forward(self, x, *args, **kwargs):\n        return x\n\n", "file_name": "299989.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "\"\"\"make variations of input image\"\"\"\n\nimport argparse, os\nimport PIL\nimport torch\nimport numpy as np\nfrom omegaconf import OmegaConf\nfrom PIL import Image\nfrom tqdm import tqdm, trange\nfrom itertools import islice\nfrom einops import rearrange, repeat\nfrom torchvision.utils import make_grid\nfrom torch import autocast\nfrom contextlib import nullcontext\nfrom pytorch_lightning import seed_everything\nfrom imwatermark import WatermarkEncoder\n\n\nfrom scripts.txt2img import put_watermark\nfrom ldm.util import instantiate_from_config\nfrom ldm.models.diffusion.ddim import DDIMSampler\n\n\ndef chunk(it, size):\n    it = iter(it)\n    return iter(lambda: tuple(islice(it, size)), ())\n\n\ndef load_model_from_config(config, ckpt, verbose=False):\n    print(f\"Loading model from {ckpt}\")\n    pl_sd = torch.load(ckpt, map_location=\"cpu\")\n    if \"global_step\" in pl_sd:\n        print(f\"Global Step: {pl_sd['global_step']}\")\n    sd = pl_sd[\"state_dict\"]\n    model = instantiate_from_config(config.model)\n    m, u = model.load_state_dict(sd, strict=False)\n    if len(m) > 0 and verbose:\n        print(\"missing keys:\")\n        print(m)\n    if len(u) > 0 and verbose:\n        print(\"unexpected keys:\")\n        print(u)\n\n    model.cuda()\n    model.eval()\n    return model\n\n\ndef load_img(path):\n    image = Image.open(path).convert(\"RGB\")\n    w, h = image.size\n    print(f\"loaded input image of size ({w}, {h}) from {path}\")\n    w, h = map(lambda x: x - x % 64, (w, h))  # resize to integer multiple of 64\n    image = image.resize((w, h), resample=PIL.Image.LANCZOS)\n    image = np.array(image).astype(np.float32) / 255.0\n    image = image[None].transpose(0, 3, 1, 2)\n    image = torch.from_numpy(image)\n    return 2. * image - 1.\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument(\n        \"--prompt\",\n        type=str,\n        nargs=\"?\",\n        default=\"a painting of a virus monster playing guitar\",\n        help=\"the prompt to render\"\n    )\n\n    parser.add_argument(\n        \"--init-img\",\n        type=str,\n        nargs=\"?\",\n        help=\"path to the input image\"\n    )\n\n    parser.add_argument(\n        \"--outdir\",\n        type=str,\n        nargs=\"?\",\n        help=\"dir to write results to\",\n        default=\"outputs/img2img-samples\"\n    )\n\n    parser.add_argument(\n        \"--ddim_steps\",\n        type=int,\n        default=50,\n        help=\"number of ddim sampling steps\",\n    )\n\n    parser.add_argument(\n        \"--fixed_code\",\n        action='store_true',\n        help=\"if enabled, uses the same starting code across all samples \",\n    )\n\n    parser.add_argument(\n        \"--ddim_eta\",\n        type=float,\n        default=0.0,\n        help=\"ddim eta (eta=0.0 corresponds to deterministic sampling\",\n    )\n    parser.add_argument(\n        \"--n_iter\",\n        type=int,\n        default=1,\n        help=\"sample this often\",\n    )\n\n    parser.add_argument(\n        \"--C\",\n        type=int,\n        default=4,\n        help=\"latent channels\",\n    )\n    parser.add_argument(\n        \"--f\",\n        type=int,\n        default=8,\n        help=\"downsampling factor, most often 8 or 16\",\n    )\n\n    parser.add_argument(\n        \"--n_samples\",\n        type=int,\n        default=2,\n        help=\"how many samples to produce for each given prompt. A.k.a batch size\",\n    )\n\n    parser.add_argument(\n        \"--n_rows\",\n        type=int,\n        default=0,\n        help=\"rows in the grid (default: n_samples)\",\n    )\n\n    parser.add_argument(\n        \"--scale\",\n        type=float,\n        default=9.0,\n        help=\"unconditional guidance scale: eps = eps(x, empty) + scale * (eps(x, cond) - eps(x, empty))\",\n    )\n\n    parser.add_argument(\n        \"--strength\",\n        type=float,\n        default=0.8,\n        help=\"strength for noising/unnoising. 1.0 corresponds to full destruction of information in init image\",\n    )\n\n    parser.add_argument(\n        \"--from-file\",\n        type=str,\n        help=\"if specified, load prompts from this file\",\n    )\n    parser.add_argument(\n        \"--config\",\n        type=str,\n        default=\"configs/stable-diffusion/v2-inference.yaml\",\n        help=\"path to config which constructs model\",\n    )\n    parser.add_argument(\n        \"--ckpt\",\n        type=str,\n        help=\"path to checkpoint of model\",\n    )\n    parser.add_argument(\n        \"--seed\",\n        type=int,\n        default=42,\n        help=\"the seed (for reproducible sampling)\",\n    )\n    parser.add_argument(\n        \"--precision\",\n        type=str,\n        help=\"evaluate at this precision\",\n        choices=[\"full\", \"autocast\"],\n        default=\"autocast\"\n    )\n\n    opt = parser.parse_args()\n    seed_everything(opt.seed)\n\n    config = OmegaConf.load(f\"{opt.config}\")\n    model = load_model_from_config(config, f\"{opt.ckpt}\")\n\n    device = torch.device(\"cuda\") if torch.cuda.is_available() else torch.device(\"cpu\")\n    model = model.to(device)\n\n    sampler = DDIMSampler(model)\n\n    os.makedirs(opt.outdir, exist_ok=True)\n    outpath = opt.outdir\n\n    print(\"Creating invisible watermark encoder (see https://github.com/ShieldMnt/invisible-watermark)...\")\n    wm = \"SDV2\"\n    wm_encoder = WatermarkEncoder()\n    wm_encoder.set_watermark('bytes', wm.encode('utf-8'))\n\n    batch_size = opt.n_samples\n    n_rows = opt.n_rows if opt.n_rows > 0 else batch_size\n    if not opt.from_file:\n        prompt = opt.prompt\n        assert prompt is not None\n        data = [batch_size * [prompt]]\n\n    else:\n        print(f\"reading prompts from {opt.from_file}\")\n        with open(opt.from_file, \"r\") as f:\n            data = f.read().splitlines()\n            data = list(chunk(data, batch_size))\n\n    sample_path = os.path.join(outpath, \"samples\")\n    os.makedirs(sample_path, exist_ok=True)\n    base_count = len(os.listdir(sample_path))\n    grid_count = len(os.listdir(outpath)) - 1\n\n    assert os.path.isfile(opt.init_img)\n    init_image = load_img(opt.init_img).to(device)\n    init_image = repeat(init_image, '1 ... -> b ...', b=batch_size)\n    init_latent = model.get_first_stage_encoding(model.encode_first_stage(init_image))  # move to latent space\n\n    sampler.make_schedule(ddim_num_steps=opt.ddim_steps, ddim_eta=opt.ddim_eta, verbose=False)\n\n    assert 0. <= opt.strength <= 1., 'can only work with strength in [0.0, 1.0]'\n    t_enc = int(opt.strength * opt.ddim_steps)\n    print(f\"target t_enc is {t_enc} steps\")\n\n    precision_scope = autocast if opt.precision == \"autocast\" else nullcontext\n    with torch.no_grad():\n        with precision_scope(\"cuda\"):\n            with model.ema_scope():\n                all_samples = list()\n                for n in trange(opt.n_iter, desc=\"Sampling\"):\n                    for prompts in tqdm(data, desc=\"data\"):\n                        uc = None\n                        if opt.scale != 1.0:\n                            uc = model.get_learned_conditioning(batch_size * [\"\"])\n                        if isinstance(prompts, tuple):\n                            prompts = list(prompts)\n                        c = model.get_learned_conditioning(prompts)\n\n                        # encode (scaled latent)\n                        z_enc = sampler.stochastic_encode(init_latent, torch.tensor([t_enc] * batch_size).to(device))\n                        # decode it\n                        samples = sampler.decode(z_enc, c, t_enc, unconditional_guidance_scale=opt.scale,\n                                                 unconditional_conditioning=uc, )\n\n                        x_samples = model.decode_first_stage(samples)\n                        x_samples = torch.clamp((x_samples + 1.0) / 2.0, min=0.0, max=1.0)\n\n                        for x_sample in x_samples:\n                            x_sample = 255. * rearrange(x_sample.cpu().numpy(), 'c h w -> h w c')\n                            img = Image.fromarray(x_sample.astype(np.uint8))\n                            img = put_watermark(img, wm_encoder)\n                            img.save(os.path.join(sample_path, f\"{base_count:05}.png\"))\n                            base_count += 1\n                        all_samples.append(x_samples)\n\n                # additionally, save as grid\n                grid = torch.stack(all_samples, 0)\n                grid = rearrange(grid, 'n b c h w -> (n b) c h w')\n                grid = make_grid(grid, nrow=n_rows)\n\n                # to image\n                grid = 255. * rearrange(grid, 'c h w -> h w c').cpu().numpy()\n                grid = Image.fromarray(grid.astype(np.uint8))\n                grid = put_watermark(grid, wm_encoder)\n                grid.save(os.path.join(outpath, f'grid-{grid_count:04}.png'))\n                grid_count += 1\n\n    print(f\"Your samples are ready and waiting for you here: \\n{outpath} \\nEnjoy.\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "file_name": "916680.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "#!/usr/bin/env python\n# vim: set encoding=utf-8\n# pylint: disable=wrong-import-position,wrong-import-order\n\n\"\"\"\nMain server program.\n\nConfiguration parameters:\n\n    path.internal.malformed\n    path.internal.static\n    path.internal.templates\n    path.log.main\n    path.log.queries\n\"\"\"\n\nfrom __future__ import print_function\n\nimport sys\nif sys.version_info[0] < 3:\n    reload(sys)\n    sys.setdefaultencoding('utf8')\n\nimport sys\nimport logging\nimport os\nimport requests\nimport jinja2\nfrom flask import Flask, request, send_from_directory, redirect, Response\n\nsys.path.append(os.path.abspath(os.path.join(__file__, \"..\", \"..\", \"lib\")))\nfrom config import CONFIG\nfrom limits import Limits\nfrom cheat_wrapper import cheat_wrapper\nfrom post import process_post_request\nfrom options import parse_args\n\nfrom stateful_queries import save_query, last_query\n\n\nif not os.path.exists(os.path.dirname(CONFIG[\"path.log.main\"])):\n    os.makedirs(os.path.dirname(CONFIG[\"path.log.main\"]))\nlogging.basicConfig(\n    filename=CONFIG[\"path.log.main\"],\n    level=logging.DEBUG,\n    format='%(asctime)s %(message)s')\n# Fix Flask \"exception and request logging\" to `stderr`.\n#\n# When Flask's werkzeug detects that logging is already set, it\n# doesn't add its own logger that prints exceptions.\nstderr_handler = logging.StreamHandler()\nlogging.getLogger().addHandler(stderr_handler)\n#\n# Alter log format to disting log lines from everything else\nstderr_handler.setFormatter(logging.Formatter('%(filename)s:%(lineno)s: %(message)s'))\n#\n# Sometimes werkzeug starts logging before an app is imported\n# (https://github.com/pallets/werkzeug/issues/1969)\n# resulting in duplicating lines. In that case we need root\n# stderr handler to skip lines from werkzeug.\nclass SkipFlaskLogger(object):\n    def filter(self, record):\n        if record.name != 'werkzeug':\n            return True\nif logging.getLogger('werkzeug').handlers:\n    stderr_handler.addFilter(SkipFlaskLogger())\n\n\napp = Flask(__name__) # pylint: disable=invalid-name\napp.jinja_loader = jinja2.ChoiceLoader([\n    app.jinja_loader,\n    jinja2.FileSystemLoader(CONFIG[\"path.internal.templates\"])])\n\nLIMITS = Limits()\n\nPLAIN_TEXT_AGENTS = [\n    \"curl\",\n    \"httpie\",\n    \"lwp-request\",\n    \"wget\",\n    \"python-requests\",\n    \"openbsd ftp\",\n    \"powershell\",\n    \"fetch\",\n    \"aiohttp\",\n]\n\ndef _is_html_needed(user_agent):\n    \"\"\"\n    Basing on `user_agent`, return whether it needs HTML or ANSI\n    \"\"\"\n    return all([x not in user_agent for x in PLAIN_TEXT_AGENTS])\n\ndef is_result_a_script(query):\n    return query in [':cht.sh']\n\n@app.route('/files/<path:path>')\ndef send_static(path):\n    \"\"\"\n    Return static file `path`.\n    Can be served by the HTTP frontend.\n    \"\"\"\n    return send_from_directory(CONFIG[\"path.internal.static\"], path)\n\n@app.route('/favicon.ico')\ndef send_favicon():\n    \"\"\"\n    Return static file `favicon.ico`.\n    Can be served by the HTTP frontend.\n    \"\"\"\n    return send_from_directory(CONFIG[\"path.internal.static\"], 'favicon.ico')\n\n@app.route('/malformed-response.html')\ndef send_malformed():\n    \"\"\"\n    Return static file `malformed-response.html`.\n    Can be served by the HTTP frontend.\n    \"\"\"\n    dirname, filename = os.path.split(CONFIG[\"path.internal.malformed\"])\n    return send_from_directory(dirname, filename)\n\ndef log_query(ip_addr, found, topic, user_agent):\n    \"\"\"\n    Log processed query and some internal data\n    \"\"\"\n    log_entry = \"%s %s %s %s\\n\" % (ip_addr, found, topic, user_agent)\n    with open(CONFIG[\"path.log.queries\"], 'ab') as my_file:\n        my_file.write(log_entry.encode('utf-8'))\n\ndef get_request_ip(req):\n    \"\"\"\n    Extract IP address from `request`\n    \"\"\"\n\n    if req.headers.getlist(\"X-Forwarded-For\"):\n        ip_addr = req.headers.getlist(\"X-Forwarded-For\")[0]\n        if ip_addr.startswith('::ffff:'):\n            ip_addr = ip_addr[7:]\n    else:\n        ip_addr = req.remote_addr\n    if req.headers.getlist(\"X-Forwarded-For\"):\n        ip_addr = req.headers.getlist(\"X-Forwarded-For\")[0]\n        if ip_addr.startswith('::ffff:'):\n            ip_addr = ip_addr[7:]\n    else:\n        ip_addr = req.remote_addr\n\n    return ip_addr\n\ndef get_answer_language(request):\n    \"\"\"\n    Return preferred answer language based on\n    domain name, query arguments and headers\n    \"\"\"\n\n    def _parse_accept_language(accept_language):\n        languages = accept_language.split(\",\")\n        locale_q_pairs = []\n\n        for language in languages:\n            try:\n                if language.split(\";\")[0] == language:\n                    # no q => q = 1\n                    locale_q_pairs.append((language.strip(), \"1\"))\n                else:\n                    locale = language.split(\";\")[0].strip()\n                    weight = language.split(\";\")[1].split(\"=\")[1]\n                    locale_q_pairs.append((locale, weight))\n            except IndexError:\n                pass\n\n        return locale_q_pairs\n\n    def _find_supported_language(accepted_languages):\n        for lang_tuple in accepted_languages:\n            lang = lang_tuple[0]\n            if '-' in lang:\n                lang = lang.split('-', 1)[0]\n            return lang\n        return None\n\n    lang = None\n    hostname = request.headers['Host']\n    if hostname.endswith('.cheat.sh'):\n        lang = hostname[:-9]\n\n    if 'lang' in request.args:\n        lang = request.args.get('lang')\n\n    header_accept_language = request.headers.get('Accept-Language', '')\n    if lang is None and header_accept_language:\n        lang = _find_supported_language(\n            _parse_accept_language(header_accept_language))\n\n    return lang\n\ndef _proxy(*args, **kwargs):\n    # print \"method=\", request.method,\n    # print \"url=\", request.url.replace('/:shell-x/', ':3000/')\n    # print \"headers=\", {key: value for (key, value) in request.headers if key != 'Host'}\n    # print \"data=\", request.get_data()\n    # print \"cookies=\", request.cookies\n    # print \"allow_redirects=\", False\n\n    url_before, url_after = request.url.split('/:shell-x/', 1)\n    url = url_before + ':3000/'\n\n    if 'q' in request.args:\n        url_after = '?' + \"&\".join(\"arg=%s\" % x for x in request.args['q'].split())\n\n    url += url_after\n    print(url)\n    print(request.get_data())\n    resp = requests.request(\n        method=request.method,\n        url=url,\n        headers={key: value for (key, value) in request.headers if key != 'Host'},\n        data=request.get_data(),\n        cookies=request.cookies,\n        allow_redirects=False)\n\n    excluded_headers = ['content-encoding', 'content-length', 'transfer-encoding', 'connection']\n    headers = [(name, value) for (name, value) in resp.raw.headers.items()\n               if name.lower() not in excluded_headers]\n\n    response = Response(resp.content, resp.status_code, headers)\n    return response\n\n\n@app.route(\"/\", methods=['GET', 'POST'])\n@app.route(\"/<path:topic>\", methods=[\"GET\", \"POST\"])\ndef answer(topic=None):\n    \"\"\"\n    Main rendering function, it processes incoming weather queries.\n    Depending on user agent it returns output in HTML or ANSI format.\n\n    Incoming data:\n        request.args\n        request.headers\n        request.remote_addr\n        request.referrer\n        request.query_string\n    \"\"\"\n\n    user_agent = request.headers.get('User-Agent', '').lower()\n    html_needed = _is_html_needed(user_agent)\n    options = parse_args(request.args)\n\n    if topic in ['apple-touch-icon-precomposed.png', 'apple-touch-icon.png', 'apple-touch-icon-120x120-precomposed.png'] \\\n        or (topic is not None and any(topic.endswith('/'+x) for x in ['favicon.ico'])):\n        return ''\n\n    request_id = request.cookies.get('id')\n    if topic is not None and topic.lstrip('/') == ':last':\n        if request_id:\n            topic = last_query(request_id)\n        else:\n            return \"ERROR: you have to set id for your requests to use /:last\\n\"\n    else:\n        if request_id:\n            save_query(request_id, topic)\n\n    if request.method == 'POST':\n        process_post_request(request, html_needed)\n        if html_needed:\n            return redirect(\"/\")\n        return \"OK\\n\"\n\n    if 'topic' in request.args:\n        return redirect(\"/%s\" % request.args.get('topic'))\n\n    if topic is None:\n        topic = \":firstpage\"\n\n    if topic.startswith(':shell-x/'):\n        return _proxy()\n        #return requests.get('http://127.0.0.1:3000'+topic[8:]).text\n\n    lang = get_answer_language(request)\n    if lang:\n        options['lang'] = lang\n\n    ip_address = get_request_ip(request)\n    if '+' in topic:\n        not_allowed = LIMITS.check_ip(ip_address)\n        if not_allowed:\n            return \"429 %s\\n\" % not_allowed, 429\n\n    html_is_needed = _is_html_needed(user_agent) and not is_result_a_script(topic)\n    if html_is_needed:\n        output_format='html'\n    else:\n        output_format='ansi'\n    result, found = cheat_wrapper(topic, request_options=options, output_format=output_format)\n    if 'Please come back in several hours' in result and html_is_needed:\n        malformed_response = open(os.path.join(CONFIG[\"path.internal.malformed\"])).read()\n        return malformed_response\n\n    log_query(ip_address, found, topic, user_agent)\n    if html_is_needed:\n        return result\n    return Response(result, mimetype='text/plain')\n", "file_name": "919804.py", "cwe": ["CWE-601: URL Redirection to Untrusted Site ('Open Redirect')"]}
{"source": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nimport contextlib\nimport requests\nfrom lxml import etree\nfrom hashlib import md5\nfrom urllib import parse\n\nfrom odoo import api, fields, models\nfrom odoo.addons.account_peppol.tools.demo_utils import handle_demo\nfrom odoo.tools.sql import column_exists, create_column\n\nTIMEOUT = 10\n\nclass ResPartner(models.Model):\n    _inherit = 'res.partner'\n\n    account_peppol_is_endpoint_valid = fields.Boolean(\n        string=\"PEPPOL endpoint validity\",\n        help=\"The partner's EAS code and PEPPOL endpoint are valid\",\n        compute=\"_compute_account_peppol_is_endpoint_valid\", store=True,\n        copy=False,\n    )\n    account_peppol_validity_last_check = fields.Date(\n        string=\"Checked on\",\n        help=\"Last Peppol endpoint verification\",\n        compute=\"_compute_account_peppol_is_endpoint_valid\", store=True,\n        copy=False,\n    )\n    account_peppol_verification_label = fields.Selection(\n        selection=[\n            ('not_verified', 'Not verified yet'),\n            ('not_valid', 'Not valid'),  # does not exist on Peppol at all\n            ('not_valid_format', 'Cannot receive this format'),  # registered on Peppol but cannot receive the selected document type\n            ('valid', 'Valid'),\n        ],\n        string='Peppol endpoint validity',\n        compute='_compute_account_peppol_verification_label',\n        copy=False,\n    )  # field to compute the label to show for partner endpoint\n    is_peppol_edi_format = fields.Boolean(compute='_compute_is_peppol_edi_format')\n\n    def _auto_init(self):\n        \"\"\"Create columns `account_peppol_is_endpoint_valid` and `account_peppol_validity_last_check`\n        to avoid having them computed by the ORM on installation.\n        \"\"\"\n        if not column_exists(self.env.cr, 'res_partner', 'account_peppol_is_endpoint_valid'):\n            create_column(self.env.cr, 'res_partner', 'account_peppol_is_endpoint_valid', 'boolean')\n        if not column_exists(self.env.cr, 'res_partner', 'account_peppol_validity_last_check'):\n            create_column(self.env.cr, 'res_partner', 'account_peppol_validity_last_check', 'timestamp')\n        return super()._auto_init()\n\n    @api.model\n    def fields_get(self, allfields=None, attributes=None):\n        # TODO: remove in master\n        res = super().fields_get(allfields, attributes)\n\n        # the orm_cache does not contain the new selections added in stable: clear the cache once\n        existing_selection = res.get('account_peppol_verification_label', {}).get('selection')\n        if existing_selection is None:\n            return res\n\n        not_valid_format_label = next(x for x in self._fields['account_peppol_verification_label'].selection if x[0] == 'not_valid_format')\n        need_update = not_valid_format_label not in existing_selection\n\n        if need_update:\n            self.env['ir.model.fields'].invalidate_model(['selection_ids'])\n            self.env['ir.model.fields.selection']._update_selection(\n                'res.partner',\n                'account_peppol_verification_label',\n                self._fields['account_peppol_verification_label'].selection,\n            )\n            self.env.registry.clear_cache()\n            return super().fields_get(allfields, attributes)\n        return res\n\n    # -------------------------------------------------------------------------\n    # HELPER METHODS\n    # -------------------------------------------------------------------------\n\n    @api.model\n    def _get_participant_info(self, edi_identification):\n        hash_participant = md5(edi_identification.lower().encode()).hexdigest()\n        endpoint_participant = parse.quote_plus(f\"iso6523-actorid-upis::{edi_identification}\")\n        peppol_user = self.env.company.sudo().account_edi_proxy_client_ids.filtered(lambda user: user.proxy_type == 'peppol')\n        edi_mode = peppol_user and peppol_user.edi_mode or self.env['ir.config_parameter'].sudo().get_param('account_peppol.edi.mode')\n        sml_zone = 'acc.edelivery' if edi_mode == 'test' else 'edelivery'\n        smp_url = f\"http://B-{hash_participant}.iso6523-actorid-upis.{sml_zone}.tech.ec.europa.eu/{endpoint_participant}\"\n\n        try:\n            response = requests.get(smp_url, timeout=TIMEOUT)\n        except requests.exceptions.ConnectionError:\n            return None\n        if response.status_code != 200:\n            return None\n        return etree.fromstring(response.content)\n\n    @api.model\n    def _check_peppol_participant_exists(self, edi_identification, check_company=False, ubl_cii_format=False):\n        participant_info = self._get_participant_info(edi_identification)\n        if participant_info is None:\n            return False\n\n        participant_identifier = participant_info.findtext('{*}ParticipantIdentifier')\n        service_metadata = participant_info.find('.//{*}ServiceMetadataReference')\n        service_href = ''\n        if service_metadata is not None:\n            service_href = service_metadata.attrib.get('href', '')\n\n        if edi_identification != participant_identifier or 'hermes-belgium' in service_href:\n            # all Belgian companies are pre-registered on hermes-belgium, so they will\n            # technically have an existing SMP url but they are not real Peppol participants\n            return False\n\n        if check_company:\n            # if we are only checking company's existence on the network, we don't care about what documents they can receive\n            if not service_href:\n                return True\n\n            access_point_contact = True\n            with contextlib.suppress(requests.exceptions.RequestException, etree.XMLSyntaxError):\n                response = requests.get(service_href, timeout=TIMEOUT)\n                if response.status_code == 200:\n                    access_point_info = etree.fromstring(response.content)\n                    access_point_contact = access_point_info.findtext('.//{*}TechnicalContactUrl') or access_point_info.findtext('.//{*}TechnicalInformationUrl')\n            return access_point_contact\n\n        return self._check_document_type_support(participant_info, ubl_cii_format)\n\n    def _check_document_type_support(self, participant_info, ubl_cii_format):\n        service_metadata = participant_info.find('.//{*}ServiceMetadataReferenceCollection')\n        if service_metadata is None:\n            return False\n\n        document_type = self.env['account.edi.xml.ubl_21']._get_customization_ids()[ubl_cii_format]\n        for service in service_metadata.iterfind('{*}ServiceMetadataReference'):\n            if document_type in parse.unquote_plus(service.attrib.get('href', '')):\n                return True\n        return False\n\n    # -------------------------------------------------------------------------\n    # COMPUTE METHODS\n    # -------------------------------------------------------------------------\n\n    @api.depends('ubl_cii_format')\n    def _compute_is_peppol_edi_format(self):\n        for partner in self:\n            partner.is_peppol_edi_format = partner.ubl_cii_format not in (False, 'facturx', 'oioubl_201', 'ciusro')\n\n    @api.depends('peppol_eas', 'peppol_endpoint', 'ubl_cii_format')\n    def _compute_account_peppol_is_endpoint_valid(self):\n        for partner in self:\n            partner.button_account_peppol_check_partner_endpoint()\n\n    @api.depends('account_peppol_is_endpoint_valid', 'account_peppol_validity_last_check')\n    def _compute_account_peppol_verification_label(self):\n        for partner in self:\n            if not partner.account_peppol_validity_last_check:\n                partner.account_peppol_verification_label = 'not_verified'\n            elif (\n                partner.is_peppol_edi_format\n                and (participant_info := self._get_participant_info(f'{partner.peppol_eas}:{partner.peppol_endpoint}'.lower())) is not None\n                and not partner._check_document_type_support(participant_info, partner.ubl_cii_format)\n            ):\n                # the partner might exist on the network, but not be able to receive that specific format\n                partner.account_peppol_verification_label = 'not_valid_format'\n            elif partner.account_peppol_is_endpoint_valid:\n                partner.account_peppol_verification_label = 'valid'\n            else:\n                partner.account_peppol_verification_label = 'not_valid'\n\n    # -------------------------------------------------------------------------\n    # BUSINESS ACTIONS\n    # -------------------------------------------------------------------------\n\n    @handle_demo\n    def button_account_peppol_check_partner_endpoint(self):\n        \"\"\" A basic check for whether a participant is reachable at the given\n        Peppol participant ID - peppol_eas:peppol_endpoint (ex: '9999:test')\n        The SML (Service Metadata Locator) assigns a DNS name to each peppol participant.\n        This DNS name resolves into the SMP (Service Metadata Publisher) of the participant.\n        The DNS address is of the following form:\n        - \"http://B-\" + hexstring(md5(lowercase(ID-VALUE))) + \".\" + ID-SCHEME + \".\" + SML-ZONE-NAME + \"/\" + url_encoded(ID-SCHEME + \"::\" + ID-VALUE)\n        (ref:https://peppol.helger.com/public/locale-en_US/menuitem-docs-doc-exchange)\n        \"\"\"\n        self.ensure_one()\n\n        if not (self.peppol_eas and self.peppol_endpoint) or not self.is_peppol_edi_format:\n            self.account_peppol_is_endpoint_valid = False\n        else:\n            edi_identification = f'{self.peppol_eas}:{self.peppol_endpoint}'.lower()\n            self.account_peppol_validity_last_check = fields.Date.context_today(self)\n            self.account_peppol_is_endpoint_valid = bool(self._check_peppol_participant_exists(edi_identification, ubl_cii_format=self.ubl_cii_format))\n        return False\n", "file_name": "765068.py", "cwe": ["CWE-319: Cleartext Transmission of Sensitive Information"]}
{"source": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\nimport logging\nimport werkzeug\nfrom werkzeug.urls import url_encode\n\nfrom odoo import http, tools, _\nfrom odoo.addons.auth_signup.models.res_users import SignupError\nfrom odoo.addons.web.controllers.home import ensure_db, Home, SIGN_UP_REQUEST_PARAMS, LOGIN_SUCCESSFUL_PARAMS\nfrom odoo.addons.base_setup.controllers.main import BaseSetup\nfrom odoo.exceptions import UserError\nfrom odoo.http import request\n\n_logger = logging.getLogger(__name__)\n\nLOGIN_SUCCESSFUL_PARAMS.add('account_created')\n\n\nclass AuthSignupHome(Home):\n\n    @http.route()\n    def web_login(self, *args, **kw):\n        ensure_db()\n        response = super().web_login(*args, **kw)\n        response.qcontext.update(self.get_auth_signup_config())\n        if request.session.uid:\n            if request.httprequest.method == 'GET' and request.params.get('redirect'):\n                # Redirect if already logged in and redirect param is present\n                return request.redirect(request.params.get('redirect'))\n            # Add message for non-internal user account without redirect if account was just created\n            if response.location == '/web/login_successful' and kw.get('confirm_password'):\n                return request.redirect_query('/web/login_successful', query={'account_created': True})\n        return response\n\n    @http.route('/web/signup', type='http', auth='public', website=True, sitemap=False)\n    def web_auth_signup(self, *args, **kw):\n        qcontext = self.get_auth_signup_qcontext()\n\n        if not qcontext.get('token') and not qcontext.get('signup_enabled'):\n            raise werkzeug.exceptions.NotFound()\n\n        if 'error' not in qcontext and request.httprequest.method == 'POST':\n            try:\n                self.do_signup(qcontext)\n\n                # Set user to public if they were not signed in by do_signup\n                # (mfa enabled)\n                if request.session.uid is None:\n                    public_user = request.env.ref('base.public_user')\n                    request.update_env(user=public_user)\n\n                # Send an account creation confirmation email\n                User = request.env['res.users']\n                user_sudo = User.sudo().search(\n                    User._get_login_domain(qcontext.get('login')), order=User._get_login_order(), limit=1\n                )\n                template = request.env.ref('auth_signup.mail_template_user_signup_account_created', raise_if_not_found=False)\n                if user_sudo and template:\n                    template.sudo().send_mail(user_sudo.id, force_send=True)\n                return self.web_login(*args, **kw)\n            except UserError as e:\n                qcontext['error'] = e.args[0]\n            except (SignupError, AssertionError) as e:\n                if request.env[\"res.users\"].sudo().search([(\"login\", \"=\", qcontext.get(\"login\"))]):\n                    qcontext[\"error\"] = _(\"Another user is already registered using this email address.\")\n                else:\n                    _logger.warning(\"%s\", e)\n                    qcontext['error'] = _(\"Could not create a new account.\") + \"\\n\" + str(e)\n\n        elif 'signup_email' in qcontext:\n            user = request.env['res.users'].sudo().search([('email', '=', qcontext.get('signup_email')), ('state', '!=', 'new')], limit=1)\n            if user:\n                return request.redirect('/web/login?%s' % url_encode({'login': user.login, 'redirect': '/web'}))\n\n        response = request.render('auth_signup.signup', qcontext)\n        response.headers['X-Frame-Options'] = 'SAMEORIGIN'\n        response.headers['Content-Security-Policy'] = \"frame-ancestors 'self'\"\n        return response\n\n    @http.route('/web/reset_password', type='http', auth='public', website=True, sitemap=False)\n    def web_auth_reset_password(self, *args, **kw):\n        qcontext = self.get_auth_signup_qcontext()\n\n        if not qcontext.get('token') and not qcontext.get('reset_password_enabled'):\n            raise werkzeug.exceptions.NotFound()\n\n        if 'error' not in qcontext and request.httprequest.method == 'POST':\n            try:\n                if qcontext.get('token'):\n                    self.do_signup(qcontext)\n                    return self.web_login(*args, **kw)\n                else:\n                    login = qcontext.get('login')\n                    assert login, _(\"No login provided.\")\n                    _logger.info(\n                        \"Password reset attempt for <%s> by user <%s> from %s\",\n                        login, request.env.user.login, request.httprequest.remote_addr)\n                    request.env['res.users'].sudo().reset_password(login)\n                    qcontext['message'] = _(\"Password reset instructions sent to your email\")\n            except UserError as e:\n                qcontext['error'] = e.args[0]\n            except SignupError:\n                qcontext['error'] = _(\"Could not reset your password\")\n                _logger.exception('error when resetting password')\n            except Exception as e:\n                qcontext['error'] = str(e)\n\n        elif 'signup_email' in qcontext:\n            user = request.env['res.users'].sudo().search([('email', '=', qcontext.get('signup_email')), ('state', '!=', 'new')], limit=1)\n            if user:\n                return request.redirect('/web/login?%s' % url_encode({'login': user.login, 'redirect': '/web'}))\n\n        response = request.render('auth_signup.reset_password', qcontext)\n        response.headers['X-Frame-Options'] = 'SAMEORIGIN'\n        response.headers['Content-Security-Policy'] = \"frame-ancestors 'self'\"\n        return response\n\n    def get_auth_signup_config(self):\n        \"\"\"retrieve the module config (which features are enabled) for the login page\"\"\"\n\n        get_param = request.env['ir.config_parameter'].sudo().get_param\n        return {\n            'disable_database_manager': not tools.config['list_db'],\n            'signup_enabled': request.env['res.users']._get_signup_invitation_scope() == 'b2c',\n            'reset_password_enabled': get_param('auth_signup.reset_password') == 'True',\n        }\n\n    def get_auth_signup_qcontext(self):\n        \"\"\" Shared helper returning the rendering context for signup and reset password \"\"\"\n        qcontext = {k: v for (k, v) in request.params.items() if k in SIGN_UP_REQUEST_PARAMS}\n        qcontext.update(self.get_auth_signup_config())\n        if not qcontext.get('token') and request.session.get('auth_signup_token'):\n            qcontext['token'] = request.session.get('auth_signup_token')\n        if qcontext.get('token'):\n            try:\n                # retrieve the user info (name, login or email) corresponding to a signup token\n                token_infos = request.env['res.partner'].sudo().signup_retrieve_info(qcontext.get('token'))\n                for k, v in token_infos.items():\n                    qcontext.setdefault(k, v)\n            except:\n                qcontext['error'] = _(\"Invalid signup token\")\n                qcontext['invalid_token'] = True\n        return qcontext\n\n    def _prepare_signup_values(self, qcontext):\n        values = { key: qcontext.get(key) for key in ('login', 'name', 'password') }\n        if not values:\n            raise UserError(_(\"The form was not properly filled in.\"))\n        if values.get('password') != qcontext.get('confirm_password'):\n            raise UserError(_(\"Passwords do not match; please retype them.\"))\n        supported_lang_codes = [code for code, _ in request.env['res.lang'].get_installed()]\n        lang = request.context.get('lang', '')\n        if lang in supported_lang_codes:\n            values['lang'] = lang\n        return values\n\n    def do_signup(self, qcontext):\n        \"\"\" Shared helper that creates a res.partner out of a token \"\"\"\n        values = self._prepare_signup_values(qcontext)\n        self._signup_with_values(qcontext.get('token'), values)\n        request.env.cr.commit()\n\n    def _signup_with_values(self, token, values):\n        login, password = request.env['res.users'].sudo().signup(values, token)\n        request.env.cr.commit()     # as authenticate will use its own cursor we need to commit the current transaction\n        pre_uid = request.session.authenticate(request.db, login, password)\n        if not pre_uid:\n            raise SignupError(_('Authentication Failed.'))\n\nclass AuthBaseSetup(BaseSetup):\n    @http.route()\n    def base_setup_data(self, **kwargs):\n        res = super().base_setup_data(**kwargs)\n        res.update({'resend_invitation': True})\n        return res\n", "file_name": "511699.py", "cwe": ["CWE-532: Insertion of Sensitive Information into Log File"]}
{"source": "# -*- coding: utf-8 -*-\nimport contextlib\nimport datetime\nimport json\nimport logging\nimport math\nimport os\nimport random\nimport selectors\nimport threading\nimport time\nfrom psycopg2 import InterfaceError, sql\n\nimport odoo\nfrom odoo import api, fields, models\nfrom odoo.service.server import CommonServer\nfrom odoo.tools.misc import DEFAULT_SERVER_DATETIME_FORMAT\nfrom odoo.tools import date_utils\n\n_logger = logging.getLogger(__name__)\n\n# longpolling timeout connection\nTIMEOUT = 50\n\n# custom function to call instead of default PostgreSQL's `pg_notify`\nODOO_NOTIFY_FUNCTION = os.getenv('ODOO_NOTIFY_FUNCTION', 'pg_notify')\n\n\ndef get_notify_payload_max_length(default=8000):\n    try:\n        length = int(os.environ.get('ODOO_NOTIFY_PAYLOAD_MAX_LENGTH', default))\n    except ValueError:\n        _logger.warning(\"ODOO_NOTIFY_PAYLOAD_MAX_LENGTH has to be an integer, \"\n                        \"defaulting to %d bytes\", default)\n        length = default\n    return length\n\n\n# max length in bytes for the NOTIFY query payload\nNOTIFY_PAYLOAD_MAX_LENGTH = get_notify_payload_max_length()\n\n\n#----------------------------------------------------------\n# Bus\n#----------------------------------------------------------\ndef json_dump(v):\n    return json.dumps(v, separators=(',', ':'), default=date_utils.json_default)\n\ndef hashable(key):\n    if isinstance(key, list):\n        key = tuple(key)\n    return key\n\n\ndef channel_with_db(dbname, channel):\n    if isinstance(channel, models.Model):\n        return (dbname, channel._name, channel.id)\n    if isinstance(channel, tuple) and len(channel) == 2 and isinstance(channel[0], models.Model):\n        return (dbname, channel[0]._name, channel[0].id, channel[1])\n    if isinstance(channel, str):\n        return (dbname, channel)\n    return channel\n\n\ndef get_notify_payloads(channels):\n    \"\"\"\n    Generates the json payloads for the imbus NOTIFY.\n    Splits recursively payloads that are too large.\n\n    :param list channels:\n    :return: list of payloads of json dumps\n    :rtype: list[str]\n    \"\"\"\n    if not channels:\n        return []\n    payload = json_dump(channels)\n    if len(channels) == 1 or len(payload.encode()) < NOTIFY_PAYLOAD_MAX_LENGTH:\n        return [payload]\n    else:\n        pivot = math.ceil(len(channels) / 2)\n        return (get_notify_payloads(channels[:pivot]) +\n                get_notify_payloads(channels[pivot:]))\n\n\nclass ImBus(models.Model):\n\n    _name = 'bus.bus'\n    _description = 'Communication Bus'\n\n    channel = fields.Char('Channel')\n    message = fields.Char('Message')\n\n    @api.autovacuum\n    def _gc_messages(self):\n        timeout_ago = datetime.datetime.utcnow()-datetime.timedelta(seconds=TIMEOUT*2)\n        domain = [('create_date', '<', timeout_ago.strftime(DEFAULT_SERVER_DATETIME_FORMAT))]\n        return self.sudo().search(domain).unlink()\n\n    @api.model\n    def _sendmany(self, notifications):\n        channels = set()\n        values = []\n        for target, notification_type, message in notifications:\n            channel = channel_with_db(self.env.cr.dbname, target)\n            channels.add(channel)\n            values.append({\n                'channel': json_dump(channel),\n                'message': json_dump({\n                    'type': notification_type,\n                    'payload': message,\n                })\n            })\n        self.sudo().create(values)\n        if channels:\n            # We have to wait until the notifications are commited in database.\n            # When calling `NOTIFY imbus`, notifications will be fetched in the\n            # bus table. If the transaction is not commited yet, there will be\n            # nothing to fetch, and the websocket will return no notification.\n            @self.env.cr.postcommit.add\n            def notify():\n                with odoo.sql_db.db_connect('postgres').cursor() as cr:\n                    query = sql.SQL(\"SELECT {}('imbus', %s)\").format(sql.Identifier(ODOO_NOTIFY_FUNCTION))\n                    payloads = get_notify_payloads(list(channels))\n                    if len(payloads) > 1:\n                        _logger.info(\"The imbus notification payload was too large, \"\n                                     \"it's been split into %d payloads.\", len(payloads))\n                    for payload in payloads:\n                        cr.execute(query, (payload,))\n\n    @api.model\n    def _sendone(self, channel, notification_type, message):\n        self._sendmany([[channel, notification_type, message]])\n\n    @api.model\n    def _poll(self, channels, last=0):\n        # first poll return the notification in the 'buffer'\n        if last == 0:\n            timeout_ago = datetime.datetime.utcnow()-datetime.timedelta(seconds=TIMEOUT)\n            domain = [('create_date', '>', timeout_ago.strftime(DEFAULT_SERVER_DATETIME_FORMAT))]\n        else:  # else returns the unread notifications\n            domain = [('id', '>', last)]\n        channels = [json_dump(channel_with_db(self.env.cr.dbname, c)) for c in channels]\n        domain.append(('channel', 'in', channels))\n        notifications = self.sudo().search_read(domain)\n        # list of notification to return\n        result = []\n        for notif in notifications:\n            result.append({\n                'id': notif['id'],\n                'message': json.loads(notif['message']),\n            })\n        return result\n\n    def _bus_last_id(self):\n        last = self.env['bus.bus'].search([], order='id desc', limit=1)\n        return last.id if last else 0\n\n\n#----------------------------------------------------------\n# Dispatcher\n#----------------------------------------------------------\n\nclass BusSubscription:\n    def __init__(self, channels, last):\n        self.last_notification_id = last\n        self.channels = channels\n\n\nclass ImDispatch(threading.Thread):\n    def __init__(self):\n        super().__init__(daemon=True, name=f'{__name__}.Bus')\n        self._channels_to_ws = {}\n\n    def subscribe(self, channels, last, db, websocket):\n        \"\"\"\n        Subcribe to bus notifications. Every notification related to the\n        given channels will be sent through the websocket. If a subscription\n        is already present, overwrite it.\n        \"\"\"\n        channels = {hashable(channel_with_db(db, c)) for c in channels}\n        for channel in channels:\n            self._channels_to_ws.setdefault(channel, set()).add(websocket)\n        outdated_channels = websocket._channels - channels\n        self._clear_outdated_channels(websocket, outdated_channels)\n        websocket.subscribe(channels, last)\n        with contextlib.suppress(RuntimeError):\n            if not self.is_alive():\n                self.start()\n\n    def unsubscribe(self, websocket):\n        self._clear_outdated_channels(websocket, websocket._channels)\n\n    def _clear_outdated_channels(self, websocket, outdated_channels):\n        \"\"\" Remove channels from channel to websocket map. \"\"\"\n        for channel in outdated_channels:\n            self._channels_to_ws[channel].remove(websocket)\n            if not self._channels_to_ws[channel]:\n                self._channels_to_ws.pop(channel)\n\n    def loop(self):\n        \"\"\" Dispatch postgres notifications to the relevant websockets \"\"\"\n        _logger.info(\"Bus.loop listen imbus on db postgres\")\n        with odoo.sql_db.db_connect('postgres').cursor() as cr, \\\n             selectors.DefaultSelector() as sel:\n            cr.execute(\"listen imbus\")\n            cr.commit()\n            conn = cr._cnx\n            sel.register(conn, selectors.EVENT_READ)\n            while not stop_event.is_set():\n                if sel.select(TIMEOUT):\n                    conn.poll()\n                    channels = []\n                    while conn.notifies:\n                        channels.extend(json.loads(conn.notifies.pop().payload))\n                    # relay notifications to websockets that have\n                    # subscribed to the corresponding channels.\n                    websockets = set()\n                    for channel in channels:\n                        websockets.update(self._channels_to_ws.get(hashable(channel), []))\n                    for websocket in websockets:\n                        websocket.trigger_notification_dispatching()\n\n    def run(self):\n        while not stop_event.is_set():\n            try:\n                self.loop()\n            except Exception as exc:\n                if isinstance(exc, InterfaceError) and stop_event.is_set():\n                    continue\n                _logger.exception(\"Bus.loop error, sleep and retry\")\n                time.sleep(TIMEOUT)\n\n# Partially undo a2ed3d3d5bdb6025a1ba14ad557a115a86413e65\n# IMDispatch has a lazy start, so we could initialize it anyway\n# And this avoids the Bus unavailable error messages\ndispatch = ImDispatch()\nstop_event = threading.Event()\nCommonServer.on_stop(stop_event.set)\n", "file_name": "969579.py", "cwe": ["CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"]}
{"source": "import codecs\nimport io\nimport json\nimport re\nfrom pathlib import Path\n\nimport aiohttp\nimport PyPDF2\nimport yaml\nfrom bs4 import BeautifulSoup\nfrom fastapi import FastAPI, Query, Request, Response\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.openapi.utils import get_openapi\nfrom fastapi.responses import JSONResponse\nfrom loguru import logger\nfrom starlette.responses import FileResponse\n\n# In total, the text + image links + prompts should be <= 2048\nCHAR_LIMIT = 1585  # TODO: increase these values after long-context support has been added\nIMAGES_CHAR_LIMIT = 300\nMAX_DOWNLOAD_SIZE = 4 * 1024 * 1024\nMAX_CHUNK_SIZE = 1024 * 1024\n\nIMAGES_SUFIX = \"\"\", and I will also include images formatted like this:\n![](image url)\n\"\"\"\n\nfolder_path = Path(__file__).parent\n\napp = FastAPI()\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\ndef extract_image_links(text: str):\n    image_pattern = r\"https?://\\S+\\.(?:jpg|jpeg|png|gif|bmp|webp|svg)\"\n    images = re.findall(image_pattern, text, flags=re.IGNORECASE | re.MULTILINE)\n    return images\n\n\ndef detect_content_type(content: bytes) -> str:\n    if content.startswith(b\"%PDF-\"):\n        return \"application/pdf\"\n    elif (content).lstrip().upper().startswith(b\"<!DOCTYPE HTML\") or content.startswith(b\"<html\"):\n        return \"text/html\"\n    elif content.startswith(b\"{\") or content.startswith(b\"[\"):\n        try:\n            json.loads(content)\n            return \"application/json\"\n        except json.JSONDecodeError:\n            pass\n    elif content.startswith(b\"---\") or content.startswith(b\"%YAML\"):\n        try:\n            yaml.safe_load(content)\n            return \"application/x-yaml\"\n        except yaml.YAMLError:\n            pass\n\n    return \"text/plain\"\n\n\ndef limit_image_count(images, max_chars=300):\n    limited_images = []\n    current_length = 0\n\n    for url in images:\n        # Add the length of \"http:\" if the URL starts with \"//\"\n        url_length = len(\"http:\") + len(url) if url.startswith(\"//\") else len(url)\n\n        if current_length + url_length > max_chars:\n            break\n\n        if url.startswith(\"//\"):\n            limited_images.append(f\"http:{url}\")\n        else:\n            limited_images.append(url)\n\n        current_length += url_length\n\n    return limited_images\n\n\ndef truncate_paragraphs(paragraphs, max_length):\n    truncated_paragraphs = []\n    current_length = 0\n\n    for paragraph in paragraphs:\n        if len(paragraph) == 0:\n            continue\n        paragraph = paragraph.strip()\n        if current_length + len(paragraph) <= max_length:\n            truncated_paragraphs.append(paragraph)\n            current_length += len(paragraph)\n        else:\n            remaining_length = max_length - current_length\n            truncated_paragraph = paragraph[:remaining_length]\n            truncated_paragraphs.append(truncated_paragraph)\n            break\n\n    return truncated_paragraphs\n\n\n@app.get(\"/get-url-content/\", operation_id=\"getUrlContent\", summary=\"It will return a web page's or pdf's content\")\nasync def get_url_content(url: str = Query(..., description=\"url to fetch content from\")) -> Response:\n    try:\n        buffer = io.BytesIO()\n        encoding: str | None\n        content_type: str | None\n\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                response.raise_for_status()  # Raise an exception for HTTP errors\n                try:\n                    encoding = response.get_encoding()\n                except RuntimeError:\n                    encoding = None\n                content_type = response.content_type\n\n                if response.content_length is not None and response.content_length > MAX_DOWNLOAD_SIZE:\n                    error_message = (\n                        f\"Sorry, the file at {url} is too large.\\nYou should report this message to the user!\"\n                    )\n                    return JSONResponse(content={\"error\": error_message}, status_code=500)\n\n                async for chunk in response.content.iter_chunked(MAX_CHUNK_SIZE):\n                    buffer.write(chunk)\n                    if buffer.tell() > MAX_DOWNLOAD_SIZE:\n                        error_message = (\n                            f\"Sorry, the file at {url} is too large.\\nYou should report this message to the user!\"\n                        )\n                        return JSONResponse(content={\"error\": error_message}, status_code=500)\n\n        content_bytes: bytes = buffer.getvalue()\n        if content_type is None or content_type == \"application/octet-stream\":\n            content_type = detect_content_type(content_bytes)\n        buffer.seek(0)\n\n        def decode_text() -> str:\n            decoder = codecs.getincrementaldecoder(encoding or \"utf-8\")(errors=\"replace\")\n            return decoder.decode(content_bytes, True)\n\n        text = \"\"\n        images = []\n\n        if content_type == \"application/pdf\":\n            pdf_reader = PyPDF2.PdfReader(buffer)\n\n            text = \"\"\n            for page in pdf_reader.pages:\n                text += page.extract_text()\n\n        elif content_type == \"text/html\":\n            soup = BeautifulSoup(decode_text(), \"html.parser\")\n\n            paragraphs = [p.get_text(strip=True) for p in soup.find_all(\"p\")]\n            # if there are no paragraphs, try to get text from divs\n            if not paragraphs:\n                paragraphs = [p.get_text(strip=True) for p in soup.find_all(\"div\")]\n            # if there are no paragraphs or divs, try to get text from spans\n            if not paragraphs:\n                paragraphs = [p.get_text(strip=True) for p in soup.find_all(\"span\")]\n\n            paragraphs = truncate_paragraphs(paragraphs, CHAR_LIMIT)\n            text = \"\\n\".join(paragraphs)\n\n            for p in soup.find_all(\"p\"):\n                parent = p.parent\n                images.extend([img[\"src\"] for img in parent.find_all(\"img\") if img.get(\"src\")])\n\n        elif content_type == \"application/json\":\n            json_data = json.loads(decode_text())\n            text = yaml.dump(json_data, sort_keys=False, default_flow_style=False)\n\n            for _, value in json_data.items():\n                if isinstance(value, str):\n                    images.extend(extract_image_links(value))\n                elif isinstance(value, list):\n                    for item in value:\n                        if isinstance(item, str):\n                            images.extend(extract_image_links(item))\n\n        elif content_type == \"text/plain\":\n            text = decode_text()\n            images.extend(extract_image_links(text))\n\n        else:\n            error_message = f\"Sorry, unsupported content type '{content_type}' at {url}.\\nYou should report this message to the user!\"\n            return JSONResponse(content={\"error\": error_message}, status_code=500)\n\n        images = [f\"http:{url}\" if url.startswith(\"//\") else url for url in images]\n        images = limit_image_count(images, max_chars=IMAGES_CHAR_LIMIT)\n\n        if len(text) > CHAR_LIMIT:\n            text = text[:CHAR_LIMIT]\n\n        MULTILINE_SYM = \"|\" if content_type != \"applicaion/json\" else \"\"\n        text_yaml = f\"text_content: {MULTILINE_SYM}\\n\"\n        for line in text.split(\"\\n\"):\n            text_yaml += f\"  {line}\\n\"\n\n        images_yaml = \"images:\\n\" if len(images) > 0 else \"\"\n        for image in images:\n            images_yaml += f\"- {image}\\n\"\n\n        yaml_text = f\"{text_yaml}\\n{images_yaml}\"\n        text = f\"\"\"{yaml_text}\nThought: I now know the answer{IMAGES_SUFIX if len(images) > 0 else \".\"}\n\"\"\"\n        return Response(content=text, media_type=\"text/plain\")\n\n    except Exception as e:\n        logger.opt(exception=True).debug(\"web_retriever GET failed:\")\n        error_message = f\"Sorry, the url is not available. {e}\\nYou should report this message to the user!\"\n        return JSONResponse(content={\"error\": error_message}, status_code=500)\n\n\n@app.get(\"/icon.png\", include_in_schema=False)\nasync def api_icon():\n    return FileResponse(folder_path / \"icon.png\")\n\n\n@app.get(\"/ai-plugin.json\", include_in_schema=False)\nasync def api_ai_plugin(request: Request):\n    json_path = folder_path / \"ai-plugin.json\"\n    with json_path.open(\"r\") as f:\n        ai_plugin_json = json.load(f)\n\n    base_url, _, _ = request.url._url.rpartition(\"/\")\n    ai_plugin_json[\"logo_url\"] = base_url + \"/icon.png\"\n    ai_plugin_json[\"api\"][\"url\"] = base_url + \"/openapi.json\"\n\n    return Response(content=json.dumps(ai_plugin_json), media_type=\"application/json\")\n\n\ndef custom_openapi():\n    if app.openapi_schema:\n        return app.openapi_schema\n    openapi_schema = get_openapi(\n        title=\"Web Retriever\",\n        version=\"0.1\",\n        routes=app.routes,\n        servers=[{\"url\": \"/plugins/web_retriever\"}],\n    )\n    openapi_schema[\"tags\"] = [\n        {\n            \"name\": \"web-retriever\",\n            \"description\": \"Use this plugin to retrieve web page and pdf content\",\n        },\n    ]\n    openapi_schema.pop(\"components\", None)\n    app.openapi_schema = openapi_schema\n    return app.openapi_schema\n\n\napp.openapi = custom_openapi\n\n\nif __name__ == \"__main__\":\n    # simple built-in test\n    import asyncio\n\n    url = \"https://huggingface.co/OpenAssistant/oasst-sft-1-pythia-12b\"\n    x = asyncio.run(get_url_content(url))\n    print(x.status_code, x.body)\n", "file_name": "287641.py", "cwe": ["CWE-942: Permissive Cross-domain Policy with Untrusted Domains"]}
{"source": "\"\"\"\nBasic FastAPI server to serve models using HuggingFace Transformers library.\nThis is an alternative to running the HuggingFace `text-generation-inference` (tgi) server.\n\"\"\"\n\nimport sys\nimport threading\nfrom queue import Queue\n\nimport fastapi\nimport hf_stopping\nimport hf_streamer\nimport interface\nimport torch\nimport transformers\nimport uvicorn\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom loguru import logger\nfrom oasst_shared import model_configs\nfrom settings import settings\nfrom sse_starlette.sse import EventSourceResponse\n\napp = fastapi.FastAPI()\n\nDECODE_TOKEN = \"<decode-token>\"\n\n\n# Allow CORS\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\n@app.middleware(\"http\")\nasync def log_exceptions(request: fastapi.Request, call_next):\n    try:\n        response = await call_next(request)\n    except Exception:\n        logger.exception(\"Exception in request\")\n        raise\n    return response\n\n\nmodel_loaded: bool = False\nfully_loaded: bool = False\nmodel_input_queue: Queue = Queue()\n\n\ndef model_thread():\n    \"\"\"Continually obtain new work requests from the model input queue and work on them.\"\"\"\n    model: transformers.PreTrainedModel\n    tokenizer: transformers.PreTrainedTokenizer\n    model, tokenizer, decode_token = load_models()\n\n    request: interface.GenerateStreamRequest\n    output_queue: Queue\n    eos_token_id = tokenizer.eos_token_id if hasattr(tokenizer, \"eos_token_id\") else None\n    while True:\n        request, output_queue = model_input_queue.get()\n        try:\n            prompt = request.inputs\n            params = request.parameters.dict()\n            seed = params.pop(\"seed\")\n            stop_sequences = params.pop(\"stop\")\n            params.pop(\"details\")\n            params.pop(\"plugins\")\n\n            if seed is not None:\n                torch.manual_seed(seed)\n\n            last_token_id = None  # need to delay by 1 to simulate tgi\n\n            def print_text(token_id: int):\n                nonlocal last_token_id\n                if last_token_id is not None:\n                    text = decode_token(last_token_id)\n                    stream_response = interface.GenerateStreamResponse(\n                        token=interface.Token(text=text, id=last_token_id),\n                    )\n                    output_queue.put_nowait(stream_response)\n                last_token_id = token_id\n\n            with torch.no_grad():\n                ids = tokenizer.encode(prompt, return_tensors=\"pt\", add_special_tokens=False)\n                streamer = hf_streamer.HFStreamer(input_ids=ids, printer=print_text)\n                ids = ids.to(model.device)\n                stopping_criteria = (\n                    transformers.StoppingCriteriaList(\n                        [hf_stopping.SequenceStoppingCriteria(tokenizer, stop_sequences, prompt)]\n                    )\n                    if stop_sequences\n                    else None\n                )\n                output = model.generate(\n                    ids,\n                    **params,\n                    streamer=streamer,\n                    eos_token_id=eos_token_id,\n                    stopping_criteria=stopping_criteria,\n                )\n                output = output.cpu()\n                output_ids = output[0][len(ids[0]) :]\n                decoded = tokenizer.decode(output_ids, skip_special_tokens=True)\n\n            stream_response = interface.GenerateStreamResponse(\n                token=interface.Token(\n                    text=decode_token(last_token_id),  # hack because the \"normal\" inference server does this at once\n                    id=last_token_id,\n                ),\n                generated_text=decoded.strip(),\n                details=interface.StreamDetails(\n                    finish_reason=\"eos_token\",\n                    generated_tokens=len(output_ids),\n                    seed=seed,\n                ),\n            )\n            output_queue.put_nowait(stream_response)\n        except Exception as e:\n            logger.exception(\"Exception in model thread\")\n            output_queue.put_nowait(interface.GenerateStreamResponse(error=str(e)))\n\n\ndef load_models():\n    global model_loaded\n\n    torch.set_num_threads(1)\n    torch.set_num_interop_threads(1)\n\n    model_config = model_configs.MODEL_CONFIGS.get(settings.model_config_name)\n    if model_config is None:\n        logger.error(f\"Unknown model config name: {settings.model_config_name}\")\n        sys.exit(2)\n\n    hf_config = transformers.AutoConfig.from_pretrained(model_config.model_id)\n    logger.warning(f\"Loading model {model_config.model_id}...\")\n    tokenizer = transformers.AutoTokenizer.from_pretrained(model_config.model_id)\n    logger.warning(f\"tokenizer {tokenizer.name_or_path} has vocab size {len(tokenizer)}\")\n\n    # see `decode_token` method, taken from HF text-generation-inference\n    tokenizer.add_special_tokens({\"additional_special_tokens\": [\"<decode-token>\"]})\n\n    special_decode_token_id = tokenizer.convert_tokens_to_ids(\"<decode-token>\")\n    special_decode_token_length = len(\"<decode-token>\")\n\n    def decode_token(token_id):\n        result = tokenizer.decode([special_decode_token_id, token_id], skip_special_tokens=False)\n        # slice to remove special decode token\n        return result[special_decode_token_length:]\n\n    config_dtype = hf_config.torch_dtype if hasattr(hf_config, \"torch_dtype\") else torch.float32\n    dtype = torch.bfloat16 if torch.has_cuda and torch.cuda.is_bf16_supported() else config_dtype\n\n    model = transformers.AutoModelForCausalLM.from_pretrained(\n        model_config.model_id,\n        torch_dtype=dtype,\n        load_in_8bit=settings.quantize,\n        device_map=\"auto\" if torch.cuda.is_available() else None,\n    ).eval()\n    logger.warning(\"Model loaded, using it once...\")\n\n    # warmup\n    with torch.no_grad():\n        text = \"Hello, world\"\n        tokens = tokenizer.encode(text, return_tensors=\"pt\")\n        tokens = tokens.to(model.device)\n        model.generate(tokens, max_length=10, num_beams=1, do_sample=False)\n\n    model_loaded = True\n\n    return model, tokenizer, decode_token\n\n\n@app.on_event(\"startup\")\nasync def start_model_thread():\n    logger.warning(\"Starting model thread...\")\n    threading.Thread(target=model_thread, daemon=True).start()\n    logger.warning(\"Model thread started\")\n\n\n@app.on_event(\"startup\")\nasync def welcome_message():\n    global fully_loaded\n    logger.warning(\"Server started\")\n    logger.warning(\"To stop the server, press Ctrl+C\")\n    fully_loaded = True\n\n\n@app.post(\"/generate_stream\")\nasync def generate(\n    request: interface.GenerateStreamRequest,\n):\n    def event_stream():\n        try:\n            output_queue: Queue = Queue()\n            model_input_queue.put_nowait((request, output_queue))\n            while True:\n                output = output_queue.get()  # type: interface.GenerateStreamResponse\n                yield {\"data\": output.json()}\n                if output.is_end:\n                    break\n                if output.is_error:\n                    raise Exception(output.error)\n        except Exception as e:\n            logger.exception(\"Exception in event stream\")\n            output_queue.put_nowait(interface.GenerateStreamResponse(error=str(e)))\n            raise\n\n    return EventSourceResponse(event_stream())\n\n\n@app.get(\"/health\")\nasync def health():\n    if not (fully_loaded and model_loaded):\n        raise fastapi.HTTPException(status_code=503, detail=\"Server not fully loaded\")\n    return {\"status\": \"ok\"}\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n", "file_name": "672233.py", "cwe": ["CWE-942: Permissive Cross-domain Policy with Untrusted Domains"]}
{"source": "from argparse import Namespace\n\nimport pytest\nimport torch\nfrom model_training.custom_datasets import get_one_dataset\nfrom model_training.custom_datasets.formatting import (\n    QA_SPECIAL_TOKENS,\n    DatasetEntryRm,\n    Role,\n    Utterance,\n    create_dataset_entry_qa,\n)\nfrom model_training.custom_datasets.ranking_collator import RankingDataCollator\nfrom model_training.utils.utils import get_tokenizer, match_tokenizer_name\nfrom torch.utils.data import DataLoader\nfrom transformers.models.auto.tokenization_auto import AutoTokenizer\n\n\n@pytest.fixture\ndef pythia_tokenizer():\n    tokenizer = AutoTokenizer.from_pretrained(\"tests/resources/data_collator\", local_files_only=True)\n    # for this test we use the pythia special tokens but note that this test is model agnostic\n    tokenizer_config = match_tokenizer_name(\"pythia\")\n\n    tokenizer.add_special_tokens(\n        {\n            \"pad_token\": tokenizer_config.special_tokens.pad_token,\n            \"eos_token\": tokenizer_config.special_tokens.eos_token,\n            \"sep_token\": tokenizer_config.special_tokens.sep_token,\n        }\n    )\n\n    additional_special_tokens = list(QA_SPECIAL_TOKENS.values())\n\n    tokenizer.add_special_tokens({\"additional_special_tokens\": additional_special_tokens})\n    return tokenizer\n\n\ndef test_ranking_collator_system_tag(pythia_tokenizer):\n    first_example = DatasetEntryRm(\n        messages=[Utterance(text=\"First instruction.\", role=Role.prompter, lang=\"en\")],\n        replies=[\n            Utterance(text=\"Answer to first instruction.\", role=Role.assistant, lang=\"en\", quality=0.7),\n            Utterance(text=\"Answer to first instruction.\", role=Role.assistant, lang=\"de\", quality=0.8),\n        ],\n    )\n    second_example = DatasetEntryRm(\n        messages=[Utterance(text=\"Second instruction.\", role=Role.prompter)],\n        replies=[\n            Utterance(text=\"Answer to second instruction.\", role=Role.assistant, humor=0.1, creativity=0.2),\n            Utterance(text=\"Answer to second instruction.\", role=Role.assistant, humor=0.4, creativity=0.3),\n        ],\n    )\n    examples = [first_example, second_example]\n\n    rdc = RankingDataCollator(tokenizer=pythia_tokenizer, padding=True)\n    batch, cu_lens = rdc(examples=examples)\n\n    assert len(batch) == 2\n    assert cu_lens == [0, len(first_example.replies), len(first_example.replies) + len(second_example.replies)]\n    assert batch.data[\"attention_mask\"].shape[0] == 4  # we have 4 replies in total\n    assert batch.data[\"input_ids\"].shape == batch.data[\"attention_mask\"].shape\n    eos = pythia_tokenizer.eos_token\n\n    # check each instruction\n    first_example_first_answer_decoded = pythia_tokenizer.decode(batch.data[\"input_ids\"][0])\n    f\"{QA_SPECIAL_TOKENS['Question']}{first_example.messages[0].text}{eos}\" in first_example_first_answer_decoded\n    f\"{QA_SPECIAL_TOKENS['Answer']}{first_example.replies[0].text}{eos}\" in first_example_first_answer_decoded\n    \"lang: en\" in first_example_first_answer_decoded\n    \"quality: 0.7\" in first_example_first_answer_decoded\n\n    first_example_second_answer_decoded = pythia_tokenizer.decode(batch.data[\"input_ids\"][1])\n    f\"{QA_SPECIAL_TOKENS['Question']}{first_example.messages[0].text}{eos}\" in first_example_second_answer_decoded\n    f\"{QA_SPECIAL_TOKENS['Answer']}{first_example.replies[1].text}{eos}\" in first_example_second_answer_decoded\n    \"lang: de\" in first_example_second_answer_decoded\n    \"quality: 0.8\" in first_example_second_answer_decoded\n\n    second_example_first_answer_decoded = pythia_tokenizer.decode(batch.data[\"input_ids\"][2])\n    f\"{QA_SPECIAL_TOKENS['Question']}{second_example.messages[0].text}{eos}\" in second_example_first_answer_decoded\n    f\"{QA_SPECIAL_TOKENS['Answer']}{second_example.replies[0].text}{eos}\" in second_example_first_answer_decoded\n    \"humor: 0.1\" in second_example_first_answer_decoded\n    \"creativity: 0.2\" in second_example_first_answer_decoded\n\n    second_example_second_answer_decoded = pythia_tokenizer.decode(batch.data[\"input_ids\"][2])\n    f\"{QA_SPECIAL_TOKENS['Question']}{second_example.messages[0].text}{eos}\" in second_example_second_answer_decoded\n    f\"{QA_SPECIAL_TOKENS['Answer']}{second_example.replies[1].text}{eos}\" in second_example_second_answer_decoded\n    \"humor: 0.4\" in second_example_second_answer_decoded\n    \"creativity: 0.3\" in second_example_second_answer_decoded\n\n\ndef test_ranking_collator_no_messages(pythia_tokenizer):\n    first_messages = None\n    first_replies = [\n        \"Response A to None\",\n        \"Response B to None\",\n        \"Response C to None\",\n    ]\n    examples = [(first_messages, first_replies)]\n    rdc = RankingDataCollator(tokenizer=pythia_tokenizer, padding=True)\n    eos = pythia_tokenizer.eos_token\n    examples_ds = [\n        DatasetEntryRm(messages=None, replies=[Utterance(text=r, role=Role.assistant) for r in first_replies])\n    ]\n    # make sure that formatting via dataset entry and lists is the same\n    for ex in [examples, examples_ds]:\n        batch, cu_lens = rdc(examples=ex)\n        assert len(batch) == 2\n        assert cu_lens == [0, len(first_replies)]\n        assert batch.data[\"attention_mask\"].shape[0] == 3  # we have 5 replies in total\n        assert batch.data[\"input_ids\"].shape == batch.data[\"attention_mask\"].shape\n\n        # check each instruction\n        assert pythia_tokenizer.decode(batch.data[\"input_ids\"][0]) == f\"{first_replies[0]}{eos}\"\n        assert pythia_tokenizer.decode(batch.data[\"input_ids\"][1]) == f\"{first_replies[1]}{eos}\"\n        assert pythia_tokenizer.decode(batch.data[\"input_ids\"][2]) == f\"{first_replies[2]}{eos}\"\n        assert (batch.attention_mask == torch.where(batch.input_ids == 1, 0, 1)).all()\n\n\ndef test_ranking_collator_local(pythia_tokenizer):\n    first_messages = [\"First Instruction.\"]\n    first_replies = [\n        \"Response A to First Instruction\",\n        \"Response B to First Instruction\",\n        \"First Response C to First Instruction\",\n    ]\n    second_messages = [\"Second Instruction.\"]\n    second_replies = [\"Response A to Second Instruction\", \"Response B to Second Instruction\"]\n    examples = [(first_messages, first_replies), (second_messages, second_replies)]\n    rdc = RankingDataCollator(tokenizer=pythia_tokenizer, padding=True)\n    eos = pythia_tokenizer.eos_token\n    pad = pythia_tokenizer.pad_token\n\n    examples_ds = [\n        create_dataset_entry_qa(mode=\"rm\", questions=first_messages, answers=first_replies),\n        create_dataset_entry_qa(mode=\"rm\", questions=second_messages, answers=second_replies),\n    ]\n    # make sure that formatting via dataset entry and lists is the same\n    for ex in [examples, examples_ds]:\n        batch, cu_lens = rdc(examples=ex)\n\n        assert len(batch) == 2\n        assert cu_lens == [0, len(first_replies), len(first_replies) + len(second_replies)]\n        assert batch.data[\"attention_mask\"].shape[0] == 5  # we have 5 replies in total\n        assert batch.data[\"input_ids\"].shape == batch.data[\"attention_mask\"].shape\n        # check each instruction\n        assert (\n            pythia_tokenizer.decode(batch.data[\"input_ids\"][0])\n            == f\"{QA_SPECIAL_TOKENS['Question']}{first_messages[0]}{eos}{QA_SPECIAL_TOKENS['Answer']}{first_replies[0]}{eos}\"\n            + 5 * pad\n        )\n        assert (\n            pythia_tokenizer.decode(batch.data[\"input_ids\"][1])\n            == f\"{QA_SPECIAL_TOKENS['Question']}{first_messages[0]}{eos}{QA_SPECIAL_TOKENS['Answer']}{first_replies[1]}{eos}\"\n            + 5 * pad\n        )\n        assert (\n            pythia_tokenizer.decode(batch.data[\"input_ids\"][2])\n            == f\"{QA_SPECIAL_TOKENS['Question']}{first_messages[0]}{eos}{QA_SPECIAL_TOKENS['Answer']}{first_replies[2]}{eos}\"\n        )\n        assert (\n            pythia_tokenizer.decode(batch.data[\"input_ids\"][3])\n            == f\"{QA_SPECIAL_TOKENS['Question']}{second_messages[0]}{eos}{QA_SPECIAL_TOKENS['Answer']}{second_replies[0]}{eos}\"\n            + 4 * pad\n        )\n        assert (\n            pythia_tokenizer.decode(batch.data[\"input_ids\"][4])\n            == f\"{QA_SPECIAL_TOKENS['Question']}{second_messages[0]}{eos}{QA_SPECIAL_TOKENS['Answer']}{second_replies[1]}{eos}\"\n            + 4 * pad\n        )\n\n        assert (batch.attention_mask == torch.where(batch.input_ids == 1, 0, 1)).all()\n\n\n@pytest.mark.skip(reason=\"manual\")\ndef test_rm_datasets():\n    # dummy configuration\n    config = Namespace(cache_dir=\".cache\", model_name=\"EleutherAI/pythia-70m-deduped\")\n\n    dataset_names = [\"anthropic_rlhf\", \"hf_summary_pairs\", \"webgpt\", \"hellaswag\", \"shp\", \"hf_summary\"]\n    for name in dataset_names:\n        train, val = get_one_dataset(conf=config, dataset_name=name, mode=\"rm\")\n        print(f\"dataset: '{name}' (train ({type(train)}): {len(train)}, val({type(val)}): {len(val)})\")\n\n        avg_number_continuations = sum(len(x[1]) for x in train) / len(train)\n        num_more_than_two = sum(1 if len(x[1]) > 2 else 0 for x in train)\n        print(f\"Average number of continuations: {avg_number_continuations} (with >2: {num_more_than_two})\")\n\n        for i in range(10):\n            item = train[i + 100]\n            print(f\"[{i}] Prefix: {item[0]}\")\n            continuations = item[1]\n            print(f\"[{i}] Continuations ({len(continuations)}):\")\n            for j, c in enumerate(continuations):\n                print(f\"[{i}.{j}]: {c}\")\n\n\n@pytest.mark.skip(reason=\"manual\")\ndef test_ranking_collator():\n    # dummy configuration\n    config = Namespace(cache_dir=\".cache\", model_name=\"EleutherAI/pythia-70m-deduped\")\n\n    # get a tokenizer\n    tokenizer = get_tokenizer(config)\n    print(type(tokenizer))\n\n    # load oasst dataset\n    kwargs = {\"lang\": \"en,es,de,fr\", \"input_file_path\": \"2023-03-13_oasst_ready_labels.jsonl.gz\", \"mode\": \"rm\"}\n    train, val = get_one_dataset(conf=config, dataset_name=\"oasst_export\", **kwargs)\n    print(len(train))\n    a = train[0]\n\n    print(type(a))\n    print(len(a))\n    print(\"prefix\", a[0])\n    print(\"continuations\", a[1])\n\n    # create RankingCollator\n    ranking_collator = RankingDataCollator(tokenizer=tokenizer)\n\n    dl = DataLoader(\n        train,\n        batch_size=4,\n        collate_fn=ranking_collator,\n        num_workers=1,\n        pin_memory=False,\n    )\n\n    data_iter = iter(dl)\n    b = next(data_iter)\n    x, y = b\n\n    input_ids = x.input_ids\n    attention_mask = x.attention_mask\n    print(\"input_ids\", input_ids.shape)\n    print(\"attention_mask\", attention_mask.shape)\n    print(\"input_ids[0, :200]\", input_ids[0, :200])\n    print(\"decoded input_ids[0, :200]:\", tokenizer.decode(input_ids[0, :200]))\n    print(\"decoded non masked input_ids[0]:\", tokenizer.decode(input_ids[0][x.attention_mask[0] == 1]))\n\n    print(y)\n\n\nif __name__ == \"__main__\":\n    test_rm_datasets()\n    # test_ranking_collator()\n", "file_name": "230568.py", "cwe": ["CWE-676: Use of Potentially Dangerous Function"]}
{"source": "import dataclasses\nimport gc\nimport glob\nimport os\n\nfrom accelerate import init_empty_weights\nfrom accelerate.utils import set_module_tensor_to_device\nfrom huggingface_hub import snapshot_download\nimport torch\nfrom torch import Tensor\nfrom torch.nn import functional as F\nimport torch.nn as nn\nfrom tqdm import tqdm\nfrom transformers import (\n    AutoConfig,\n    AutoModelForCausalLM,\n    AutoTokenizer,\n    AutoModel,\n    AutoModelForSeq2SeqLM,\n)\n\n\n@dataclasses.dataclass\nclass CompressionConfig:\n    \"\"\"Group-wise quantization.\"\"\"\n\n    num_bits: int\n    group_size: int\n    group_dim: int\n    symmetric: bool\n    enabled: bool = True\n\n\ndefault_compression_config = CompressionConfig(\n    num_bits=8, group_size=256, group_dim=1, symmetric=True, enabled=True\n)\n\n\nclass CLinear(nn.Module):\n    \"\"\"Compressed Linear Layer.\"\"\"\n\n    def __init__(self, weight=None, bias=None, device=None):\n        super().__init__()\n        if weight is None:\n            self.weight = None\n        elif isinstance(weight, Tensor):\n            self.weight = compress(weight.data.to(device), default_compression_config)\n        else:\n            self.weight = weight\n        self.bias = bias\n\n    def forward(self, input: Tensor) -> Tensor:\n        weight = decompress(self.weight, default_compression_config)\n        if self.bias is None:\n            return F.linear(input.to(weight.dtype), weight)\n        return F.linear(input.to(weight.dtype), weight, self.bias.to(weight.dtype))\n\n\ndef compress_module(module, target_device):\n    for attr_str in dir(module):\n        target_attr = getattr(module, attr_str)\n        if type(target_attr) == torch.nn.Linear:\n            setattr(\n                module,\n                attr_str,\n                CLinear(target_attr.weight, target_attr.bias, target_device),\n            )\n    for name, child in module.named_children():\n        compress_module(child, target_device)\n\n\ndef get_compressed_list(module, prefix=\"\"):\n    compressed_list = []\n    for attr_str in dir(module):\n        target_attr = getattr(module, attr_str)\n        if type(target_attr) == torch.nn.Linear:\n            full_name = (\n                f\"{prefix}.{attr_str}.weight\" if prefix else f\"{attr_str}.weight\"\n            )\n            compressed_list.append(full_name)\n    for name, child in module.named_children():\n        child_prefix = f\"{prefix}.{name}\" if prefix else name\n        for each in get_compressed_list(child, child_prefix):\n            compressed_list.append(each)\n    return compressed_list\n\n\ndef apply_compressed_weight(module, compressed_state_dict, target_device, prefix=\"\"):\n    for attr_str in dir(module):\n        target_attr = getattr(module, attr_str)\n        if type(target_attr) == torch.nn.Linear:\n            full_name = (\n                f\"{prefix}.{attr_str}.weight\" if prefix else f\"{attr_str}.weight\"\n            )\n            setattr(\n                module,\n                attr_str,\n                CLinear(\n                    compressed_state_dict[full_name], target_attr.bias, target_device\n                ),\n            )\n    for name, child in module.named_children():\n        child_prefix = f\"{prefix}.{name}\" if prefix else name\n        apply_compressed_weight(\n            child, compressed_state_dict, target_device, child_prefix\n        )\n\n\ndef load_compress_model(model_path, device, torch_dtype, use_fast, revision=\"main\"):\n    # partially load model\n    # `use_fast=True`` is not supported for some models.\n    try:\n        tokenizer = AutoTokenizer.from_pretrained(\n            model_path, use_fast=use_fast, revision=revision, trust_remote_code=True\n        )\n    except TypeError:\n        tokenizer = AutoTokenizer.from_pretrained(\n            model_path, use_fast=~use_fast, revision=revision, trust_remote_code=True\n        )\n    with init_empty_weights():\n        # `trust_remote_code` should be set as `True` for both AutoConfig and AutoModel\n        config = AutoConfig.from_pretrained(\n            model_path,\n            low_cpu_mem_usage=True,\n            torch_dtype=torch_dtype,\n            trust_remote_code=True,\n            revision=revision,\n        )\n        # some models are loaded by AutoModel but not AutoModelForCausalLM,\n        # such as chatglm, chatglm2\n        try:\n            # google/flan-* models are based on an AutoModelForSeq2SeqLM.\n            if \"T5Config\" in str(type(config)):\n                model = AutoModelForSeq2SeqLM.from_config(\n                    config, trust_remote_code=True\n                )\n            else:\n                model = AutoModelForCausalLM.from_config(config, trust_remote_code=True)\n        except NameError:\n            model = AutoModel.from_config(config, trust_remote_code=True)\n        linear_weights = get_compressed_list(model)\n    if os.path.exists(model_path):\n        # `model_path` is a local folder\n        base_pattern = os.path.join(model_path, \"pytorch_model*.bin\")\n    else:\n        # `model_path` is a cached Hugging Face repo\n        # We don't necessarily need to download the model' repo again if there is a cache.\n        # So check the default huggingface cache first.\n        model_path_temp = os.path.join(\n            os.path.expanduser(\"~\"),\n            \".cache/huggingface/hub\",\n            \"models--\" + model_path.replace(\"/\", \"--\"),\n            \"snapshots/\",\n        )\n        downloaded = False\n        if os.path.exists(model_path_temp):\n            temp_last_dir = os.listdir(model_path_temp)[-1]\n            model_path_temp = os.path.join(model_path_temp, temp_last_dir)\n            base_pattern = os.path.join(model_path_temp, \"pytorch_model*.bin\")\n            files = glob.glob(base_pattern)\n            if len(files) > 0:\n                downloaded = True\n\n        if downloaded:\n            model_path = model_path_temp\n        else:\n            model_path = snapshot_download(model_path, revision=revision)\n        base_pattern = os.path.join(model_path, \"pytorch_model*.bin\")\n\n    files = glob.glob(base_pattern)\n    use_safetensors = False\n    if len(files) == 0:\n        base_pattern = os.path.join(model_path, \"*.safetensors\")\n        files = glob.glob(base_pattern)\n        use_safetensors = True\n    if len(files) == 0:\n        raise ValueError(\n            f\"Cannot find any model weight files. \"\n            f\"Please check your (cached) weight path: {model_path}\"\n        )\n\n    compressed_state_dict = {}\n    if use_safetensors:\n        from safetensors.torch import load_file\n    for filename in tqdm(files):\n        if use_safetensors:\n            tmp_state_dict = load_file(filename)\n        else:\n            tmp_state_dict = torch.load(\n                filename, map_location=lambda storage, loc: storage\n            )\n        for name in tmp_state_dict:\n            if name in linear_weights:\n                tensor = tmp_state_dict[name].to(device, dtype=torch_dtype)\n                compressed_state_dict[name] = compress(\n                    tensor, default_compression_config\n                )\n            else:\n                compressed_state_dict[name] = tmp_state_dict[name].to(\n                    device, dtype=torch_dtype\n                )\n            tmp_state_dict[name] = None\n            tensor = None\n            gc.collect()\n            torch.cuda.empty_cache()\n            if device == \"xpu\":\n                torch.xpu.empty_cache()\n            if device == \"npu\":\n                torch.npu.empty_cache()\n\n    for name in model.state_dict():\n        if name not in linear_weights:\n            set_module_tensor_to_device(\n                model, name, device, value=compressed_state_dict[name]\n            )\n    apply_compressed_weight(model, compressed_state_dict, device)\n\n    if torch_dtype == torch.float16:\n        model.half()\n    model.to(device)\n    model.eval()\n\n    return model, tokenizer\n\n\ndef compress(tensor, config):\n    \"\"\"Simulate group-wise quantization.\"\"\"\n    if not config.enabled:\n        return tensor\n\n    group_size, num_bits, group_dim, symmetric = (\n        config.group_size,\n        config.num_bits,\n        config.group_dim,\n        config.symmetric,\n    )\n    assert num_bits <= 8\n\n    original_shape = tensor.shape\n    num_groups = (original_shape[group_dim] + group_size - 1) // group_size\n    new_shape = (\n        original_shape[:group_dim]\n        + (num_groups, group_size)\n        + original_shape[group_dim + 1 :]\n    )\n\n    # Pad\n    pad_len = (group_size - original_shape[group_dim] % group_size) % group_size\n    if pad_len != 0:\n        pad_shape = (\n            original_shape[:group_dim] + (pad_len,) + original_shape[group_dim + 1 :]\n        )\n        tensor = torch.cat(\n            [tensor, torch.zeros(pad_shape, dtype=tensor.dtype, device=tensor.device)],\n            dim=group_dim,\n        )\n    data = tensor.view(new_shape)\n\n    # Quantize\n    if symmetric:\n        B = 2 ** (num_bits - 1) - 1\n        scale = B / torch.max(data.abs(), dim=group_dim + 1, keepdim=True)[0]\n        data = data * scale\n        data = data.clamp_(-B, B).round_().to(torch.int8)\n        return data, scale, original_shape\n    else:\n        B = 2**num_bits - 1\n        mn = torch.min(data, dim=group_dim + 1, keepdim=True)[0]\n        mx = torch.max(data, dim=group_dim + 1, keepdim=True)[0]\n\n        scale = B / (mx - mn)\n        data = data - mn\n        data.mul_(scale)\n\n        data = data.clamp_(0, B).round_().to(torch.uint8)\n        return data, mn, scale, original_shape\n\n\ndef decompress(packed_data, config):\n    \"\"\"Simulate group-wise dequantization.\"\"\"\n    if not config.enabled:\n        return packed_data\n\n    group_size, num_bits, group_dim, symmetric = (\n        config.group_size,\n        config.num_bits,\n        config.group_dim,\n        config.symmetric,\n    )\n\n    # Dequantize\n    if symmetric:\n        data, scale, original_shape = packed_data\n        data = data / scale\n    else:\n        data, mn, scale, original_shape = packed_data\n        data = data / scale\n        data.add_(mn)\n\n    # Unpad\n    pad_len = (group_size - original_shape[group_dim] % group_size) % group_size\n    if pad_len:\n        padded_original_shape = (\n            original_shape[:group_dim]\n            + (original_shape[group_dim] + pad_len,)\n            + original_shape[group_dim + 1 :]\n        )\n        data = data.reshape(padded_original_shape)\n        indices = [slice(0, x) for x in original_shape]\n        return data[indices].contiguous()\n    else:\n        return data.view(original_shape)\n", "file_name": "914791.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\nfrom __future__ import annotations\n\n__version__ = \"3.0.0.dev0\"\n\nimport os\nimport sys\nimport warnings\nfrom typing import TYPE_CHECKING\n\nif os.environ.get(\"_AIRFLOW_PATCH_GEVENT\"):\n    # If you are using gevents and start airflow webserver, you might want to run gevent monkeypatching\n    # as one of the first thing when Airflow is started. This allows gevent to patch networking and other\n    # system libraries to make them gevent-compatible before anything else patches them (for example boto)\n    from gevent.monkey import patch_all\n\n    patch_all()\n\nif sys.platform == \"win32\":\n    warnings.warn(\n        \"Airflow currently can be run on POSIX-compliant Operating Systems. For development, \"\n        \"it is regularly tested on fairly modern Linux Distros and recent versions of macOS. \"\n        \"On Windows you can run it via WSL2 (Windows Subsystem for Linux 2) or via Linux Containers. \"\n        \"The work to add Windows support is tracked via https://github.com/apache/airflow/issues/10388, \"\n        \"but it is not a high priority.\",\n        category=RuntimeWarning,\n        stacklevel=1,\n    )\n\n# The configuration module initializes and validates the conf object as a side effect the first\n# time it is imported. If it is not imported before importing the settings module, the conf\n# object will then be initted/validated as a side effect of it being imported in settings,\n# however this can cause issues since those modules are very tightly coupled and can\n# very easily cause import cycles in the conf init/validate code (since downstream code from\n# those functions likely import settings).\n# configuration is therefore initted early here, simply by importing it.\nfrom airflow import configuration, settings\n\n__all__ = [\n    \"__version__\",\n    \"DAG\",\n    \"Dataset\",\n    \"XComArg\",\n]\n\n# Make `airflow` a namespace package, supporting installing\n# airflow.providers.* in different locations (i.e. one in site, and one in user\n# lib.)\n__path__ = __import__(\"pkgutil\").extend_path(__path__, __name__)  # type: ignore\n\n\n# Perform side-effects unless someone has explicitly opted out before import\n# WARNING: DO NOT USE THIS UNLESS YOU REALLY KNOW WHAT YOU'RE DOING.\n# This environment variable prevents proper initialization, and things like\n# configs, logging, the ORM, etc. will be broken. It is only useful if you only\n# access certain trivial constants and free functions (e.g. `__version__`).\nif not os.environ.get(\"_AIRFLOW__AS_LIBRARY\", None):\n    settings.initialize()\n\n# Things to lazy import in form {local_name: ('target_module', 'target_name', 'deprecated')}\n__lazy_imports: dict[str, tuple[str, str, bool]] = {\n    \"DAG\": (\".models.dag\", \"DAG\", False),\n    \"Dataset\": (\".datasets\", \"Dataset\", False),\n    \"XComArg\": (\".models.xcom_arg\", \"XComArg\", False),\n    \"version\": (\".version\", \"\", False),\n    # Deprecated lazy imports\n    \"AirflowException\": (\".exceptions\", \"AirflowException\", True),\n}\nif TYPE_CHECKING:\n    # These objects are imported by PEP-562, however, static analyzers and IDE's\n    # have no idea about typing of these objects.\n    # Add it under TYPE_CHECKING block should help with it.\n    from airflow.models.dag import DAG\n    from airflow.models.dataset import Dataset\n    from airflow.models.xcom_arg import XComArg\n\n\ndef __getattr__(name: str):\n    # PEP-562: Lazy loaded attributes on python modules\n    module_path, attr_name, deprecated = __lazy_imports.get(name, (\"\", \"\", False))\n    if not module_path:\n        if name.startswith(\"PY3\") and (py_minor := name[3:]) in (\"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"):\n            warnings.warn(\n                f\"Python version constraint {name!r} is deprecated and will be removed in the future. \"\n                f\"Please get version info from the 'sys.version_info'.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            return sys.version_info >= (3, int(py_minor))\n\n        raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n    elif deprecated:\n        warnings.warn(\n            f\"Import {name!r} directly from the airflow module is deprecated and \"\n            f\"will be removed in the future. Please import it from 'airflow{module_path}.{attr_name}'.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    import importlib\n\n    mod = importlib.import_module(module_path, __name__)\n    if attr_name:\n        val = getattr(mod, attr_name)\n    else:\n        val = mod\n\n    # Store for next time\n    globals()[name] = val\n    return val\n\n\nif not settings.LAZY_LOAD_PROVIDERS:\n    from airflow.providers_manager import ProvidersManager\n\n    manager = ProvidersManager()\n    manager.initialize_providers_list()\n    manager.initialize_providers_hooks()\n    manager.initialize_providers_extra_links()\nif not settings.LAZY_LOAD_PLUGINS:\n    from airflow import plugins_manager\n\n    plugins_manager.ensure_plugins_loaded()\n", "file_name": "023226.py", "cwe": ["CWE-706: Use of Incorrectly-Resolved Name or Reference"]}
{"source": "# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\nfrom __future__ import annotations\n\nimport warnings\n\nfrom airflow.exceptions import RemovedInAirflow3Warning\nfrom airflow.utils.airflow_flask_app import get_airflow_app\n\n#\n# Copyright (c) 2013, Michael Komitee\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without modification,\n# are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\"\"\"Kerberos authentication module\"\"\"\nimport logging\nimport os\nfrom functools import wraps\nfrom typing import TYPE_CHECKING, Callable, NamedTuple, TypeVar, cast\n\nimport kerberos\nfrom flask import Response, g, make_response, request\n\nfrom airflow.configuration import conf\nfrom airflow.utils.net import getfqdn\n\nif TYPE_CHECKING:\n    from airflow.auth.managers.models.base_user import BaseUser\n\nlog = logging.getLogger(__name__)\n\n\nclass KerberosService:\n    \"\"\"Class to keep information about the Kerberos Service initialized.\"\"\"\n\n    def __init__(self):\n        self.service_name = None\n\n\nclass _KerberosAuth(NamedTuple):\n    return_code: int | None\n    user: str = \"\"\n    token: str | None = None\n\n\n# Stores currently initialized Kerberos Service\n_KERBEROS_SERVICE = KerberosService()\n\n\ndef init_app(app):\n    \"\"\"Initialize application with kerberos.\"\"\"\n    hostname = app.config.get(\"SERVER_NAME\")\n    if not hostname:\n        hostname = getfqdn()\n    log.info(\"Kerberos: hostname %s\", hostname)\n\n    service = \"airflow\"\n\n    _KERBEROS_SERVICE.service_name = f\"{service}@{hostname}\"\n\n    if \"KRB5_KTNAME\" not in os.environ:\n        os.environ[\"KRB5_KTNAME\"] = conf.get(\"kerberos\", \"keytab\")\n\n    try:\n        log.info(\"Kerberos init: %s %s\", service, hostname)\n        principal = kerberos.getServerPrincipalDetails(service, hostname)\n    except kerberos.KrbError as err:\n        log.warning(\"Kerberos: %s\", err)\n    else:\n        log.info(\"Kerberos API: server is %s\", principal)\n\n\ndef _unauthorized():\n    \"\"\"Indicate that authorization is required.\"\"\"\n    return Response(\"Unauthorized\", 401, {\"WWW-Authenticate\": \"Negotiate\"})\n\n\ndef _forbidden():\n    return Response(\"Forbidden\", 403)\n\n\ndef _gssapi_authenticate(token) -> _KerberosAuth | None:\n    state = None\n    try:\n        return_code, state = kerberos.authGSSServerInit(_KERBEROS_SERVICE.service_name)\n        if return_code != kerberos.AUTH_GSS_COMPLETE:\n            return _KerberosAuth(return_code=None)\n\n        if (return_code := kerberos.authGSSServerStep(state, token)) == kerberos.AUTH_GSS_COMPLETE:\n            return _KerberosAuth(\n                return_code=return_code,\n                user=kerberos.authGSSServerUserName(state),\n                token=kerberos.authGSSServerResponse(state),\n            )\n        elif return_code == kerberos.AUTH_GSS_CONTINUE:\n            return _KerberosAuth(return_code=return_code)\n        return _KerberosAuth(return_code=return_code)\n    except kerberos.GSSError:\n        return _KerberosAuth(return_code=None)\n    finally:\n        if state:\n            kerberos.authGSSServerClean(state)\n\n\nT = TypeVar(\"T\", bound=Callable)\n\n\ndef requires_authentication(function: T, find_user: Callable[[str], BaseUser] | None = None):\n    \"\"\"Decorate functions that require authentication with Kerberos.\"\"\"\n    if not find_user:\n        warnings.warn(\n            \"This module is deprecated. Please use \"\n            \"`airflow.providers.fab.auth_manager.api.auth.backend.kerberos_auth` instead.\",\n            RemovedInAirflow3Warning,\n            stacklevel=2,\n        )\n        find_user = get_airflow_app().appbuilder.sm.find_user\n\n    @wraps(function)\n    def decorated(*args, **kwargs):\n        header = request.headers.get(\"Authorization\")\n        if header:\n            token = \"\".join(header.split()[1:])\n            auth = _gssapi_authenticate(token)\n            if auth.return_code == kerberos.AUTH_GSS_COMPLETE:\n                g.user = find_user(auth.user)\n                response = function(*args, **kwargs)\n                response = make_response(response)\n                if auth.token is not None:\n                    response.headers[\"WWW-Authenticate\"] = f\"negotiate {auth.token}\"\n                return response\n            elif auth.return_code != kerberos.AUTH_GSS_CONTINUE:\n                return _forbidden()\n        return _unauthorized()\n\n    return cast(T, decorated)\n\n\ndef __getattr__(name):\n    # PEP-562: Lazy loaded attributes on python modules\n    if name != \"CLIENT_AUTH\":\n        raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n\n    from requests_kerberos import HTTPKerberosAuth\n\n    val = HTTPKerberosAuth(service=\"airflow\")\n    # Store for next time\n    globals()[name] = val\n    return val\n", "file_name": "218664.py", "cwe": ["CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"]}
{"source": "# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n\"\"\"Internal API command.\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport os\nimport signal\nimport subprocess\nimport sys\nimport textwrap\nfrom contextlib import suppress\nfrom pathlib import Path\nfrom tempfile import gettempdir\nfrom time import sleep\n\nimport psutil\nfrom flask import Flask\nfrom flask_appbuilder import SQLA\nfrom flask_caching import Cache\nfrom flask_wtf.csrf import CSRFProtect\nfrom lockfile.pidlockfile import read_pid_from_pidfile\nfrom sqlalchemy.engine.url import make_url\n\nfrom airflow import settings\nfrom airflow.api_internal.internal_api_call import InternalApiConfig\nfrom airflow.cli.commands.daemon_utils import run_command_with_daemon_option\nfrom airflow.cli.commands.webserver_command import GunicornMonitor\nfrom airflow.configuration import conf\nfrom airflow.exceptions import AirflowConfigException\nfrom airflow.logging_config import configure_logging\nfrom airflow.models import import_all_models\nfrom airflow.utils import cli as cli_utils\nfrom airflow.utils.cli import setup_locations\nfrom airflow.utils.providers_configuration_loader import providers_configuration_loaded\nfrom airflow.www.extensions.init_dagbag import init_dagbag\nfrom airflow.www.extensions.init_jinja_globals import init_jinja_globals\nfrom airflow.www.extensions.init_manifest_files import configure_manifest_files\nfrom airflow.www.extensions.init_security import init_xframe_protection\nfrom airflow.www.extensions.init_views import init_api_internal, init_error_handlers\n\nlog = logging.getLogger(__name__)\napp: Flask | None = None\n\n\n@cli_utils.action_cli\n@providers_configuration_loaded\ndef internal_api(args):\n    \"\"\"Start Airflow Internal API.\"\"\"\n    print(settings.HEADER)\n\n    access_logfile = args.access_logfile or \"-\"\n    error_logfile = args.error_logfile or \"-\"\n    access_logformat = args.access_logformat\n    num_workers = args.workers\n    worker_timeout = args.worker_timeout\n\n    if args.debug:\n        log.info(\"Starting the Internal API server on port %s and host %s.\", args.port, args.hostname)\n        app = create_app(testing=conf.getboolean(\"core\", \"unit_test_mode\"))\n        app.run(\n            debug=True,  # nosec\n            use_reloader=not app.config[\"TESTING\"],\n            port=args.port,\n            host=args.hostname,\n        )\n    else:\n        log.info(\n            textwrap.dedent(\n                f\"\"\"\\\n                Running the Gunicorn Server with:\n                Workers: {num_workers} {args.workerclass}\n                Host: {args.hostname}:{args.port}\n                Timeout: {worker_timeout}\n                Logfiles: {access_logfile} {error_logfile}\n                Access Logformat: {access_logformat}\n                =================================================================\"\"\"\n            )\n        )\n\n        pid_file, _, _, _ = setup_locations(\"internal-api\", pid=args.pid)\n\n        run_args = [\n            sys.executable,\n            \"-m\",\n            \"gunicorn\",\n            \"--workers\",\n            str(num_workers),\n            \"--worker-class\",\n            str(args.workerclass),\n            \"--timeout\",\n            str(worker_timeout),\n            \"--bind\",\n            args.hostname + \":\" + str(args.port),\n            \"--name\",\n            \"airflow-internal-api\",\n            \"--pid\",\n            pid_file,\n            \"--access-logfile\",\n            str(access_logfile),\n            \"--error-logfile\",\n            str(error_logfile),\n            \"--config\",\n            \"python:airflow.api_internal.gunicorn_config\",\n        ]\n\n        if args.access_logformat and args.access_logformat.strip():\n            run_args += [\"--access-logformat\", str(args.access_logformat)]\n\n        if args.daemon:\n            run_args += [\"--daemon\"]\n\n        run_args += [\"airflow.cli.commands.internal_api_command:cached_app()\"]\n\n        # To prevent different workers creating the web app and\n        # all writing to the database at the same time, we use the --preload option.\n        # With the preload option, the app is loaded before the workers are forked, and each worker will\n        # then have a copy of the app\n        run_args += [\"--preload\"]\n\n        def kill_proc(signum: int, gunicorn_master_proc: psutil.Process | subprocess.Popen):\n            log.info(\"Received signal: %s. Closing gunicorn.\", signum)\n            gunicorn_master_proc.terminate()\n            with suppress(TimeoutError):\n                gunicorn_master_proc.wait(timeout=30)\n            if isinstance(gunicorn_master_proc, subprocess.Popen):\n                still_running = gunicorn_master_proc.poll() is not None\n            else:\n                still_running = gunicorn_master_proc.is_running()\n            if still_running:\n                gunicorn_master_proc.kill()\n            sys.exit(0)\n\n        def monitor_gunicorn(gunicorn_master_proc: psutil.Process | subprocess.Popen):\n            # Register signal handlers\n            signal.signal(signal.SIGINT, lambda signum, _: kill_proc(signum, gunicorn_master_proc))\n            signal.signal(signal.SIGTERM, lambda signum, _: kill_proc(signum, gunicorn_master_proc))\n\n            # These run forever until SIG{INT, TERM, KILL, ...} signal is sent\n            GunicornMonitor(\n                gunicorn_master_pid=gunicorn_master_proc.pid,\n                num_workers_expected=num_workers,\n                master_timeout=120,\n                worker_refresh_interval=30,\n                worker_refresh_batch_size=1,\n                reload_on_plugin_change=False,\n            ).start()\n\n        def start_and_monitor_gunicorn(args):\n            if args.daemon:\n                subprocess.Popen(run_args, close_fds=True)\n\n                # Reading pid of gunicorn master as it will be different that\n                # the one of process spawned above.\n                gunicorn_master_proc_pid = None\n                while not gunicorn_master_proc_pid:\n                    sleep(0.1)\n                    gunicorn_master_proc_pid = read_pid_from_pidfile(pid_file)\n\n                # Run Gunicorn monitor\n                gunicorn_master_proc = psutil.Process(gunicorn_master_proc_pid)\n                monitor_gunicorn(gunicorn_master_proc)\n            else:\n                with subprocess.Popen(run_args, close_fds=True) as gunicorn_master_proc:\n                    monitor_gunicorn(gunicorn_master_proc)\n\n        if args.daemon:\n            # This makes possible errors get reported before daemonization\n            os.environ[\"SKIP_DAGS_PARSING\"] = \"True\"\n            create_app(None)\n            os.environ.pop(\"SKIP_DAGS_PARSING\")\n\n        pid_file_path = Path(pid_file)\n        monitor_pid_file = str(pid_file_path.with_name(f\"{pid_file_path.stem}-monitor{pid_file_path.suffix}\"))\n        run_command_with_daemon_option(\n            args=args,\n            process_name=\"internal-api\",\n            callback=lambda: start_and_monitor_gunicorn(args),\n            should_setup_logging=True,\n            pid_file=monitor_pid_file,\n        )\n\n\ndef create_app(config=None, testing=False):\n    \"\"\"Create a new instance of Airflow Internal API app.\"\"\"\n    flask_app = Flask(__name__)\n\n    flask_app.config[\"APP_NAME\"] = \"Airflow Internal API\"\n    flask_app.config[\"TESTING\"] = testing\n    flask_app.config[\"SQLALCHEMY_DATABASE_URI\"] = conf.get(\"database\", \"SQL_ALCHEMY_CONN\")\n\n    url = make_url(flask_app.config[\"SQLALCHEMY_DATABASE_URI\"])\n    if url.drivername == \"sqlite\" and url.database and not url.database.startswith(\"/\"):\n        raise AirflowConfigException(\n            f'Cannot use relative path: `{conf.get(\"database\", \"SQL_ALCHEMY_CONN\")}` to connect to sqlite. '\n            \"Please use absolute path such as `sqlite:////tmp/airflow.db`.\"\n        )\n\n    flask_app.config[\"SQLALCHEMY_TRACK_MODIFICATIONS\"] = False\n\n    flask_app.config[\"SESSION_COOKIE_HTTPONLY\"] = True\n    flask_app.config[\"SESSION_COOKIE_SAMESITE\"] = \"Lax\"\n\n    if config:\n        flask_app.config.from_mapping(config)\n\n    if \"SQLALCHEMY_ENGINE_OPTIONS\" not in flask_app.config:\n        flask_app.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = settings.prepare_engine_args()\n\n    if conf.getboolean(\"core\", \"database_access_isolation\", fallback=False):\n        InternalApiConfig.set_use_database_access(\"Gunicorn worker initialization\")\n    else:\n        raise AirflowConfigException(\n            \"The internal-api component should only be run when database_access_isolation is enabled.\"\n        )\n\n    csrf = CSRFProtect()\n    csrf.init_app(flask_app)\n\n    db = SQLA()\n    db.session = settings.Session\n    db.init_app(flask_app)\n\n    init_dagbag(flask_app)\n\n    cache_config = {\"CACHE_TYPE\": \"flask_caching.backends.filesystem\", \"CACHE_DIR\": gettempdir()}\n    Cache(app=flask_app, config=cache_config)\n\n    configure_logging()\n    configure_manifest_files(flask_app)\n\n    import_all_models()\n\n    with flask_app.app_context():\n        init_error_handlers(flask_app)\n        init_api_internal(flask_app, standalone_api=True)\n\n        init_jinja_globals(flask_app)\n        init_xframe_protection(flask_app)\n    return flask_app\n\n\ndef cached_app(config=None, testing=False):\n    \"\"\"Return cached instance of Airflow Internal API app.\"\"\"\n    global app\n    if not app:\n        app = create_app(config=config, testing=testing)\n    return app\n", "file_name": "409624.py", "cwe": ["CWE-489: Active Debug Code"]}
{"source": "# Copyright (c) SenseTime Research. All rights reserved.\n\n\nimport os\nimport argparse \nimport numpy as np\nimport torch\nfrom torch.utils.data import DataLoader\nfrom torchvision.transforms import transforms\nfrom utils.ImagesDataset import ImagesDataset\n\nimport cv2\nimport time\nimport copy\nimport imutils\n\n# for openpose body keypoint detector : # (src:https://github.com/Hzzone/pytorch-openpose)\nfrom openpose.src import util\nfrom openpose.src.body import Body\n\n# for paddlepaddle human segmentation : #(src: https://github.com/PaddlePaddle/PaddleSeg/blob/release/2.5/contrib/PP-HumanSeg/)\nfrom PP_HumanSeg.deploy.infer import Predictor as PP_HumenSeg_Predictor\n\nimport math\ndef angle_between_points(p0,p1,p2):\n    if p0[1]==-1 or p1[1]==-1 or p2[1]==-1:\n        return -1\n    a = (p1[0]-p0[0])**2 + (p1[1]-p0[1])**2\n    b = (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2\n    c = (p2[0]-p0[0])**2 + (p2[1]-p0[1])**2 \n    if a * b == 0:\n        return -1\n    return math.acos((a+b-c) / math.sqrt(4*a*b)) * 180 / math.pi\n\n\ndef crop_img_with_padding(img, keypoints, rect):\n    person_xmin,person_xmax, ymin, ymax= rect\n    img_h,img_w,_ = img.shape    ## find body center using keypoints\n    middle_shoulder_x = keypoints[1][0]\n    middle_hip_x = (keypoints[8][0] + keypoints[11][0]) // 2\n    mid_x = (middle_hip_x + middle_shoulder_x) // 2    \n    mid_y = (ymin + ymax) // 2\n    ## find which side (l or r) is further than center x, use the further side\n    if abs(mid_x-person_xmin) > abs(person_xmax-mid_x): #left further\n        xmin = person_xmin\n        xmax = mid_x + (mid_x-person_xmin)\n    else:\n        ############### may be negtive\n        ### in this case, the script won't output any image, leave the case like this\n        ### since we don't want to pad human body\n        xmin = mid_x - (person_xmax-mid_x)   \n        xmax = person_xmax \n\n    w = xmax - xmin\n    h = ymax - ymin\n    ## pad rectangle to w:h = 1:2 ## calculate desired border length\n    if h / w >= 2: #pad horizontally\n        target_w = h // 2\n        xmin_prime = int(mid_x - target_w / 2)\n        xmax_prime = int(mid_x + target_w / 2)\n        if xmin_prime < 0:\n            pad_left = abs(xmin_prime)# - xmin\n            xmin = 0\n        else:\n            pad_left = 0\n            xmin = xmin_prime\n        if xmax_prime > img_w:\n            pad_right = xmax_prime - img_w\n            xmax = img_w\n        else:\n            pad_right = 0\n            xmax = xmax_prime\n\n        cropped_img = img[int(ymin):int(ymax), int(xmin):int(xmax)]\n        im_pad = cv2.copyMakeBorder(cropped_img, 0, 0, int(pad_left),  int(pad_right), cv2.BORDER_REPLICATE) \n    else: #pad vertically\n        target_h = w * 2\n        ymin_prime = mid_y - (target_h / 2)\n        ymax_prime = mid_y + (target_h / 2) \n        if ymin_prime < 0: \n            pad_up = abs(ymin_prime)# - ymin\n            ymin = 0\n        else:\n            pad_up = 0\n            ymin = ymin_prime\n        if ymax_prime > img_h:\n            pad_down = ymax_prime - img_h\n            ymax = img_h\n        else:\n            pad_down = 0\n            ymax = ymax_prime\n        print(ymin,ymax, xmin,xmax, img.shape)\n\n        cropped_img = img[int(ymin):int(ymax), int(xmin):int(xmax)]\n        im_pad = cv2.copyMakeBorder(cropped_img, int(pad_up), int(pad_down), 0,\n                                    0, cv2.BORDER_REPLICATE) \n    result = cv2.resize(im_pad,(512,1024),interpolation = cv2.INTER_AREA)\n    return result\n\n\ndef run(args):\n    os.makedirs(args.output_folder, exist_ok=True)\n    dataset = ImagesDataset(args.image_folder, transforms.Compose([transforms.ToTensor()]))\n    dataloader = DataLoader(dataset, batch_size=1, shuffle=False)\n\n    body_estimation = Body('openpose/model/body_pose_model.pth')\n\n    total = len(dataloader)\n    print('Num of dataloader : ', total)\n    os.makedirs(f'{args.output_folder}', exist_ok=True)\n    # os.makedirs(f'{args.output_folder}/middle_result', exist_ok=True)\n    \n    ## initialzide HumenSeg\n    human_seg_args = {}\n    human_seg_args['cfg'] = 'PP_HumanSeg/export_model/deeplabv3p_resnet50_os8_humanseg_512x512_100k_with_softmax/deploy.yaml'\n    human_seg_args['input_shape'] = [1024,512]\n    human_seg_args['save_dir'] = args.output_folder\n    human_seg_args['soft_predict'] = False\n    human_seg_args['use_gpu'] = True\n    human_seg_args['test_speed'] = False\n    human_seg_args['use_optic_flow'] = False\n    human_seg_args['add_argmax'] = True\n    human_seg_args= argparse.Namespace(**human_seg_args)\n    human_seg = PP_HumenSeg_Predictor(human_seg_args)\n\n    from tqdm import tqdm\n    for fname, image in tqdm(dataloader):\n        # try:\n        ## tensor to numpy image\n        fname = fname[0]\n        print(f'Processing \\'{fname}\\'.')\n        \n        image = (image.permute(0, 2, 3, 1) * 255).clamp(0, 255)\n        image = image.squeeze(0).numpy() # --> tensor to numpy, (H,W,C)\n        # avoid super high res img\n        if image.shape[0] >= 2000: # height  ### for shein image\n            ratio = image.shape[0]/1200 #height\n            dim = (int(image.shape[1]/ratio),1200)#(width, height)\n            image = cv2.resize(image, dim, interpolation = cv2.INTER_AREA)\n        image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)\n\n        ## create segmentation\n        # mybg = cv2.imread('mybg.png') \n        comb, segmentation, bg, ori_img = human_seg.run(image,None)  #mybg) \n        # cv2.imwrite('comb.png',comb)  # [0,255]\n        # cv2.imwrite('alpha.png',segmentation*255) # segmentation [0,1] --> [0.255]\n        # cv2.imwrite('bg.png',bg)  #[0,255]\n        # cv2.imwrite('ori_img.png',ori_img) # [0,255]\n\n        masks_np = (segmentation* 255)# .byte().cpu().numpy() #1024,512,1\n        mask0_np = masks_np[:,:,0].astype(np.uint8)#[0, :, :]\n        contours = cv2.findContours(mask0_np,  cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        cnts = imutils.grab_contours(contours)\n        c = max(cnts, key=cv2.contourArea)\n        extTop = tuple(c[c[:, :, 1].argmin()][0])\n        extBot = tuple(c[c[:, :, 1].argmax()][0])\n        extBot = list(extBot)\n        extTop = list(extTop)\n        pad_range = int((extBot[1]-extTop[1])*0.05)\n        if (int(extTop[1])<=5 and int(extTop[1])>0) and (comb.shape[0]>int(extBot[1]) and int(extBot[1])>=comb.shape[0]-5): #seg mask already reaches to the edge\n            #pad with pure white, top 100 px, bottom 100 px\n            comb= cv2.copyMakeBorder(comb,pad_range+5,pad_range+5,0,0,cv2.BORDER_CONSTANT,value=[255,255,255]) \n        elif int(extTop[1])<=0 or int(extBot[1])>=comb.shape[0]:\n            print('PAD: body out of boundary', fname) #should not happened\n            return {}\n        else:\n            comb = cv2.copyMakeBorder(comb, pad_range+5, pad_range+5, 0, 0, cv2.BORDER_REPLICATE) #105 instead of 100: give some extra space\n        extBot[1] = extBot[1] + pad_range+5\n        extTop[1] = extTop[1] + pad_range+5\n\n        extLeft = tuple(c[c[:, :, 0].argmin()][0])\n        extRight = tuple(c[c[:, :, 0].argmax()][0])\n        extLeft = list(extLeft)\n        extRight = list(extRight)\n        person_ymin = int(extTop[1])-pad_range # 100\n        person_ymax = int(extBot[1])+pad_range # 100 #height\n        if person_ymin<0 or person_ymax>comb.shape[0]: # out of range\n            return {}\n        person_xmin = int(extLeft[0])\n        person_xmax = int(extRight[0])\n        rect =  [person_xmin,person_xmax,person_ymin, person_ymax]\n        # recimg = copy.deepcopy(comb)\n        # cv2.rectangle(recimg,(person_xmin,person_ymin),(person_xmax,person_ymax),(0,255,0),2)\n        # cv2.imwrite(f'{args.output_folder}/middle_result/{fname}_rec.png',recimg)\n\n        ## detect keypoints\n        keypoints, subset = body_estimation(comb)\n        # print(keypoints, subset, len(subset))\n        if len(subset) != 1 or (len(subset)==1 and subset[0][-1]<15): \n            print(f'Processing \\'{fname}\\'. Please import image contains one person only. Also can check segmentation mask. ')\n            continue\n\n        # canvas = copy.deepcopy(comb)\n        # canvas = util.draw_bodypose(canvas, keypoints, subset, show_number=True)\n        # cv2.imwrite(f'{args.output_folder}/middle_result/{fname}_keypoints.png',canvas)\n\n        comb = crop_img_with_padding(comb, keypoints, rect)\n\n        \n        cv2.imwrite(f'{args.output_folder}/{fname}.png', comb)\n        print(f' -- Finished processing \\'{fname}\\'. --')\n        # except:\n        #     print(f'Processing \\'{fname}\\'. Not satisfied the alignment strategy.')\n        \n        \nif __name__ == '__main__':\n    torch.backends.cudnn.benchmark = True\n    torch.backends.cudnn.deterministic = False\n    \n    t1 = time.time()\n    arg_formatter = argparse.ArgumentDefaultsHelpFormatter\n    description = 'StyleGAN-Human data process'\n    parser = argparse.ArgumentParser(formatter_class=arg_formatter,\n                                     description=description)\n    parser.add_argument('--image-folder', type=str, dest='image_folder')\n    parser.add_argument('--output-folder', dest='output_folder', default='results', type=str)\n    # parser.add_argument('--cfg', dest='cfg for segmentation', default='PP_HumanSeg/export_model/ppseg_lite_portrait_398x224_with_softmax/deploy.yaml', type=str)\n\n    print('parsing arguments')\n    cmd_args = parser.parse_args()\n    run(cmd_args)\n\n    print('total time elapsed: ', str(time.time() - t1))", "file_name": "192152.py", "cwe": ["CWE-676: Use of Potentially Dangerous Function"]}
{"source": "# Copyright (c) SenseTime Research. All rights reserved.\n\nfrom legacy import save_obj, load_pkl\nimport torch\nfrom torch.nn import functional as F\nimport pandas as pd\nfrom .edit_config import attr_dict\nimport os\n\ndef conv_warper(layer, input, style, noise):\n    # the conv should change\n    conv = layer.conv\n    batch, in_channel, height, width = input.shape\n\n    style = style.view(batch, 1, in_channel, 1, 1)\n    weight = conv.scale * conv.weight * style\n\n    if conv.demodulate:\n        demod = torch.rsqrt(weight.pow(2).sum([2, 3, 4]) + 1e-8)\n        weight = weight * demod.view(batch, conv.out_channel, 1, 1, 1)\n\n    weight = weight.view(\n        batch * conv.out_channel, in_channel, conv.kernel_size, conv.kernel_size\n    )\n\n    if conv.upsample:\n        input = input.view(1, batch * in_channel, height, width)\n        weight = weight.view(\n            batch, conv.out_channel, in_channel, conv.kernel_size, conv.kernel_size\n        )\n        weight = weight.transpose(1, 2).reshape(\n            batch * in_channel, conv.out_channel, conv.kernel_size, conv.kernel_size\n        )\n        out = F.conv_transpose2d(input, weight, padding=0, stride=2, groups=batch)\n        _, _, height, width = out.shape\n        out = out.view(batch, conv.out_channel, height, width)\n        out = conv.blur(out)\n\n    elif conv.downsample:\n        input = conv.blur(input)\n        _, _, height, width = input.shape\n        input = input.view(1, batch * in_channel, height, width)\n        out = F.conv2d(input, weight, padding=0, stride=2, groups=batch)\n        _, _, height, width = out.shape\n        out = out.view(batch, conv.out_channel, height, width)\n\n    else:\n        input = input.view(1, batch * in_channel, height, width)\n        out = F.conv2d(input, weight, padding=conv.padding, groups=batch)\n        _, _, height, width = out.shape\n        out = out.view(batch, conv.out_channel, height, width)\n        \n    out = layer.noise(out, noise=noise)\n    out = layer.activate(out)\n    \n    return out\n\ndef decoder(G, style_space, latent, noise):\n    # an decoder warper for G\n    out = G.input(latent)\n    out = conv_warper(G.conv1, out, style_space[0], noise[0])\n    skip = G.to_rgb1(out, latent[:, 1])\n\n    i = 1\n    for conv1, conv2, noise1, noise2, to_rgb in zip(\n        G.convs[::2], G.convs[1::2], noise[1::2], noise[2::2], G.to_rgbs\n    ):\n        out = conv_warper(conv1, out, style_space[i], noise=noise1)\n        out = conv_warper(conv2, out, style_space[i+1], noise=noise2)\n        skip = to_rgb(out, latent[:, i + 2], skip)\n        i += 2\n    image = skip\n\n    return image\n\ndef encoder_ifg(G, noise, attr_name, truncation=1, truncation_latent=None, \n                  latent_dir='latent_direction/ss/',\n                  step=0, total=0, real=False):\n    if not real:\n        styles = [noise]\n        styles = [G.style(s) for s in styles]\n    style_space = []\n    \n    if truncation<1:\n        if not real: \n            style_t = []\n            for style in styles:\n                style_t.append(truncation_latent + truncation * (style - truncation_latent))\n            styles = style_t\n        else: # styles are latent (tensor: 1,18,512), for real PTI output\n            truncation_latent = truncation_latent.repeat(18,1).unsqueeze(0) # (1,512) --> (1,18,512)\n            styles = torch.add(truncation_latent,torch.mul(torch.sub(noise,truncation_latent),truncation))\n\n\n    noise = [getattr(G.noises, 'noise_{}'.format(i)) for i in range(G.num_layers)]\n    if not real:\n        inject_index = G.n_latent\n        latent = styles[0].unsqueeze(1).repeat(1, inject_index, 1)\n    else: latent=styles\n\n    style_space.append(G.conv1.conv.modulation(latent[:, 0]))\n    i = 1\n    for conv1, conv2, noise1, noise2, to_rgb in zip(\n        G.convs[::2], G.convs[1::2], noise[1::2], noise[2::2], G.to_rgbs\n    ):\n        style_space.append(conv1.conv.modulation(latent[:, i]))\n        style_space.append(conv2.conv.modulation(latent[:, i+1]))\n        i += 2\n\n    # get layer, strength by dict\n    strength = attr_dict['interface_gan'][attr_name][0]\n\n    if step != 0 and total != 0:\n        strength = step / total * strength\n    for i in range(15):\n        style_vect = load_pkl(os.path.join(latent_dir, '{}/style_vect_mean_{}.pkl'.format(attr_name, i)))\n        style_vect = torch.from_numpy(style_vect).to(latent.device).float()\n        style_space[i] += style_vect * strength\n        \n    return style_space, latent, noise\n\ndef encoder_ss(G, noise, attr_name, truncation=1, truncation_latent=None, \n               statics_dir=\"latent_direction/ss_statics\",\n               latent_dir=\"latent_direction/ss/\",\n               step=0, total=0,real=False):\n    if not real:\n        styles = [noise]\n        styles = [G.style(s) for s in styles]\n    style_space = []\n\n    if truncation<1:\n        if not real:\n            style_t = []\n            for style in styles:\n                style_t.append(\n                    truncation_latent + truncation * (style - truncation_latent)\n                )\n            styles = style_t\n        else: # styles are latent (tensor: 1,18,512), for real PTI output\n            truncation_latent = truncation_latent.repeat(18,1).unsqueeze(0) # (1,512) --> (1,18,512)\n            styles = torch.add(truncation_latent,torch.mul(torch.sub(noise,truncation_latent),truncation))\n\n    noise = [getattr(G.noises, 'noise_{}'.format(i)) for i in range(G.num_layers)]\n    \n    if not real:\n        inject_index = G.n_latent\n        latent = styles[0].unsqueeze(1).repeat(1, inject_index, 1)\n    else: latent = styles\n\n    style_space.append(G.conv1.conv.modulation(latent[:, 0]))\n    i = 1\n    for conv1, conv2, noise1, noise2, to_rgb in zip(\n        G.convs[::2], G.convs[1::2], noise[1::2], noise[2::2], G.to_rgbs\n    ):\n        style_space.append(conv1.conv.modulation(latent[:, i]))\n        style_space.append(conv2.conv.modulation(latent[:, i+1]))\n        i += 2\n    # get threshold, layer, strength by dict\n    layer, strength, threshold = attr_dict['stylespace'][attr_name] \n\n    statis_dir = os.path.join(statics_dir, \"{}_statis/{}\".format(attr_name, layer))\n    statis_csv_path = os.path.join(statis_dir, \"statis.csv\")\n    statis_df = pd.read_csv(statis_csv_path)\n    statis_df = statis_df.sort_values(by='channel', ascending=True)\n    ch_mask = statis_df['strength'].values\n    ch_mask = torch.from_numpy(ch_mask).to(latent.device).float()\n    ch_mask = (ch_mask.abs()>threshold).float()\n    style_vect = load_pkl(os.path.join(latent_dir, '{}/style_vect_mean_{}.pkl'.format(attr_name, layer)))\n    style_vect = torch.from_numpy(style_vect).to(latent.device).float()\n\n    style_vect = style_vect * ch_mask\n\n    if step != 0 and total != 0:\n        strength = step / total * strength\n\n    style_space[layer] += style_vect * strength\n        \n    return style_space, latent, noise\n\ndef encoder_sefa(G, noise, attr_name, truncation=1, truncation_latent=None, \n                  latent_dir='latent_direction/sefa/',\n                  step=0, total=0, real=False):\n    if not real: \n        styles = [noise]\n        styles = [G.style(s) for s in styles]\n    \n    if truncation<1:\n        if not real:\n            style_t = []\n            for style in styles:\n                style_t.append(\n                    truncation_latent + truncation * (style - truncation_latent)\n                )\n            styles = style_t\n        else:\n            truncation_latent = truncation_latent.repeat(18,1).unsqueeze(0) # (1,512) --> (1,18,512)\n            styles = torch.add(truncation_latent,torch.mul(torch.sub(noise,truncation_latent),truncation))\n\n\n    noise = [getattr(G.noises, 'noise_{}'.format(i)) for i in range(G.num_layers)]\n    if not real:\n        inject_index = G.n_latent\n        latent = styles[0].unsqueeze(1).repeat(1, inject_index, 1)\n    else: latent = styles\n    \n    layer, strength = attr_dict['sefa'][attr_name] \n\n    sefa_vect = torch.load(os.path.join(latent_dir, '{}.pt'.format(attr_name))).to(latent.device).float()\n    if step != 0 and total != 0:\n        strength = step / total * strength\n    for l in layer:\n        latent[:, l, :] += (sefa_vect * strength * 2)\n        \n\n    return latent, noise\n", "file_name": "263731.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "from enum import Enum\nimport math\nimport numpy as np\nimport torch\nfrom torch import nn\nfrom torch.nn import Conv2d, BatchNorm2d, PReLU, Sequential, Module\n\nfrom pti.pti_models.e4e.encoders.helpers import get_blocks, bottleneck_IR, bottleneck_IR_SE, _upsample_add\nfrom pti.pti_models.e4e.stylegan2.model import EqualLinear\n\n\nclass ProgressiveStage(Enum):\n    WTraining = 0\n    Delta1Training = 1\n    Delta2Training = 2\n    Delta3Training = 3\n    Delta4Training = 4\n    Delta5Training = 5\n    Delta6Training = 6\n    Delta7Training = 7\n    Delta8Training = 8\n    Delta9Training = 9\n    Delta10Training = 10\n    Delta11Training = 11\n    Delta12Training = 12\n    Delta13Training = 13\n    Delta14Training = 14\n    Delta15Training = 15\n    Delta16Training = 16\n    Delta17Training = 17\n    Inference = 18\n\n\nclass GradualStyleBlock(Module):\n    def __init__(self, in_c, out_c, spatial):\n        super(GradualStyleBlock, self).__init__()\n        self.out_c = out_c\n        self.spatial = spatial\n        num_pools = int(np.log2(spatial))\n        modules = []\n        modules += [Conv2d(in_c, out_c, kernel_size=3, stride=2, padding=1),\n                    nn.LeakyReLU()]\n        for i in range(num_pools - 1):\n            modules += [\n                Conv2d(out_c, out_c, kernel_size=3, stride=2, padding=1),\n                nn.LeakyReLU()\n            ]\n        self.convs = nn.Sequential(*modules)\n        self.linear = EqualLinear(out_c, out_c, lr_mul=1)\n\n    def forward(self, x):\n        x = self.convs(x)\n        x = x.view(-1, self.out_c)\n        x = self.linear(x)\n        return x\n\n\nclass GradualStyleEncoder(Module):\n    def __init__(self, num_layers, mode='ir', opts=None):\n        super(GradualStyleEncoder, self).__init__()\n        assert num_layers in [50, 100, 152], 'num_layers should be 50,100, or 152'\n        assert mode in ['ir', 'ir_se'], 'mode should be ir or ir_se'\n        blocks = get_blocks(num_layers)\n        if mode == 'ir':\n            unit_module = bottleneck_IR\n        elif mode == 'ir_se':\n            unit_module = bottleneck_IR_SE\n        self.input_layer = Sequential(Conv2d(3, 64, (3, 3), 1, 1, bias=False),\n                                      BatchNorm2d(64),\n                                      PReLU(64))\n        modules = []\n        for block in blocks:\n            for bottleneck in block:\n                modules.append(unit_module(bottleneck.in_channel,\n                                           bottleneck.depth,\n                                           bottleneck.stride))\n        self.body = Sequential(*modules)\n\n        self.styles = nn.ModuleList()\n        log_size = int(math.log(opts.stylegan_size, 2))\n        self.style_count = 2 * log_size - 2\n        self.coarse_ind = 3\n        self.middle_ind = 7\n        for i in range(self.style_count):\n            if i < self.coarse_ind:\n                style = GradualStyleBlock(512, 512, 16)\n            elif i < self.middle_ind:\n                style = GradualStyleBlock(512, 512, 32)\n            else:\n                style = GradualStyleBlock(512, 512, 64)\n            self.styles.append(style)\n        self.latlayer1 = nn.Conv2d(256, 512, kernel_size=1, stride=1, padding=0)\n        self.latlayer2 = nn.Conv2d(128, 512, kernel_size=1, stride=1, padding=0)\n\n    def forward(self, x):\n        x = self.input_layer(x)\n\n        latents = []\n        modulelist = list(self.body._modules.values())\n        for i, l in enumerate(modulelist):\n            x = l(x)\n            if i == 6:\n                c1 = x\n            elif i == 20:\n                c2 = x\n            elif i == 23:\n                c3 = x\n\n        for j in range(self.coarse_ind):\n            latents.append(self.styles[j](c3))\n\n        p2 = _upsample_add(c3, self.latlayer1(c2))\n        for j in range(self.coarse_ind, self.middle_ind):\n            latents.append(self.styles[j](p2))\n\n        p1 = _upsample_add(p2, self.latlayer2(c1))\n        for j in range(self.middle_ind, self.style_count):\n            latents.append(self.styles[j](p1))\n\n        out = torch.stack(latents, dim=1)\n        return out\n\n\nclass Encoder4Editing(Module):\n    def __init__(self, num_layers, mode='ir', opts=None):\n        super(Encoder4Editing, self).__init__()\n        assert num_layers in [50, 100, 152], 'num_layers should be 50,100, or 152'\n        assert mode in ['ir', 'ir_se'], 'mode should be ir or ir_se'\n        blocks = get_blocks(num_layers)\n        if mode == 'ir':\n            unit_module = bottleneck_IR\n        elif mode == 'ir_se':\n            unit_module = bottleneck_IR_SE\n        self.input_layer = Sequential(Conv2d(3, 64, (3, 3), 1, 1, bias=False),\n                                      BatchNorm2d(64),\n                                      PReLU(64))\n        modules = []\n        for block in blocks:\n            for bottleneck in block:\n                modules.append(unit_module(bottleneck.in_channel,\n                                           bottleneck.depth,\n                                           bottleneck.stride))\n        self.body = Sequential(*modules)\n\n        self.styles = nn.ModuleList()\n        log_size = int(math.log(opts.stylegan_size, 2))\n        self.style_count = 2 * log_size - 2\n        self.coarse_ind = 3\n        self.middle_ind = 7\n\n        for i in range(self.style_count):\n            if i < self.coarse_ind:\n                style = GradualStyleBlock(512, 512, 16)\n            elif i < self.middle_ind:\n                style = GradualStyleBlock(512, 512, 32)\n            else:\n                style = GradualStyleBlock(512, 512, 64)\n            self.styles.append(style)\n\n        self.latlayer1 = nn.Conv2d(256, 512, kernel_size=1, stride=1, padding=0)\n        self.latlayer2 = nn.Conv2d(128, 512, kernel_size=1, stride=1, padding=0)\n\n        self.progressive_stage = ProgressiveStage.Inference\n\n    def get_deltas_starting_dimensions(self):\n        ''' Get a list of the initial dimension of every delta from which it is applied '''\n        return list(range(self.style_count))  # Each dimension has a delta applied to it\n\n    def set_progressive_stage(self, new_stage: ProgressiveStage):\n        self.progressive_stage = new_stage\n        print('Changed progressive stage to: ', new_stage)\n\n    def forward(self, x):\n        x = self.input_layer(x)\n\n        modulelist = list(self.body._modules.values())\n        for i, l in enumerate(modulelist):\n            x = l(x)\n            if i == 6:\n                c1 = x\n            elif i == 20:\n                c2 = x\n            elif i == 23:\n                c3 = x\n\n        # Infer main W and duplicate it\n        w0 = self.styles[0](c3)\n        w = w0.repeat(self.style_count, 1, 1).permute(1, 0, 2)\n        stage = self.progressive_stage.value\n        features = c3\n        for i in range(1, min(stage + 1, self.style_count)):  # Infer additional deltas\n            if i == self.coarse_ind:\n                p2 = _upsample_add(c3, self.latlayer1(c2))  # FPN's middle features\n                features = p2\n            elif i == self.middle_ind:\n                p1 = _upsample_add(p2, self.latlayer2(c1))  # FPN's fine features\n                features = p1\n            delta_i = self.styles[i](features)\n            w[:, i] += delta_i\n        return w\n", "file_name": "076051.py", "cwe": ["Unknown"]}
{"source": "import json\nimport random\nimport subprocess\nimport threading\nimport time\nfrom typing import NamedTuple\n\nimport libtmux\n\n\nclass InstructionSpec(NamedTuple):\n    instruction: str\n    time_from: float\n    time_to: float\n\n\nclass CliDirector:\n    def __init__(self):\n        self.record_start = None\n        self.pause_between_keys = 0.2\n        self.instructions: list[InstructionSpec] = []\n\n    def start(self, filename: str, width: int = 0, height: int = 0) -> libtmux.Session:\n        self.start_session(width, height)\n        self.start_recording(filename)\n        return self.tmux_session\n\n    def start_session(self, width: int = 0, height: int = 0) -> libtmux.Session:\n        self.tmux_server = libtmux.Server()\n        self.tmux_session = self.tmux_server.new_session(\n            session_name=\"asciinema_recorder\", kill_session=True\n        )\n        self.tmux_pane = self.tmux_session.attached_window.attached_pane\n        self.tmux_version = self.tmux_pane.display_message(\"#{version}\", True)\n        if width and height:\n            self.resize_window(width, height)\n        self.pause(3)\n        return self.tmux_session\n\n    def start_recording(self, filename: str) -> None:\n        self.asciinema_proc = subprocess.Popen(\n            [\n                \"asciinema\",\n                \"rec\",\n                \"-y\",\n                \"--overwrite\",\n                \"-c\",\n                \"tmux attach -t asciinema_recorder\",\n                filename,\n            ]\n        )\n        self.pause(1.5)\n        self.record_start = time.time()\n\n    def resize_window(self, width: int, height: int) -> None:\n        subprocess.Popen(\n            [\"resize\", \"-s\", str(height), str(width)],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n\n    def end(self) -> None:\n        self.end_recording()\n        self.end_session()\n\n    def end_recording(self) -> None:\n        self.asciinema_proc.terminate()\n        self.asciinema_proc.wait(timeout=5)\n        self.record_start = None\n        self.instructions = []\n\n    def end_session(self) -> None:\n        self.tmux_session.kill_session()\n\n    def press_key(\n        self, keys: str, count=1, pause: float | None = None, target=None\n    ) -> None:\n        if pause is None:\n            pause = self.pause_between_keys\n        if target is None:\n            target = self.tmux_pane\n        for i in range(count):\n            if keys == \" \":\n                keys = \"Space\"\n            target.send_keys(cmd=keys, enter=False, suppress_history=False)\n\n            # inspired by https://github.com/dmotz/TuringType\n            real_pause = random.uniform(0, pause) + 0.4 * pause\n            if keys == \"Space\":\n                real_pause += 1.5 * pause\n            elif keys == \".\":\n                real_pause += pause\n            elif random.random() > 0.75:\n                real_pause += pause\n            elif random.random() > 0.95:\n                real_pause += 2 * pause\n            self.pause(real_pause)\n\n    def type(self, keys: str, pause: float | None = None, target=None) -> None:\n        if pause is None:\n            pause = self.pause_between_keys\n        if target is None:\n            target = self.tmux_pane\n        target.select_pane()\n        for key in keys:\n            self.press_key(key, pause=pause, target=target)\n\n    def exec(self, keys: str, target=None) -> None:\n        if target is None:\n            target = self.tmux_pane\n        self.type(keys, target=target)\n        self.pause(1.25)\n        self.press_key(\"Enter\", target=target)\n        self.pause(0.5)\n\n    def focus_pane(self, pane: libtmux.Pane, set_active_pane: bool = True) -> None:\n        pane.select_pane()\n        if set_active_pane:\n            self.tmux_pane = pane\n\n    def pause(self, seconds: float) -> None:\n        time.sleep(seconds)\n\n    def run_external(self, command: str) -> None:\n        subprocess.run(command, shell=True)\n\n    def message(\n        self,\n        msg: str,\n        duration: int | None = None,\n        add_instruction: bool = True,\n        instruction_html: str = \"\",\n    ) -> None:\n        if duration is None:\n            duration = len(msg) * 0.08  # seconds\n        self.tmux_session.set_option(\n            \"display-time\", int(duration * 1000)\n        )  # milliseconds\n        self.tmux_pane.display_message(\" \" + msg)\n\n        if add_instruction or instruction_html:\n            if not instruction_html:\n                instruction_html = msg\n            self.instruction(instruction=instruction_html, duration=duration)\n        self.pause(duration + 0.5)\n\n    def popup(self, content: str, duration: int = 4) -> None:\n        # todo: check if installed tmux version supports display-popup\n\n        # tmux's display-popup is blocking, so we close it in a separate thread\n        t = threading.Thread(target=self.close_popup, args=[duration])\n        t.start()\n\n        lines = content.splitlines()\n        self.tmux_pane.cmd(\"display-popup\", \"\", *lines)\n        t.join()\n\n    def close_popup(self, duration: float = 0) -> None:\n        self.pause(duration)\n        self.tmux_pane.cmd(\"display-popup\", \"-C\")\n\n    def instruction(\n        self, instruction: str, duration: float = 3, time_from: float | None = None\n    ) -> None:\n        if time_from is None:\n            time_from = self.current_time\n\n        self.instructions.append(\n            InstructionSpec(\n                instruction=str(len(self.instructions) + 1) + \". \" + instruction,\n                time_from=round(time_from, 1),\n                time_to=round(time_from + duration, 1),\n            )\n        )\n\n    def save_instructions(self, output_path: str) -> None:\n        instr_as_dicts = []\n        for instr in self.instructions:\n            instr_as_dicts.append(instr._asdict())\n        with open(output_path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(instr_as_dicts, f, ensure_ascii=False, indent=4)\n\n    @property\n    def current_time(self) -> float:\n        now = time.time()\n        return round(now - self.record_start, 1)\n\n    @property\n    def current_pane(self) -> libtmux.Pane:\n        return self.tmux_pane\n", "file_name": "245327.py", "cwe": ["CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"]}
{"source": "\"\"\"\nThis module manages and invokes typed commands.\n\"\"\"\n\nimport functools\nimport inspect\nimport logging\nimport sys\nimport textwrap\nimport types\nfrom collections.abc import Callable\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom typing import Any\nfrom typing import NamedTuple\n\nimport pyparsing\n\nimport mitmproxy.types\nfrom mitmproxy import command_lexer\nfrom mitmproxy import exceptions\nfrom mitmproxy.command_lexer import unquote\n\n\ndef verify_arg_signature(f: Callable, args: Iterable[Any], kwargs: dict) -> None:\n    sig = inspect.signature(f, eval_str=True)\n    try:\n        sig.bind(*args, **kwargs)\n    except TypeError as v:\n        raise exceptions.CommandError(\"command argument mismatch: %s\" % v.args[0])\n\n\ndef typename(t: type) -> str:\n    \"\"\"\n    Translates a type to an explanatory string.\n    \"\"\"\n    if t == inspect._empty:  # type: ignore\n        raise exceptions.CommandError(\"missing type annotation\")\n    to = mitmproxy.types.CommandTypes.get(t, None)\n    if not to:\n        raise exceptions.CommandError(\n            \"unsupported type: %s\" % getattr(t, \"__name__\", t)\n        )\n    return to.display\n\n\ndef _empty_as_none(x: Any) -> Any:\n    if x == inspect.Signature.empty:\n        return None\n    return x\n\n\nclass CommandParameter(NamedTuple):\n    name: str\n    type: type\n    kind: inspect._ParameterKind = inspect.Parameter.POSITIONAL_OR_KEYWORD\n\n    def __str__(self):\n        if self.kind is inspect.Parameter.VAR_POSITIONAL:\n            return f\"*{self.name}\"\n        else:\n            return self.name\n\n\nclass Command:\n    name: str\n    manager: \"CommandManager\"\n    signature: inspect.Signature\n    help: str | None\n\n    def __init__(self, manager: \"CommandManager\", name: str, func: Callable) -> None:\n        self.name = name\n        self.manager = manager\n        self.func = func\n        self.signature = inspect.signature(self.func, eval_str=True)\n\n        if func.__doc__:\n            txt = func.__doc__.strip()\n            self.help = \"\\n\".join(textwrap.wrap(txt))\n        else:\n            self.help = None\n\n        # This fails with a CommandException if types are invalid\n        for name, parameter in self.signature.parameters.items():\n            t = parameter.annotation\n            if not mitmproxy.types.CommandTypes.get(parameter.annotation, None):\n                raise exceptions.CommandError(\n                    f\"Argument {name} has an unknown type {t} in {func}.\"\n                )\n        if self.return_type and not mitmproxy.types.CommandTypes.get(\n            self.return_type, None\n        ):\n            raise exceptions.CommandError(\n                f\"Return type has an unknown type ({self.return_type}) in {func}.\"\n            )\n\n    @property\n    def return_type(self) -> type | None:\n        return _empty_as_none(self.signature.return_annotation)\n\n    @property\n    def parameters(self) -> list[CommandParameter]:\n        \"\"\"Returns a list of CommandParameters.\"\"\"\n        ret = []\n        for name, param in self.signature.parameters.items():\n            ret.append(CommandParameter(name, param.annotation, param.kind))\n        return ret\n\n    def signature_help(self) -> str:\n        params = \" \".join(str(param) for param in self.parameters)\n        if self.return_type:\n            ret = f\" -> {typename(self.return_type)}\"\n        else:\n            ret = \"\"\n        return f\"{self.name} {params}{ret}\"\n\n    def prepare_args(self, args: Sequence[str]) -> inspect.BoundArguments:\n        try:\n            bound_arguments = self.signature.bind(*args)\n        except TypeError:\n            expected = f\"Expected: {str(self.signature.parameters)}\"\n            received = f\"Received: {str(args)}\"\n            raise exceptions.CommandError(\n                f\"Command argument mismatch: \\n    {expected}\\n    {received}\"\n            )\n\n        for name, value in bound_arguments.arguments.items():\n            param = self.signature.parameters[name]\n            convert_to = param.annotation\n            if param.kind == param.VAR_POSITIONAL:\n                bound_arguments.arguments[name] = tuple(\n                    parsearg(self.manager, x, convert_to) for x in value\n                )\n            else:\n                bound_arguments.arguments[name] = parsearg(\n                    self.manager, value, convert_to\n                )\n\n        bound_arguments.apply_defaults()\n\n        return bound_arguments\n\n    def call(self, args: Sequence[str]) -> Any:\n        \"\"\"\n        Call the command with a list of arguments. At this point, all\n        arguments are strings.\n        \"\"\"\n        bound_args = self.prepare_args(args)\n        ret = self.func(*bound_args.args, **bound_args.kwargs)\n        if ret is None and self.return_type is None:\n            return\n        typ = mitmproxy.types.CommandTypes.get(self.return_type)\n        assert typ\n        if not typ.is_valid(self.manager, typ, ret):\n            raise exceptions.CommandError(\n                f\"{self.name} returned unexpected data - expected {typ.display}\"\n            )\n        return ret\n\n\nclass ParseResult(NamedTuple):\n    value: str\n    type: type\n    valid: bool\n\n\nclass CommandManager:\n    commands: dict[str, Command]\n\n    def __init__(self, master):\n        self.master = master\n        self.commands = {}\n\n    def collect_commands(self, addon):\n        for i in dir(addon):\n            if not i.startswith(\"__\"):\n                o = getattr(addon, i)\n                try:\n                    # hasattr is not enough, see https://github.com/mitmproxy/mitmproxy/issues/3794\n                    is_command = isinstance(getattr(o, \"command_name\", None), str)\n                except Exception:\n                    pass  # getattr may raise if o implements __getattr__.\n                else:\n                    if is_command:\n                        try:\n                            self.add(o.command_name, o)\n                        except exceptions.CommandError as e:\n                            logging.warning(\n                                f\"Could not load command {o.command_name}: {e}\"\n                            )\n\n    def add(self, path: str, func: Callable):\n        self.commands[path] = Command(self, path, func)\n\n    @functools.lru_cache(maxsize=128)\n    def parse_partial(\n        self, cmdstr: str\n    ) -> tuple[Sequence[ParseResult], Sequence[CommandParameter]]:\n        \"\"\"\n        Parse a possibly partial command. Return a sequence of ParseResults and a sequence of remainder type help items.\n        \"\"\"\n\n        parts: pyparsing.ParseResults = command_lexer.expr.parseString(\n            cmdstr, parseAll=True\n        )\n\n        parsed: list[ParseResult] = []\n        next_params: list[CommandParameter] = [\n            CommandParameter(\"\", mitmproxy.types.Cmd),\n            CommandParameter(\"\", mitmproxy.types.CmdArgs),\n        ]\n        expected: CommandParameter | None = None\n        for part in parts:\n            if part.isspace():\n                parsed.append(\n                    ParseResult(\n                        value=part,\n                        type=mitmproxy.types.Space,\n                        valid=True,\n                    )\n                )\n                continue\n\n            if expected and expected.kind is inspect.Parameter.VAR_POSITIONAL:\n                assert not next_params\n            elif next_params:\n                expected = next_params.pop(0)\n            else:\n                expected = CommandParameter(\"\", mitmproxy.types.Unknown)\n\n            arg_is_known_command = (\n                expected.type == mitmproxy.types.Cmd and part in self.commands\n            )\n            arg_is_unknown_command = (\n                expected.type == mitmproxy.types.Cmd and part not in self.commands\n            )\n            command_args_following = (\n                next_params and next_params[0].type == mitmproxy.types.CmdArgs\n            )\n            if arg_is_known_command and command_args_following:\n                next_params = self.commands[part].parameters + next_params[1:]\n            if arg_is_unknown_command and command_args_following:\n                next_params.pop(0)\n\n            to = mitmproxy.types.CommandTypes.get(expected.type, None)\n            valid = False\n            if to:\n                try:\n                    to.parse(self, expected.type, part)\n                except ValueError:\n                    valid = False\n                else:\n                    valid = True\n\n            parsed.append(\n                ParseResult(\n                    value=part,\n                    type=expected.type,\n                    valid=valid,\n                )\n            )\n\n        return parsed, next_params\n\n    def call(self, command_name: str, *args: Any) -> Any:\n        \"\"\"\n        Call a command with native arguments. May raise CommandError.\n        \"\"\"\n        if command_name not in self.commands:\n            raise exceptions.CommandError(\"Unknown command: %s\" % command_name)\n        return self.commands[command_name].func(*args)\n\n    def call_strings(self, command_name: str, args: Sequence[str]) -> Any:\n        \"\"\"\n        Call a command using a list of string arguments. May raise CommandError.\n        \"\"\"\n        if command_name not in self.commands:\n            raise exceptions.CommandError(\"Unknown command: %s\" % command_name)\n\n        return self.commands[command_name].call(args)\n\n    def execute(self, cmdstr: str) -> Any:\n        \"\"\"\n        Execute a command string. May raise CommandError.\n        \"\"\"\n        parts, _ = self.parse_partial(cmdstr)\n        if not parts:\n            raise exceptions.CommandError(f\"Invalid command: {cmdstr!r}\")\n        command_name, *args = (\n            unquote(part.value) for part in parts if part.type != mitmproxy.types.Space\n        )\n        return self.call_strings(command_name, args)\n\n    def dump(self, out=sys.stdout) -> None:\n        cmds = list(self.commands.values())\n        cmds.sort(key=lambda x: x.signature_help())\n        for c in cmds:\n            for hl in (c.help or \"\").splitlines():\n                print(\"# \" + hl, file=out)\n            print(c.signature_help(), file=out)\n            print(file=out)\n\n\ndef parsearg(manager: CommandManager, spec: str, argtype: type) -> Any:\n    \"\"\"\n    Convert a string to a argument to the appropriate type.\n    \"\"\"\n    t = mitmproxy.types.CommandTypes.get(argtype, None)\n    if not t:\n        raise exceptions.CommandError(f\"Unsupported argument type: {argtype}\")\n    try:\n        return t.parse(manager, argtype, spec)\n    except ValueError as e:\n        raise exceptions.CommandError(str(e)) from e\n\n\ndef command(name: str | None = None):\n    def decorator(function):\n        @functools.wraps(function)\n        def wrapper(*args, **kwargs):\n            verify_arg_signature(function, args, kwargs)\n            return function(*args, **kwargs)\n\n        wrapper.__dict__[\"command_name\"] = name or function.__name__.replace(\"_\", \".\")\n        return wrapper\n\n    return decorator\n\n\ndef argument(name, type):\n    \"\"\"\n    Set the type of a command argument at runtime. This is useful for more\n    specific types such as mitmproxy.types.Choice, which we cannot annotate\n    directly as mypy does not like that.\n    \"\"\"\n\n    def decorator(f: types.FunctionType) -> types.FunctionType:\n        assert name in f.__annotations__\n        f.__annotations__[name] = type\n        return f\n\n    return decorator\n", "file_name": "527709.py", "cwe": ["CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"]}
{"source": "#!/usr/bin/env -S python3 -u\nimport datetime\nimport http.client\nimport json\nimport os\nimport re\nimport subprocess\nimport sys\nimport time\nfrom pathlib import Path\n\n# Security: No third-party dependencies here!\n\nroot = Path(__file__).absolute().parent.parent\n\n\ndef get(url: str) -> http.client.HTTPResponse:\n    assert url.startswith(\"https://\")\n    host, path = re.split(r\"(?=/)\", url.removeprefix(\"https://\"), maxsplit=1)\n    conn = http.client.HTTPSConnection(host)\n    conn.request(\"GET\", path, headers={\"User-Agent\": \"mitmproxy/release-bot\"})\n    resp = conn.getresponse()\n    print(f\"HTTP {resp.status} {resp.reason}\")\n    return resp\n\n\ndef get_json(url: str) -> dict:\n    resp = get(url)\n    body = resp.read()\n    try:\n        return json.loads(body)\n    except Exception as e:\n        raise RuntimeError(f\"{resp.status=} {body=}\") from e\n\n\nif __name__ == \"__main__\":\n    version = sys.argv[1]\n    assert re.match(r\"^\\d+\\.\\d+\\.\\d+$\", version)\n    major_version = int(version.split(\".\")[0])\n\n    skip_branch_status_check = sys.argv[2] == \"true\"\n\n    # changing this is useful for testing on a fork.\n    repo = os.environ.get(\"GITHUB_REPOSITORY\", \"mitmproxy/mitmproxy\")\n    print(f\"{version=} {skip_branch_status_check=} {repo=}\")\n\n    branch = subprocess.run(\n        [\"git\", \"branch\", \"--show-current\"],\n        cwd=root,\n        check=True,\n        capture_output=True,\n        text=True,\n    ).stdout.strip()\n\n    print(\"\u27a1\ufe0f Working dir clean?\")\n    assert not subprocess.run([\"git\", \"status\", \"--porcelain\"]).stdout\n\n    if skip_branch_status_check:\n        print(f\"\u26a0\ufe0f Skipping status check for {branch}.\")\n    else:\n        print(f\"\u27a1\ufe0f CI is passing for {branch}?\")\n        assert (\n            get_json(f\"https://api.github.com/repos/{repo}/commits/{branch}/status\")[\n                \"state\"\n            ]\n            == \"success\"\n        )\n\n    print(\"\u27a1\ufe0f Updating CHANGELOG.md...\")\n    changelog = root / \"CHANGELOG.md\"\n    date = datetime.date.today().strftime(\"%d %B %Y\")\n    title = f\"## {date}: mitmproxy {version}\"\n    cl = changelog.read_text(\"utf8\")\n    assert title not in cl\n    cl, ok = re.subn(r\"(?<=## Unreleased: mitmproxy next)\", f\"\\n\\n\\n{title}\", cl)\n    assert ok == 1\n    changelog.write_text(cl, \"utf8\")\n\n    print(\"\u27a1\ufe0f Updating web assets...\")\n    subprocess.run([\"npm\", \"ci\"], cwd=root / \"web\", check=True, capture_output=True)\n    subprocess.run(\n        [\"npm\", \"start\", \"prod\"], cwd=root / \"web\", check=True, capture_output=True\n    )\n\n    print(\"\u27a1\ufe0f Updating version...\")\n    version_py = root / \"mitmproxy\" / \"version.py\"\n    ver = version_py.read_text(\"utf8\")\n    ver, ok = re.subn(r'(?<=VERSION = \")[^\"]+', version, ver)\n    assert ok == 1\n    version_py.write_text(ver, \"utf8\")\n\n    print(\"\u27a1\ufe0f Do release commit...\")\n    subprocess.run(\n        [\"git\", \"config\", \"user.email\", \"noreply@mitmproxy.org\"], cwd=root, check=True\n    )\n    subprocess.run(\n        [\"git\", \"config\", \"user.name\", \"mitmproxy release bot\"], cwd=root, check=True\n    )\n    subprocess.run(\n        [\"git\", \"commit\", \"-a\", \"-m\", f\"mitmproxy {version}\"], cwd=root, check=True\n    )\n    tag_name = f\"v{version}\"\n    subprocess.run([\"git\", \"tag\", tag_name], cwd=root, check=True)\n    release_sha = subprocess.run(\n        [\"git\", \"rev-parse\", \"HEAD\"],\n        cwd=root,\n        check=True,\n        capture_output=True,\n        text=True,\n    ).stdout.strip()\n\n    if branch == \"main\":\n        print(\"\u27a1\ufe0f Bump version...\")\n        next_dev_version = f\"{major_version + 1}.0.0.dev\"\n        ver, ok = re.subn(r'(?<=VERSION = \")[^\"]+', next_dev_version, ver)\n        assert ok == 1\n        version_py.write_text(ver, \"utf8\")\n\n        print(\"\u27a1\ufe0f Reopen main for development...\")\n        subprocess.run(\n            [\"git\", \"commit\", \"-a\", \"-m\", f\"reopen main for development\"],\n            cwd=root,\n            check=True,\n        )\n\n    print(\"\u27a1\ufe0f Pushing...\")\n    subprocess.run(\n        [\"git\", \"push\", \"--atomic\", \"origin\", branch, tag_name], cwd=root, check=True\n    )\n\n    print(\"\u27a1\ufe0f Creating release on GitHub...\")\n    subprocess.run(\n        [\n            \"gh\",\n            \"release\",\n            \"create\",\n            tag_name,\n            \"--title\",\n            f\"mitmproxy {version}\",\n            \"--notes-file\",\n            \"release/github-release-notes.txt\",\n        ],\n        cwd=root,\n        check=True,\n    )\n\n    print(\"\u27a1\ufe0f Dispatching release workflow...\")\n    subprocess.run(\n        [\"gh\", \"workflow\", \"run\", \"main.yml\", \"--ref\", tag_name], cwd=root, check=True\n    )\n\n    print(\"\")\n    print(\"\u2705 CI is running now.\")\n\n    while True:\n        print(\"\u231b Waiting for CI...\")\n        workflows = get_json(\n            f\"https://api.github.com/repos/{repo}/actions/runs?head_sha={release_sha}\"\n        )[\"workflow_runs\"]\n\n        all_done = True\n        if not workflows:\n            all_done = False  # we expect to have at least one workflow.\n        for workflow in workflows:\n            if workflow[\"status\"] != \"completed\":\n                all_done = False\n            if workflow[\"status\"] == \"waiting\":\n                print(f\"\u26a0\ufe0f CI is waiting for approval: {workflow['html_url']}\")\n\n        if all_done:\n            for workflow in workflows:\n                if workflow[\"conclusion\"] != \"success\":\n                    print(f\"\u26a0\ufe0f {workflow['display_title']} workflow run failed.\")\n            break\n        else:\n            time.sleep(30)  # relatively strict rate limits here.\n\n    print(\"\u27a1\ufe0f Checking GitHub Releases...\")\n    resp = get(f\"https://api.github.com/repos/{repo}/releases/tags/{tag_name}\")\n    assert resp.status == 200\n\n    print(\"\u27a1\ufe0f Checking PyPI...\")\n    pypi_data = get_json(\"https://pypi.org/pypi/mitmproxy/json\")\n    assert version in pypi_data[\"releases\"]\n\n    print(\"\u27a1\ufe0f Checking docs archive...\")\n    resp = get(f\"https://docs.mitmproxy.org/archive/v{major_version}/\")\n    assert resp.status == 200\n\n    print(f\"\u27a1\ufe0f Checking Docker ({version} tag)...\")\n    resp = get(\n        f\"https://hub.docker.com/v2/repositories/mitmproxy/mitmproxy/tags/{version}\"\n    )\n    assert resp.status == 200\n\n    if branch == \"main\":\n        print(\"\u27a1\ufe0f Checking Docker (latest tag)...\")\n        docker_latest_data = get_json(\n            \"https://hub.docker.com/v2/repositories/mitmproxy/mitmproxy/tags/latest\"\n        )\n        docker_last_updated = datetime.datetime.fromisoformat(\n            docker_latest_data[\"last_updated\"].replace(\"Z\", \"+00:00\")\n        )\n        print(f\"Last update: {docker_last_updated.isoformat(timespec='minutes')}\")\n        assert docker_last_updated > datetime.datetime.now(\n            datetime.timezone.utc\n        ) - datetime.timedelta(hours=2)\n\n    print(\"\")\n    print(\"\u2705 All done. \ud83e\udd73\")\n    print(\"\")\n", "file_name": "933962.py", "cwe": ["CWE-295: Improper Certificate Validation"]}
{"source": "import cv2\nimport math\nimport numpy as np\nimport os.path as osp\nimport torch\nimport torch.utils.data as data\nfrom basicsr.data import degradations as degradations\nfrom basicsr.data.data_util import paths_from_folder\nfrom basicsr.data.transforms import augment\nfrom basicsr.utils import FileClient, get_root_logger, imfrombytes, img2tensor\nfrom basicsr.utils.registry import DATASET_REGISTRY\nfrom torchvision.transforms.functional import (adjust_brightness, adjust_contrast, adjust_hue, adjust_saturation,\n                                               normalize)\n\n\n@DATASET_REGISTRY.register()\nclass FFHQDegradationDataset(data.Dataset):\n    \"\"\"FFHQ dataset for GFPGAN.\n\n    It reads high resolution images, and then generate low-quality (LQ) images on-the-fly.\n\n    Args:\n        opt (dict): Config for train datasets. It contains the following keys:\n            dataroot_gt (str): Data root path for gt.\n            io_backend (dict): IO backend type and other kwarg.\n            mean (list | tuple): Image mean.\n            std (list | tuple): Image std.\n            use_hflip (bool): Whether to horizontally flip.\n            Please see more options in the codes.\n    \"\"\"\n\n    def __init__(self, opt):\n        super(FFHQDegradationDataset, self).__init__()\n        self.opt = opt\n        # file client (io backend)\n        self.file_client = None\n        self.io_backend_opt = opt['io_backend']\n\n        self.gt_folder = opt['dataroot_gt']\n        self.mean = opt['mean']\n        self.std = opt['std']\n        self.out_size = opt['out_size']\n\n        self.crop_components = opt.get('crop_components', False)  # facial components\n        self.eye_enlarge_ratio = opt.get('eye_enlarge_ratio', 1)  # whether enlarge eye regions\n\n        if self.crop_components:\n            # load component list from a pre-process pth files\n            self.components_list = torch.load(opt.get('component_path'))\n\n        # file client (lmdb io backend)\n        if self.io_backend_opt['type'] == 'lmdb':\n            self.io_backend_opt['db_paths'] = self.gt_folder\n            if not self.gt_folder.endswith('.lmdb'):\n                raise ValueError(f\"'dataroot_gt' should end with '.lmdb', but received {self.gt_folder}\")\n            with open(osp.join(self.gt_folder, 'meta_info.txt')) as fin:\n                self.paths = [line.split('.')[0] for line in fin]\n        else:\n            # disk backend: scan file list from a folder\n            self.paths = paths_from_folder(self.gt_folder)\n\n        # degradation configurations\n        self.blur_kernel_size = opt['blur_kernel_size']\n        self.kernel_list = opt['kernel_list']\n        self.kernel_prob = opt['kernel_prob']\n        self.blur_sigma = opt['blur_sigma']\n        self.downsample_range = opt['downsample_range']\n        self.noise_range = opt['noise_range']\n        self.jpeg_range = opt['jpeg_range']\n\n        # color jitter\n        self.color_jitter_prob = opt.get('color_jitter_prob')\n        self.color_jitter_pt_prob = opt.get('color_jitter_pt_prob')\n        self.color_jitter_shift = opt.get('color_jitter_shift', 20)\n        # to gray\n        self.gray_prob = opt.get('gray_prob')\n\n        logger = get_root_logger()\n        logger.info(f'Blur: blur_kernel_size {self.blur_kernel_size}, sigma: [{\", \".join(map(str, self.blur_sigma))}]')\n        logger.info(f'Downsample: downsample_range [{\", \".join(map(str, self.downsample_range))}]')\n        logger.info(f'Noise: [{\", \".join(map(str, self.noise_range))}]')\n        logger.info(f'JPEG compression: [{\", \".join(map(str, self.jpeg_range))}]')\n\n        if self.color_jitter_prob is not None:\n            logger.info(f'Use random color jitter. Prob: {self.color_jitter_prob}, shift: {self.color_jitter_shift}')\n        if self.gray_prob is not None:\n            logger.info(f'Use random gray. Prob: {self.gray_prob}')\n        self.color_jitter_shift /= 255.\n\n    @staticmethod\n    def color_jitter(img, shift):\n        \"\"\"jitter color: randomly jitter the RGB values, in numpy formats\"\"\"\n        jitter_val = np.random.uniform(-shift, shift, 3).astype(np.float32)\n        img = img + jitter_val\n        img = np.clip(img, 0, 1)\n        return img\n\n    @staticmethod\n    def color_jitter_pt(img, brightness, contrast, saturation, hue):\n        \"\"\"jitter color: randomly jitter the brightness, contrast, saturation, and hue, in torch Tensor formats\"\"\"\n        fn_idx = torch.randperm(4)\n        for fn_id in fn_idx:\n            if fn_id == 0 and brightness is not None:\n                brightness_factor = torch.tensor(1.0).uniform_(brightness[0], brightness[1]).item()\n                img = adjust_brightness(img, brightness_factor)\n\n            if fn_id == 1 and contrast is not None:\n                contrast_factor = torch.tensor(1.0).uniform_(contrast[0], contrast[1]).item()\n                img = adjust_contrast(img, contrast_factor)\n\n            if fn_id == 2 and saturation is not None:\n                saturation_factor = torch.tensor(1.0).uniform_(saturation[0], saturation[1]).item()\n                img = adjust_saturation(img, saturation_factor)\n\n            if fn_id == 3 and hue is not None:\n                hue_factor = torch.tensor(1.0).uniform_(hue[0], hue[1]).item()\n                img = adjust_hue(img, hue_factor)\n        return img\n\n    def get_component_coordinates(self, index, status):\n        \"\"\"Get facial component (left_eye, right_eye, mouth) coordinates from a pre-loaded pth file\"\"\"\n        components_bbox = self.components_list[f'{index:08d}']\n        if status[0]:  # hflip\n            # exchange right and left eye\n            tmp = components_bbox['left_eye']\n            components_bbox['left_eye'] = components_bbox['right_eye']\n            components_bbox['right_eye'] = tmp\n            # modify the width coordinate\n            components_bbox['left_eye'][0] = self.out_size - components_bbox['left_eye'][0]\n            components_bbox['right_eye'][0] = self.out_size - components_bbox['right_eye'][0]\n            components_bbox['mouth'][0] = self.out_size - components_bbox['mouth'][0]\n\n        # get coordinates\n        locations = []\n        for part in ['left_eye', 'right_eye', 'mouth']:\n            mean = components_bbox[part][0:2]\n            half_len = components_bbox[part][2]\n            if 'eye' in part:\n                half_len *= self.eye_enlarge_ratio\n            loc = np.hstack((mean - half_len + 1, mean + half_len))\n            loc = torch.from_numpy(loc).float()\n            locations.append(loc)\n        return locations\n\n    def __getitem__(self, index):\n        if self.file_client is None:\n            self.file_client = FileClient(self.io_backend_opt.pop('type'), **self.io_backend_opt)\n\n        # load gt image\n        # Shape: (h, w, c); channel order: BGR; image range: [0, 1], float32.\n        gt_path = self.paths[index]\n        img_bytes = self.file_client.get(gt_path)\n        img_gt = imfrombytes(img_bytes, float32=True)\n\n        # random horizontal flip\n        img_gt, status = augment(img_gt, hflip=self.opt['use_hflip'], rotation=False, return_status=True)\n        h, w, _ = img_gt.shape\n\n        # get facial component coordinates\n        if self.crop_components:\n            locations = self.get_component_coordinates(index, status)\n            loc_left_eye, loc_right_eye, loc_mouth = locations\n\n        # ------------------------ generate lq image ------------------------ #\n        # blur\n        kernel = degradations.random_mixed_kernels(\n            self.kernel_list,\n            self.kernel_prob,\n            self.blur_kernel_size,\n            self.blur_sigma,\n            self.blur_sigma, [-math.pi, math.pi],\n            noise_range=None)\n        img_lq = cv2.filter2D(img_gt, -1, kernel)\n        # downsample\n        scale = np.random.uniform(self.downsample_range[0], self.downsample_range[1])\n        img_lq = cv2.resize(img_lq, (int(w // scale), int(h // scale)), interpolation=cv2.INTER_LINEAR)\n        # noise\n        if self.noise_range is not None:\n            img_lq = degradations.random_add_gaussian_noise(img_lq, self.noise_range)\n        # jpeg compression\n        if self.jpeg_range is not None:\n            img_lq = degradations.random_add_jpg_compression(img_lq, self.jpeg_range)\n\n        # resize to original size\n        img_lq = cv2.resize(img_lq, (w, h), interpolation=cv2.INTER_LINEAR)\n\n        # random color jitter (only for lq)\n        if self.color_jitter_prob is not None and (np.random.uniform() < self.color_jitter_prob):\n            img_lq = self.color_jitter(img_lq, self.color_jitter_shift)\n        # random to gray (only for lq)\n        if self.gray_prob and np.random.uniform() < self.gray_prob:\n            img_lq = cv2.cvtColor(img_lq, cv2.COLOR_BGR2GRAY)\n            img_lq = np.tile(img_lq[:, :, None], [1, 1, 3])\n            if self.opt.get('gt_gray'):  # whether convert GT to gray images\n                img_gt = cv2.cvtColor(img_gt, cv2.COLOR_BGR2GRAY)\n                img_gt = np.tile(img_gt[:, :, None], [1, 1, 3])  # repeat the color channels\n\n        # BGR to RGB, HWC to CHW, numpy to tensor\n        img_gt, img_lq = img2tensor([img_gt, img_lq], bgr2rgb=True, float32=True)\n\n        # random color jitter (pytorch version) (only for lq)\n        if self.color_jitter_pt_prob is not None and (np.random.uniform() < self.color_jitter_pt_prob):\n            brightness = self.opt.get('brightness', (0.5, 1.5))\n            contrast = self.opt.get('contrast', (0.5, 1.5))\n            saturation = self.opt.get('saturation', (0, 1.5))\n            hue = self.opt.get('hue', (-0.1, 0.1))\n            img_lq = self.color_jitter_pt(img_lq, brightness, contrast, saturation, hue)\n\n        # round and clip\n        img_lq = torch.clamp((img_lq * 255.0).round(), 0, 255) / 255.\n\n        # normalize\n        normalize(img_gt, self.mean, self.std, inplace=True)\n        normalize(img_lq, self.mean, self.std, inplace=True)\n\n        if self.crop_components:\n            return_dict = {\n                'lq': img_lq,\n                'gt': img_gt,\n                'gt_path': gt_path,\n                'loc_left_eye': loc_left_eye,\n                'loc_right_eye': loc_right_eye,\n                'loc_mouth': loc_mouth\n            }\n            return return_dict\n        else:\n            return {'lq': img_lq, 'gt': img_gt, 'gt_path': gt_path}\n\n    def __len__(self):\n        return len(self.paths)\n", "file_name": "870482.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "import importlib\nimport inspect\nimport re\nfrom typing import Any, Callable, Type, Union, get_type_hints\n\nfrom pydantic import BaseModel, parse_raw_as\nfrom pydantic.tools import parse_obj_as\n\n\ndef name_to_title(name: str) -> str:\n    \"\"\"Converts a camelCase or snake_case name to title case.\"\"\"\n    # If camelCase -> convert to snake case\n    name = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", name)\n    name = re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", name).lower()\n    # Convert to title case\n    return name.replace(\"_\", \" \").strip().title()\n\n\ndef is_compatible_type(type: Type) -> bool:\n    \"\"\"Returns `True` if the type is opyrator-compatible.\"\"\"\n    try:\n        if issubclass(type, BaseModel):\n            return True\n    except Exception:\n        pass\n\n    try:\n        # valid list type\n        if type.__origin__ is list and issubclass(type.__args__[0], BaseModel):\n            return True\n    except Exception:\n        pass\n\n    return False\n\n\ndef get_input_type(func: Callable) -> Type:\n    \"\"\"Returns the input type of a given function (callable).\n\n    Args:\n        func: The function for which to get the input type.\n\n    Raises:\n        ValueError: If the function does not have a valid input type annotation.\n    \"\"\"\n    type_hints = get_type_hints(func)\n\n    if \"input\" not in type_hints:\n        raise ValueError(\n            \"The callable MUST have a parameter with the name `input` with typing annotation. \"\n            \"For example: `def my_opyrator(input: InputModel) -> OutputModel:`.\"\n        )\n\n    input_type = type_hints[\"input\"]\n\n    if not is_compatible_type(input_type):\n        raise ValueError(\n            \"The `input` parameter MUST be a subclass of the Pydantic BaseModel or a list of Pydantic models.\"\n        )\n\n    # TODO: return warning if more than one input parameters\n\n    return input_type\n\n\ndef get_output_type(func: Callable) -> Type:\n    \"\"\"Returns the output type of a given function (callable).\n\n    Args:\n        func: The function for which to get the output type.\n\n    Raises:\n        ValueError: If the function does not have a valid output type annotation.\n    \"\"\"\n    type_hints = get_type_hints(func)\n    if \"return\" not in type_hints:\n        raise ValueError(\n            \"The return type of the callable MUST be annotated with type hints.\"\n            \"For example: `def my_opyrator(input: InputModel) -> OutputModel:`.\"\n        )\n\n    output_type = type_hints[\"return\"]\n\n    if not is_compatible_type(output_type):\n        raise ValueError(\n            \"The return value MUST be a subclass of the Pydantic BaseModel or a list of Pydantic models.\"\n        )\n\n    return output_type\n\n\ndef get_callable(import_string: str) -> Callable:\n    \"\"\"Import a callable from an string.\"\"\"\n    callable_seperator = \":\"\n    if callable_seperator not in import_string:\n        # Use dot as seperator\n        callable_seperator = \".\"\n\n    if callable_seperator not in import_string:\n        raise ValueError(\"The callable path MUST specify the function. \")\n\n    mod_name, callable_name = import_string.rsplit(callable_seperator, 1)\n    mod = importlib.import_module(mod_name)\n    return getattr(mod, callable_name)\n\n\nclass Opyrator:\n    def __init__(self, func: Union[Callable, str]) -> None:\n        if isinstance(func, str):\n            # Try to load the function from a string notion\n            self.function = get_callable(func)\n        else:\n            self.function = func\n\n        self._action = \"Execute\"\n        self._input_type = None\n        self._output_type = None\n\n        if not callable(self.function):\n            raise ValueError(\"The provided function parameters is not a callable.\")\n\n        if inspect.isclass(self.function):\n            raise ValueError(\n                \"The provided callable is an uninitialized Class. This is not allowed.\"\n            )\n\n        if inspect.isfunction(self.function):\n            # The provided callable is a function\n            self._input_type = get_input_type(self.function)\n            self._output_type = get_output_type(self.function)\n\n            try:\n                # Get name\n                self._name = name_to_title(self.function.__name__)\n            except Exception:\n                pass\n\n            try:\n                # Get description from function\n                doc_string = inspect.getdoc(self.function)\n                if doc_string:\n                    self._action = doc_string\n            except Exception:\n                pass\n        elif hasattr(self.function, \"__call__\"):\n            # The provided callable is a function\n            self._input_type = get_input_type(self.function.__call__)  # type: ignore\n            self._output_type = get_output_type(self.function.__call__)  # type: ignore\n\n            try:\n                # Get name\n                self._name = name_to_title(type(self.function).__name__)\n            except Exception:\n                pass\n\n            try:\n                # Get action from\n                doc_string = inspect.getdoc(self.function.__call__)  # type: ignore\n                if doc_string:\n                    self._action = doc_string\n\n                if (\n                    not self._action\n                    or self._action == \"Call\"\n                ):\n                    # Get docstring from class instead of __call__ function\n                    doc_string = inspect.getdoc(self.function)\n                    if doc_string:\n                        self._action = doc_string\n            except Exception:\n                pass\n        else:\n            raise ValueError(\"Unknown callable type.\")\n\n    @property\n    def name(self) -> str:\n        return self._name\n\n    @property\n    def action(self) -> str:\n        return self._action\n\n    @property\n    def input_type(self) -> Any:\n        return self._input_type\n\n    @property\n    def output_type(self) -> Any:\n        return self._output_type\n\n    def __call__(self, input: Any, **kwargs: Any) -> Any:\n\n        input_obj = input\n\n        if isinstance(input, str):\n            # Allow json input\n            input_obj = parse_raw_as(self.input_type, input)\n\n        if isinstance(input, dict):\n            # Allow dict input\n            input_obj = parse_obj_as(self.input_type, input)\n\n        return self.function(input_obj, **kwargs)\n", "file_name": "365412.py", "cwe": ["CWE-706: Use of Incorrectly-Resolved Name or Reference"]}
{"source": "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport numpy as np\nfrom .utils.mol_attention import MOLAttention\nfrom .utils.basic_layers import Linear\nfrom .utils.vc_utils import get_mask_from_lengths\n\n\nclass DecoderPrenet(nn.Module):\n    def __init__(self, in_dim, sizes):\n        super().__init__()\n        in_sizes = [in_dim] + sizes[:-1]\n        self.layers = nn.ModuleList(\n            [Linear(in_size, out_size, bias=False)\n             for (in_size, out_size) in zip(in_sizes, sizes)])\n\n    def forward(self, x):\n        for linear in self.layers:\n            x = F.dropout(F.relu(linear(x)), p=0.5, training=True)\n        return x\n\n\nclass Decoder(nn.Module):\n    \"\"\"Mixture of Logistic (MoL) attention-based RNN Decoder.\"\"\"\n    def __init__(\n        self,\n        enc_dim,\n        num_mels,\n        frames_per_step,\n        attention_rnn_dim,\n        decoder_rnn_dim,\n        prenet_dims,\n        num_mixtures,\n        encoder_down_factor=1,\n        num_decoder_rnn_layer=1,\n        use_stop_tokens=False,\n        concat_context_to_last=False,\n    ):\n        super().__init__()\n        self.enc_dim = enc_dim\n        self.encoder_down_factor = encoder_down_factor\n        self.num_mels = num_mels\n        self.frames_per_step = frames_per_step\n        self.attention_rnn_dim = attention_rnn_dim\n        self.decoder_rnn_dim = decoder_rnn_dim\n        self.prenet_dims = prenet_dims\n        self.use_stop_tokens = use_stop_tokens\n        self.num_decoder_rnn_layer = num_decoder_rnn_layer\n        self.concat_context_to_last = concat_context_to_last\n\n        # Mel prenet\n        self.prenet = DecoderPrenet(num_mels, prenet_dims)\n        self.prenet_pitch = DecoderPrenet(num_mels, prenet_dims)\n\n        # Attention RNN\n        self.attention_rnn = nn.LSTMCell(\n            prenet_dims[-1] + enc_dim,\n            attention_rnn_dim\n        )\n        \n        # Attention\n        self.attention_layer = MOLAttention(\n            attention_rnn_dim,\n            r=frames_per_step/encoder_down_factor,\n            M=num_mixtures,\n        )\n\n        # Decoder RNN\n        self.decoder_rnn_layers = nn.ModuleList()\n        for i in range(num_decoder_rnn_layer):\n            if i == 0:\n                self.decoder_rnn_layers.append(\n                    nn.LSTMCell(\n                        enc_dim + attention_rnn_dim,\n                        decoder_rnn_dim))\n            else:\n                self.decoder_rnn_layers.append(\n                    nn.LSTMCell(\n                        decoder_rnn_dim,\n                        decoder_rnn_dim))\n        # self.decoder_rnn = nn.LSTMCell(\n            # 2 * enc_dim + attention_rnn_dim,\n            # decoder_rnn_dim\n        # )\n        if concat_context_to_last:\n            self.linear_projection = Linear(\n                enc_dim + decoder_rnn_dim,\n                num_mels * frames_per_step\n            )\n        else:\n            self.linear_projection = Linear(\n                decoder_rnn_dim,\n                num_mels * frames_per_step\n            )\n\n\n        # Stop-token layer\n        if self.use_stop_tokens:\n            if concat_context_to_last:\n                self.stop_layer = Linear(\n                    enc_dim + decoder_rnn_dim, 1, bias=True, w_init_gain=\"sigmoid\"\n                )\n            else:\n                self.stop_layer = Linear(\n                    decoder_rnn_dim, 1, bias=True, w_init_gain=\"sigmoid\"\n                )\n                \n\n    def get_go_frame(self, memory):\n        B = memory.size(0)\n        go_frame = torch.zeros((B, self.num_mels), dtype=torch.float,\n                               device=memory.device)\n        return go_frame\n\n    def initialize_decoder_states(self, memory, mask):\n        device = next(self.parameters()).device\n        B = memory.size(0)\n        \n        # attention rnn states\n        self.attention_hidden = torch.zeros(\n            (B, self.attention_rnn_dim), device=device)\n        self.attention_cell = torch.zeros(\n            (B, self.attention_rnn_dim), device=device)\n\n        # decoder rnn states\n        self.decoder_hiddens = []\n        self.decoder_cells = []\n        for i in range(self.num_decoder_rnn_layer):\n            self.decoder_hiddens.append(\n                torch.zeros((B, self.decoder_rnn_dim),\n                            device=device)\n            )\n            self.decoder_cells.append(\n                torch.zeros((B, self.decoder_rnn_dim),\n                            device=device)\n            )\n        # self.decoder_hidden = torch.zeros(\n            # (B, self.decoder_rnn_dim), device=device)\n        # self.decoder_cell = torch.zeros(\n            # (B, self.decoder_rnn_dim), device=device)\n        \n        self.attention_context =  torch.zeros(\n            (B, self.enc_dim), device=device)\n\n        self.memory = memory\n        # self.processed_memory = self.attention_layer.memory_layer(memory)\n        self.mask = mask\n\n    def parse_decoder_inputs(self, decoder_inputs):\n        \"\"\"Prepare decoder inputs, i.e. gt mel\n        Args:\n            decoder_inputs:(B, T_out, n_mel_channels) inputs used for teacher-forced training.\n        \"\"\"\n        decoder_inputs = decoder_inputs.reshape(\n            decoder_inputs.size(0),\n            int(decoder_inputs.size(1)/self.frames_per_step), -1)\n        # (B, T_out//r, r*num_mels) -> (T_out//r, B, r*num_mels)\n        decoder_inputs = decoder_inputs.transpose(0, 1)\n        # (T_out//r, B, num_mels)\n        decoder_inputs = decoder_inputs[:,:,-self.num_mels:]\n        return decoder_inputs\n        \n    def parse_decoder_outputs(self, mel_outputs, alignments, stop_outputs):\n        \"\"\" Prepares decoder outputs for output\n        Args:\n            mel_outputs:\n            alignments:\n        \"\"\"\n        # (T_out//r, B, T_enc) -> (B, T_out//r, T_enc)\n        alignments = torch.stack(alignments).transpose(0, 1)\n        # (T_out//r, B) -> (B, T_out//r)\n        if stop_outputs is not None:\n            if alignments.size(0) == 1:\n                stop_outputs = torch.stack(stop_outputs).unsqueeze(0)\n            else:\n                stop_outputs = torch.stack(stop_outputs).transpose(0, 1)\n            stop_outputs = stop_outputs.contiguous()\n        # (T_out//r, B, num_mels*r) -> (B, T_out//r, num_mels*r)\n        mel_outputs = torch.stack(mel_outputs).transpose(0, 1).contiguous()\n        # decouple frames per step\n        # (B, T_out, num_mels)\n        mel_outputs = mel_outputs.view(\n            mel_outputs.size(0), -1, self.num_mels)\n        return mel_outputs, alignments, stop_outputs     \n    \n    def attend(self, decoder_input):\n        cell_input = torch.cat((decoder_input, self.attention_context), -1)\n        self.attention_hidden, self.attention_cell = self.attention_rnn(\n            cell_input, (self.attention_hidden, self.attention_cell))\n        self.attention_context, attention_weights = self.attention_layer(\n            self.attention_hidden, self.memory, None, self.mask)\n        \n        decoder_rnn_input = torch.cat(\n            (self.attention_hidden, self.attention_context), -1)\n\n        return decoder_rnn_input, self.attention_context, attention_weights\n\n    def decode(self, decoder_input):\n        for i in range(self.num_decoder_rnn_layer):\n            if i == 0:\n                self.decoder_hiddens[i], self.decoder_cells[i] = self.decoder_rnn_layers[i](\n                    decoder_input, (self.decoder_hiddens[i], self.decoder_cells[i]))\n            else:\n                self.decoder_hiddens[i], self.decoder_cells[i] = self.decoder_rnn_layers[i](\n                    self.decoder_hiddens[i-1], (self.decoder_hiddens[i], self.decoder_cells[i]))\n        return self.decoder_hiddens[-1]\n    \n    def forward(self, memory, mel_inputs, memory_lengths):\n        \"\"\" Decoder forward pass for training\n        Args:\n            memory: (B, T_enc, enc_dim) Encoder outputs\n            decoder_inputs: (B, T, num_mels) Decoder inputs for teacher forcing.\n            memory_lengths: (B, ) Encoder output lengths for attention masking.\n        Returns:\n            mel_outputs: (B, T, num_mels) mel outputs from the decoder\n            alignments: (B, T//r, T_enc) attention weights.\n        \"\"\"\n        # [1, B, num_mels]\n        go_frame = self.get_go_frame(memory).unsqueeze(0)\n        # [T//r, B, num_mels]\n        mel_inputs = self.parse_decoder_inputs(mel_inputs)\n        # [T//r + 1, B, num_mels]\n        mel_inputs = torch.cat((go_frame, mel_inputs), dim=0)\n        # [T//r + 1, B, prenet_dim]\n        decoder_inputs = self.prenet(mel_inputs) \n        # decoder_inputs_pitch = self.prenet_pitch(decoder_inputs__)\n\n        self.initialize_decoder_states(\n            memory, mask=~get_mask_from_lengths(memory_lengths),\n        )\n        \n        self.attention_layer.init_states(memory)\n        # self.attention_layer_pitch.init_states(memory_pitch)\n\n        mel_outputs, alignments = [], []\n        if self.use_stop_tokens:\n            stop_outputs = []\n        else:\n            stop_outputs = None\n        while len(mel_outputs) < decoder_inputs.size(0) - 1:\n            decoder_input = decoder_inputs[len(mel_outputs)]\n            # decoder_input_pitch = decoder_inputs_pitch[len(mel_outputs)]\n\n            decoder_rnn_input, context, attention_weights = self.attend(decoder_input)\n\n            decoder_rnn_output = self.decode(decoder_rnn_input)\n            if self.concat_context_to_last:    \n                decoder_rnn_output = torch.cat(\n                    (decoder_rnn_output, context), dim=1)\n                   \n            mel_output = self.linear_projection(decoder_rnn_output)\n            if self.use_stop_tokens:\n                stop_output = self.stop_layer(decoder_rnn_output)\n                stop_outputs += [stop_output.squeeze()]\n            mel_outputs += [mel_output.squeeze(1)] #? perhaps don't need squeeze\n            alignments += [attention_weights]\n            # alignments_pitch += [attention_weights_pitch]   \n\n        mel_outputs, alignments, stop_outputs = self.parse_decoder_outputs(\n            mel_outputs, alignments, stop_outputs)\n        if stop_outputs is None:\n            return mel_outputs, alignments\n        else:\n            return mel_outputs, stop_outputs, alignments\n\n    def inference(self, memory, stop_threshold=0.5):\n        \"\"\" Decoder inference\n        Args:\n            memory: (1, T_enc, D_enc) Encoder outputs\n        Returns:\n            mel_outputs: mel outputs from the decoder\n            alignments: sequence of attention weights from the decoder\n        \"\"\"\n        # [1, num_mels]\n        decoder_input = self.get_go_frame(memory)\n\n        self.initialize_decoder_states(memory, mask=None)\n\n        self.attention_layer.init_states(memory)\n        \n        mel_outputs, alignments = [], []\n        # NOTE(sx): heuristic \n        max_decoder_step = memory.size(1)*self.encoder_down_factor//self.frames_per_step \n        min_decoder_step = memory.size(1)*self.encoder_down_factor // self.frames_per_step - 5\n        while True:\n            decoder_input = self.prenet(decoder_input)\n\n            decoder_input_final, context, alignment = self.attend(decoder_input)\n\n            #mel_output, stop_output, alignment = self.decode(decoder_input)\n            decoder_rnn_output = self.decode(decoder_input_final)\n            if self.concat_context_to_last:    \n                decoder_rnn_output = torch.cat(\n                    (decoder_rnn_output, context), dim=1)\n            \n            mel_output = self.linear_projection(decoder_rnn_output)\n            stop_output = self.stop_layer(decoder_rnn_output)\n            \n            mel_outputs += [mel_output.squeeze(1)]\n            alignments += [alignment]\n            \n            if torch.sigmoid(stop_output.data) > stop_threshold and len(mel_outputs) >= min_decoder_step:\n                break\n            if len(mel_outputs) >= max_decoder_step:\n                # print(\"Warning! Decoding steps reaches max decoder steps.\")\n                break\n\n            decoder_input = mel_output[:,-self.num_mels:]\n\n\n        mel_outputs, alignments, _  = self.parse_decoder_outputs(\n            mel_outputs, alignments, None)\n\n        return mel_outputs, alignments\n\n    def inference_batched(self, memory, stop_threshold=0.5):\n        \"\"\" Decoder inference\n        Args:\n            memory: (B, T_enc, D_enc) Encoder outputs\n        Returns:\n            mel_outputs: mel outputs from the decoder\n            alignments: sequence of attention weights from the decoder\n        \"\"\"\n        # [1, num_mels]\n        decoder_input = self.get_go_frame(memory)\n\n        self.initialize_decoder_states(memory, mask=None)\n\n        self.attention_layer.init_states(memory)\n        \n        mel_outputs, alignments = [], []\n        stop_outputs = []\n        # NOTE(sx): heuristic \n        max_decoder_step = memory.size(1)*self.encoder_down_factor//self.frames_per_step \n        min_decoder_step = memory.size(1)*self.encoder_down_factor // self.frames_per_step - 5\n        while True:\n            decoder_input = self.prenet(decoder_input)\n\n            decoder_input_final, context, alignment = self.attend(decoder_input)\n\n            #mel_output, stop_output, alignment = self.decode(decoder_input)\n            decoder_rnn_output = self.decode(decoder_input_final)\n            if self.concat_context_to_last:    \n                decoder_rnn_output = torch.cat(\n                    (decoder_rnn_output, context), dim=1)\n            \n            mel_output = self.linear_projection(decoder_rnn_output)\n            # (B, 1)\n            stop_output = self.stop_layer(decoder_rnn_output)\n            stop_outputs += [stop_output.squeeze()]\n            # stop_outputs.append(stop_output) \n\n            mel_outputs += [mel_output.squeeze(1)]\n            alignments += [alignment]\n            # print(stop_output.shape)\n            if torch.all(torch.sigmoid(stop_output.squeeze().data) > stop_threshold) \\\n                    and len(mel_outputs) >= min_decoder_step:\n                break\n            if len(mel_outputs) >= max_decoder_step:\n                # print(\"Warning! Decoding steps reaches max decoder steps.\")\n                break\n\n            decoder_input = mel_output[:,-self.num_mels:]\n\n\n        mel_outputs, alignments, stop_outputs = self.parse_decoder_outputs(\n            mel_outputs, alignments, stop_outputs)\n        mel_outputs_stacked = []\n        for mel, stop_logit in zip(mel_outputs, stop_outputs):\n            idx = np.argwhere(torch.sigmoid(stop_logit.cpu()) > stop_threshold)[0][0].item()\n            mel_outputs_stacked.append(mel[:idx,:])\n        mel_outputs = torch.cat(mel_outputs_stacked, dim=0).unsqueeze(0)\n        return mel_outputs, alignments\n", "file_name": "476533.py", "cwe": ["Unknown"]}
{"source": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# Copyright 2019 Shigeki Karita\n#  Apache 2.0  (http://www.apache.org/licenses/LICENSE-2.0)\n\n\"\"\"Multi-Head Attention layer definition.\"\"\"\n\nimport math\n\nimport numpy\nimport torch\nfrom torch import nn\n\n\nclass MultiHeadedAttention(nn.Module):\n    \"\"\"Multi-Head Attention layer.\n\n    :param int n_head: the number of head s\n    :param int n_feat: the number of features\n    :param float dropout_rate: dropout rate\n\n    \"\"\"\n\n    def __init__(self, n_head, n_feat, dropout_rate):\n        \"\"\"Construct an MultiHeadedAttention object.\"\"\"\n        super(MultiHeadedAttention, self).__init__()\n        assert n_feat % n_head == 0\n        # We assume d_v always equals d_k\n        self.d_k = n_feat // n_head\n        self.h = n_head\n        self.linear_q = nn.Linear(n_feat, n_feat)\n        self.linear_k = nn.Linear(n_feat, n_feat)\n        self.linear_v = nn.Linear(n_feat, n_feat)\n        self.linear_out = nn.Linear(n_feat, n_feat)\n        self.attn = None\n        self.dropout = nn.Dropout(p=dropout_rate)\n\n    def forward_qkv(self, query, key, value):\n        \"\"\"Transform query, key and value.\n\n        :param torch.Tensor query: (batch, time1, size)\n        :param torch.Tensor key: (batch, time2, size)\n        :param torch.Tensor value: (batch, time2, size)\n        :return torch.Tensor transformed query, key and value\n\n        \"\"\"\n        n_batch = query.size(0)\n        q = self.linear_q(query).view(n_batch, -1, self.h, self.d_k)\n        k = self.linear_k(key).view(n_batch, -1, self.h, self.d_k)\n        v = self.linear_v(value).view(n_batch, -1, self.h, self.d_k)\n        q = q.transpose(1, 2)  # (batch, head, time1, d_k)\n        k = k.transpose(1, 2)  # (batch, head, time2, d_k)\n        v = v.transpose(1, 2)  # (batch, head, time2, d_k)\n\n        return q, k, v\n\n    def forward_attention(self, value, scores, mask):\n        \"\"\"Compute attention context vector.\n\n        :param torch.Tensor value: (batch, head, time2, size)\n        :param torch.Tensor scores: (batch, head, time1, time2)\n        :param torch.Tensor mask: (batch, 1, time2) or (batch, time1, time2)\n        :return torch.Tensor transformed `value` (batch, time1, d_model)\n            weighted by the attention score (batch, time1, time2)\n\n        \"\"\"\n        n_batch = value.size(0)\n        if mask is not None:\n            mask = mask.unsqueeze(1).eq(0)  # (batch, 1, *, time2)\n            min_value = float(\n                numpy.finfo(torch.tensor(0, dtype=scores.dtype).numpy().dtype).min\n            )\n            scores = scores.masked_fill(mask, min_value)\n            self.attn = torch.softmax(scores, dim=-1).masked_fill(\n                mask, 0.0\n            )  # (batch, head, time1, time2)\n        else:\n            self.attn = torch.softmax(scores, dim=-1)  # (batch, head, time1, time2)\n\n        p_attn = self.dropout(self.attn)\n        x = torch.matmul(p_attn, value)  # (batch, head, time1, d_k)\n        x = (\n            x.transpose(1, 2).contiguous().view(n_batch, -1, self.h * self.d_k)\n        )  # (batch, time1, d_model)\n\n        return self.linear_out(x)  # (batch, time1, d_model)\n\n    def forward(self, query, key, value, mask):\n        \"\"\"Compute 'Scaled Dot Product Attention'.\n\n        :param torch.Tensor query: (batch, time1, size)\n        :param torch.Tensor key: (batch, time2, size)\n        :param torch.Tensor value: (batch, time2, size)\n        :param torch.Tensor mask: (batch, 1, time2) or (batch, time1, time2)\n        :param torch.nn.Dropout dropout:\n        :return torch.Tensor: attention output (batch, time1, d_model)\n        \"\"\"\n        q, k, v = self.forward_qkv(query, key, value)\n        scores = torch.matmul(q, k.transpose(-2, -1)) / math.sqrt(self.d_k)\n        return self.forward_attention(v, scores, mask)\n\n\nclass RelPositionMultiHeadedAttention(MultiHeadedAttention):\n    \"\"\"Multi-Head Attention layer with relative position encoding.\n\n    Paper: https://arxiv.org/abs/1901.02860\n\n    :param int n_head: the number of head s\n    :param int n_feat: the number of features\n    :param float dropout_rate: dropout rate\n\n    \"\"\"\n\n    def __init__(self, n_head, n_feat, dropout_rate):\n        \"\"\"Construct an RelPositionMultiHeadedAttention object.\"\"\"\n        super().__init__(n_head, n_feat, dropout_rate)\n        # linear transformation for positional ecoding\n        self.linear_pos = nn.Linear(n_feat, n_feat, bias=False)\n        # these two learnable bias are used in matrix c and matrix d\n        # as described in https://arxiv.org/abs/1901.02860 Section 3.3\n        self.pos_bias_u = nn.Parameter(torch.Tensor(self.h, self.d_k))\n        self.pos_bias_v = nn.Parameter(torch.Tensor(self.h, self.d_k))\n        torch.nn.init.xavier_uniform_(self.pos_bias_u)\n        torch.nn.init.xavier_uniform_(self.pos_bias_v)\n\n    def rel_shift(self, x, zero_triu=False):\n        \"\"\"Compute relative positinal encoding.\n\n        :param torch.Tensor x: (batch, time, size)\n        :param bool zero_triu: return the lower triangular part of the matrix\n        \"\"\"\n        zero_pad = torch.zeros((*x.size()[:3], 1), device=x.device, dtype=x.dtype)\n        x_padded = torch.cat([zero_pad, x], dim=-1)\n\n        x_padded = x_padded.view(*x.size()[:2], x.size(3) + 1, x.size(2))\n        x = x_padded[:, :, 1:].view_as(x)\n\n        if zero_triu:\n            ones = torch.ones((x.size(2), x.size(3)))\n            x = x * torch.tril(ones, x.size(3) - x.size(2))[None, None, :, :]\n\n        return x\n\n    def forward(self, query, key, value, pos_emb, mask):\n        \"\"\"Compute 'Scaled Dot Product Attention' with rel. positional encoding.\n\n        :param torch.Tensor query: (batch, time1, size)\n        :param torch.Tensor key: (batch, time2, size)\n        :param torch.Tensor value: (batch, time2, size)\n        :param torch.Tensor pos_emb: (batch, time1, size)\n        :param torch.Tensor mask: (batch, time1, time2)\n        :param torch.nn.Dropout dropout:\n        :return torch.Tensor: attention output  (batch, time1, d_model)\n        \"\"\"\n        q, k, v = self.forward_qkv(query, key, value)\n        q = q.transpose(1, 2)  # (batch, time1, head, d_k)\n\n        n_batch_pos = pos_emb.size(0)\n        p = self.linear_pos(pos_emb).view(n_batch_pos, -1, self.h, self.d_k)\n        p = p.transpose(1, 2)  # (batch, head, time1, d_k)\n\n        # (batch, head, time1, d_k)\n        q_with_bias_u = (q + self.pos_bias_u).transpose(1, 2)\n        # (batch, head, time1, d_k)\n        q_with_bias_v = (q + self.pos_bias_v).transpose(1, 2)\n\n        # compute attention score\n        # first compute matrix a and matrix c\n        # as described in https://arxiv.org/abs/1901.02860 Section 3.3\n        # (batch, head, time1, time2)\n        matrix_ac = torch.matmul(q_with_bias_u, k.transpose(-2, -1))\n\n        # compute matrix b and matrix d\n        # (batch, head, time1, time2)\n        matrix_bd = torch.matmul(q_with_bias_v, p.transpose(-2, -1))\n        matrix_bd = self.rel_shift(matrix_bd)\n\n        scores = (matrix_ac + matrix_bd) / math.sqrt(\n            self.d_k\n        )  # (batch, head, time1, time2)\n\n        return self.forward_attention(v, scores, mask)\n", "file_name": "434281.py", "cwe": ["Unknown"]}
{"source": "import importlib\nimport logging\nimport types\nfrom dataclasses import dataclass, field\nfrom heapq import heappop, heappush\nfrom typing import Type, TypeAlias\n\nfrom quivr_core.files.file import FileExtension\n\nfrom .processor_base import ProcessorBase\n\nlogger = logging.getLogger(\"quivr_core\")\n\n_LOWEST_PRIORITY = 100\n\n_registry: dict[str, Type[ProcessorBase]] = {}\n\n# external, read only. Contains the actual processors that we are imported and ready to use\nregistry = types.MappingProxyType(_registry)\n\n\n@dataclass(order=True)\nclass ProcEntry:\n    priority: int\n    cls_mod: str = field(compare=False)\n    err: str | None = field(compare=False)\n\n\nProcMapping: TypeAlias = dict[FileExtension | str, list[ProcEntry]]\n\n# Register based on mimetypes\nbase_processors: ProcMapping = {\n    FileExtension.txt: [\n        ProcEntry(\n            cls_mod=\"quivr_core.processor.implementations.simple_txt_processor.SimpleTxtProcessor\",\n            err=None,\n            priority=_LOWEST_PRIORITY,\n        )\n    ],\n    FileExtension.pdf: [\n        ProcEntry(\n            cls_mod=\"quivr_core.processor.implementations.tika_processor.TikaProcessor\",\n            err=None,\n            priority=_LOWEST_PRIORITY,\n        )\n    ],\n}\n\n\ndef _append_proc_mapping(\n    mapping: ProcMapping,\n    file_ext: FileExtension | str,\n    cls_mod: str,\n    errtxt: str,\n    priority: int | None,\n):\n    if file_ext in mapping:\n        try:\n            prev_proc = heappop(mapping[file_ext])\n            proc_entry = ProcEntry(\n                priority=priority if priority is not None else prev_proc.priority - 1,\n                cls_mod=cls_mod,\n                err=errtxt,\n            )\n            # Push the previous processor back\n            heappush(mapping[file_ext], prev_proc)\n            heappush(mapping[file_ext], proc_entry)\n        except IndexError:\n            proc_entry = ProcEntry(\n                priority=priority if priority is not None else _LOWEST_PRIORITY,\n                cls_mod=cls_mod,\n                err=errtxt,\n            )\n            heappush(mapping[file_ext], proc_entry)\n\n    else:\n        proc_entry = ProcEntry(\n            priority=priority if priority is not None else _LOWEST_PRIORITY,\n            cls_mod=cls_mod,\n            err=errtxt,\n        )\n        mapping[file_ext] = [proc_entry]\n\n\ndef defaults_to_proc_entries(\n    base_processors: ProcMapping,\n) -> ProcMapping:\n    # TODO(@aminediro) : how can a user change the order of the processor ?\n    # NOTE: order of this list is important as resolution of `get_processor_class` depends on it\n    # We should have a way to automatically add these at 'import' time\n    for supported_extensions, processor_name in [\n        ([FileExtension.csv], \"CSVProcessor\"),\n        ([FileExtension.txt], \"TikTokenTxtProcessor\"),\n        ([FileExtension.docx, FileExtension.doc], \"DOCXProcessor\"),\n        ([FileExtension.xls, FileExtension.xlsx], \"XLSXProcessor\"),\n        ([FileExtension.pptx], \"PPTProcessor\"),\n        (\n            [FileExtension.markdown, FileExtension.md, FileExtension.mdx],\n            \"MarkdownProcessor\",\n        ),\n        ([FileExtension.epub], \"EpubProcessor\"),\n        ([FileExtension.bib], \"BibTexProcessor\"),\n        ([FileExtension.odt], \"ODTProcessor\"),\n        ([FileExtension.html], \"HTMLProcessor\"),\n        ([FileExtension.py], \"PythonProcessor\"),\n        ([FileExtension.ipynb], \"NotebookProcessor\"),\n    ]:\n        for ext in supported_extensions:\n            ext_str = ext.value if isinstance(ext, FileExtension) else ext\n            _append_proc_mapping(\n                mapping=base_processors,\n                file_ext=ext,\n                cls_mod=f\"quivr_core.processor.implementations.default.{processor_name}\",\n                errtxt=f\"can't import {processor_name}. Please install quivr-core[{ext_str}] to access {processor_name}\",\n                priority=None,\n            )\n\n    # TODO(@aminediro): Megaparse should register itself\n    # Append Megaparse\n    _append_proc_mapping(\n        mapping=base_processors,\n        file_ext=FileExtension.pdf,\n        cls_mod=\"quivr_core.processor.implementations.megaparse_processor.MegaparseProcessor\",\n        errtxt=f\"can't import MegaparseProcessor. Please install quivr-core[{ext_str}] to access MegaparseProcessor\",\n        priority=None,\n    )\n    return base_processors\n\n\nknown_processors = defaults_to_proc_entries(base_processors)\n\n\ndef get_processor_class(file_extension: FileExtension | str) -> Type[ProcessorBase]:\n    \"\"\"Fetch processor class from registry\n\n    The dict ``known_processors`` maps file extensions to the locations\n    of processors that could process them.\n    Loading of these classes is *Lazy*. Appropriate import will happen\n    the first time we try to process some file type.\n\n    Some processors need additional dependencies. If the import fails\n    we return the \"err\" field of the ProcEntry in  ``known_processors``.\n    \"\"\"\n\n    if file_extension not in registry:\n        # Either you registered it from module or it's in the known processors\n        if file_extension not in known_processors:\n            raise ValueError(f\"Extension not known: {file_extension}\")\n        entries = known_processors[file_extension]\n        while entries:\n            proc_entry = heappop(entries)\n            try:\n                register_processor(file_extension, _import_class(proc_entry.cls_mod))\n                break\n            except ImportError:\n                logger.warn(\n                    f\"{proc_entry.err}. Falling to the next available processor for {file_extension}\"\n                )\n        if len(entries) == 0 and file_extension not in registry:\n            raise ImportError(f\"can't find any processor for {file_extension}\")\n\n    cls = registry[file_extension]\n    return cls\n\n\ndef register_processor(\n    file_ext: FileExtension | str,\n    proc_cls: str | Type[ProcessorBase],\n    append: bool = True,\n    override: bool = False,\n    errtxt: str | None = None,\n    priority: int | None = None,\n):\n    if isinstance(proc_cls, str):\n        if file_ext in known_processors and append is False:\n            if all(proc_cls != proc.cls_mod for proc in known_processors[file_ext]):\n                raise ValueError(\n                    f\"Processor for ({file_ext}) already in the registry and append is False\"\n                )\n        else:\n            if all(proc_cls != proc.cls_mod for proc in known_processors[file_ext]):\n                _append_proc_mapping(\n                    known_processors,\n                    file_ext=file_ext,\n                    cls_mod=proc_cls,\n                    errtxt=errtxt\n                    or f\"{proc_cls} import failed for processor of {file_ext}\",\n                    priority=priority,\n                )\n            else:\n                logger.info(f\"{proc_cls} already in registry...\")\n\n    else:\n        assert issubclass(\n            proc_cls, ProcessorBase\n        ), f\"{proc_cls} should be a subclass of quivr_core.processor.ProcessorBase\"\n        if file_ext in registry and override is False:\n            if _registry[file_ext] is not proc_cls:\n                raise ValueError(\n                    f\"Processor for ({file_ext}) already in the registry and append is False\"\n                )\n        else:\n            _registry[file_ext] = proc_cls\n\n\ndef _import_class(full_mod_path: str):\n    if \":\" in full_mod_path:\n        mod_name, name = full_mod_path.rsplit(\":\", 1)\n    else:\n        mod_name, name = full_mod_path.rsplit(\".\", 1)\n\n    mod = importlib.import_module(mod_name)\n\n    for cls in name.split(\".\"):\n        mod = getattr(mod, cls)\n\n    if not isinstance(mod, type):\n        raise TypeError(f\"{full_mod_path} is not a class\")\n\n    if not issubclass(mod, ProcessorBase):\n        raise TypeError(f\"{full_mod_path} is not a subclass of ProcessorBase \")\n\n    return mod\n\n\ndef available_processors():\n    \"\"\"Return a list of the known processors.\"\"\"\n    return list(known_processors)\n", "file_name": "554536.py", "cwe": ["CWE-706: Use of Incorrectly-Resolved Name or Reference"]}
{"source": "import json\nimport os\nimport re\nimport string\nfrom collections import Counter\nfrom shutil import rmtree\nfrom typing import Any, Dict, List, Optional, Tuple\n\nimport requests\nimport tqdm\nfrom llama_index.core.base.base_query_engine import BaseQueryEngine\nfrom llama_index.core.base.base_retriever import BaseRetriever\nfrom llama_index.core.query_engine.retriever_query_engine import (\n    RetrieverQueryEngine,\n)\nfrom llama_index.core.schema import NodeWithScore, QueryBundle, TextNode\nfrom llama_index.core.utils import get_cache_dir\n\nDEV_DISTRACTOR_URL = \"\"\"http://curtis.ml.cmu.edu/datasets/\\\nhotpot/hotpot_dev_distractor_v1.json\"\"\"\n\n\nclass HotpotQAEvaluator:\n    \"\"\"\n    Refer to https://hotpotqa.github.io/ for more details on the dataset.\n    \"\"\"\n\n    def _download_datasets(self) -> Dict[str, str]:\n        cache_dir = get_cache_dir()\n\n        dataset_paths = {}\n        dataset = \"hotpot_dev_distractor\"\n        dataset_full_path = os.path.join(cache_dir, \"datasets\", \"HotpotQA\")\n        if not os.path.exists(dataset_full_path):\n            url = DEV_DISTRACTOR_URL\n            try:\n                os.makedirs(dataset_full_path, exist_ok=True)\n                save_file = open(\n                    os.path.join(dataset_full_path, \"dev_distractor.json\"), \"wb\"\n                )\n                response = requests.get(url, stream=True)\n\n                # Define the size of each chunk\n                chunk_size = 1024\n\n                # Loop over the chunks and parse the JSON data\n                for chunk in tqdm.tqdm(response.iter_content(chunk_size=chunk_size)):\n                    if chunk:\n                        save_file.write(chunk)\n            except Exception as e:\n                if os.path.exists(dataset_full_path):\n                    print(\n                        \"Dataset:\", dataset, \"not found at:\", url, \"Removing cached dir\"\n                    )\n                    rmtree(dataset_full_path)\n                raise ValueError(f\"could not download {dataset} dataset\") from e\n        dataset_paths[dataset] = os.path.join(dataset_full_path, \"dev_distractor.json\")\n        print(\"Dataset:\", dataset, \"downloaded at:\", dataset_full_path)\n        return dataset_paths\n\n    def run(\n        self,\n        query_engine: BaseQueryEngine,\n        queries: int = 10,\n        queries_fraction: Optional[float] = None,\n        show_result: bool = False,\n    ) -> None:\n        dataset_paths = self._download_datasets()\n        dataset = \"hotpot_dev_distractor\"\n        dataset_path = dataset_paths[dataset]\n        print(\"Evaluating on dataset:\", dataset)\n        print(\"-------------------------------------\")\n\n        f = open(dataset_path)\n        query_objects = json.loads(f.read())\n        if queries_fraction:\n            queries_to_load = int(len(query_objects) * queries_fraction)\n        else:\n            queries_to_load = queries\n            queries_fraction = round(queries / len(query_objects), 5)\n\n        print(\n            f\"Loading {queries_to_load} queries out of \\\n{len(query_objects)} (fraction: {queries_fraction})\"\n        )\n        query_objects = query_objects[:queries_to_load]\n\n        assert isinstance(\n            query_engine, RetrieverQueryEngine\n        ), \"query_engine must be a RetrieverQueryEngine for this evaluation\"\n        retriever = HotpotQARetriever(query_objects)\n        # Mock the query engine with a retriever\n        query_engine = query_engine.with_retriever(retriever=retriever)\n\n        scores = {\"exact_match\": 0.0, \"f1\": 0.0}\n\n        for query in query_objects:\n            query_bundle = QueryBundle(\n                query_str=query[\"question\"]\n                + \" Give a short factoid answer (as few words as possible).\",\n                custom_embedding_strs=[query[\"question\"]],\n            )\n            response = query_engine.query(query_bundle)\n            em = int(\n                exact_match_score(\n                    prediction=str(response), ground_truth=query[\"answer\"]\n                )\n            )\n            f1, _, _ = f1_score(prediction=str(response), ground_truth=query[\"answer\"])\n            scores[\"exact_match\"] += em\n            scores[\"f1\"] += f1\n            if show_result:\n                print(\"Question: \", query[\"question\"])\n                print(\"Response:\", response)\n                print(\"Correct answer: \", query[\"answer\"])\n                print(\"EM:\", em, \"F1:\", f1)\n                print(\"-------------------------------------\")\n\n        for score in scores:\n            scores[score] /= len(query_objects)\n\n        print(\"Scores: \", scores)\n\n\nclass HotpotQARetriever(BaseRetriever):\n    \"\"\"\n    This is a mocked retriever for HotpotQA dataset. It is only meant to be used\n    with the hotpotqa dev dataset in the distractor setting. This is the setting that\n    does not require retrieval but requires identifying the supporting facts from\n    a list of 10 sources.\n    \"\"\"\n\n    def __init__(self, query_objects: Any) -> None:\n        assert isinstance(\n            query_objects,\n            list,\n        ), f\"query_objects must be a list, got: {type(query_objects)}\"\n        self._queries = {}\n        for object in query_objects:\n            self._queries[object[\"question\"]] = object\n\n    def _retrieve(self, query: QueryBundle) -> List[NodeWithScore]:\n        if query.custom_embedding_strs:\n            query_str = query.custom_embedding_strs[0]\n        else:\n            query_str = query.query_str\n        contexts = self._queries[query_str][\"context\"]\n        node_with_scores = []\n        for ctx in contexts:\n            text_list = ctx[1]\n            text = \"\\n\".join(text_list)\n            node = TextNode(text=text, metadata={\"title\": ctx[0]})\n            node_with_scores.append(NodeWithScore(node=node, score=1.0))\n\n        return node_with_scores\n\n    def __str__(self) -> str:\n        return \"HotpotQARetriever\"\n\n\n\"\"\"\nUtils from https://github.com/hotpotqa/hotpot/blob/master/hotpot_evaluate_v1.py\n\"\"\"\n\n\ndef normalize_answer(s: str) -> str:\n    def remove_articles(text: str) -> str:\n        return re.sub(r\"\\b(a|an|the)\\b\", \" \", text)\n\n    def white_space_fix(text: str) -> str:\n        return \" \".join(text.split())\n\n    def remove_punc(text: str) -> str:\n        exclude = set(string.punctuation)\n        return \"\".join(ch for ch in text if ch not in exclude)\n\n    def lower(text: str) -> str:\n        return text.lower()\n\n    return white_space_fix(remove_articles(remove_punc(lower(s))))\n\n\ndef f1_score(prediction: str, ground_truth: str) -> Tuple[float, float, float]:\n    normalized_prediction = normalize_answer(prediction)\n    normalized_ground_truth = normalize_answer(ground_truth)\n\n    ZERO_METRIC = (0, 0, 0)\n\n    if (\n        normalized_prediction in [\"yes\", \"no\", \"noanswer\"]\n        and normalized_prediction != normalized_ground_truth\n    ):\n        return ZERO_METRIC\n    if (\n        normalized_ground_truth in [\"yes\", \"no\", \"noanswer\"]\n        and normalized_prediction != normalized_ground_truth\n    ):\n        return ZERO_METRIC\n\n    prediction_tokens = normalized_prediction.split()\n    ground_truth_tokens = normalized_ground_truth.split()\n    common = Counter(prediction_tokens) & Counter(ground_truth_tokens)\n    num_same = sum(common.values())\n    if num_same == 0:\n        return ZERO_METRIC\n    precision = 1.0 * num_same / len(prediction_tokens)\n    recall = 1.0 * num_same / len(ground_truth_tokens)\n    f1 = (2 * precision * recall) / (precision + recall)\n    return f1, precision, recall\n\n\ndef exact_match_score(prediction: str, ground_truth: str) -> bool:\n    return normalize_answer(prediction) == normalize_answer(ground_truth)\n", "file_name": "930264.py", "cwe": ["CWE-319: Cleartext Transmission of Sensitive Information"]}
{"source": "\"\"\"SQL wrapper around SQLDatabase in langchain.\"\"\"\nfrom typing import Any, Dict, Iterable, List, Optional, Tuple\n\nfrom sqlalchemy import MetaData, create_engine, insert, inspect, text\nfrom sqlalchemy.engine import Engine\nfrom sqlalchemy.exc import OperationalError, ProgrammingError\n\n\nclass SQLDatabase:\n    \"\"\"SQL Database.\n\n    This class provides a wrapper around the SQLAlchemy engine to interact with a SQL\n    database.\n    It provides methods to execute SQL commands, insert data into tables, and retrieve\n    information about the database schema.\n    It also supports optional features such as including or excluding specific tables,\n    sampling rows for table info,\n    including indexes in table info, and supporting views.\n\n    Based on langchain SQLDatabase.\n    https://github.com/langchain-ai/langchain/blob/e355606b1100097665207ca259de6dc548d44c78/libs/langchain/langchain/utilities/sql_database.py#L39\n\n    Args:\n        engine (Engine): The SQLAlchemy engine instance to use for database operations.\n        schema (Optional[str]): The name of the schema to use, if any.\n        metadata (Optional[MetaData]): The metadata instance to use, if any.\n        ignore_tables (Optional[List[str]]): List of table names to ignore. If set,\n            include_tables must be None.\n        include_tables (Optional[List[str]]): List of table names to include. If set,\n            ignore_tables must be None.\n        sample_rows_in_table_info (int): The number of sample rows to include in table\n            info.\n        indexes_in_table_info (bool): Whether to include indexes in table info.\n        custom_table_info (Optional[dict]): Custom table info to use.\n        view_support (bool): Whether to support views.\n        max_string_length (int): The maximum string length to use.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        engine: Engine,\n        schema: Optional[str] = None,\n        metadata: Optional[MetaData] = None,\n        ignore_tables: Optional[List[str]] = None,\n        include_tables: Optional[List[str]] = None,\n        sample_rows_in_table_info: int = 3,\n        indexes_in_table_info: bool = False,\n        custom_table_info: Optional[dict] = None,\n        view_support: bool = False,\n        max_string_length: int = 300,\n    ):\n        \"\"\"Create engine from database URI.\"\"\"\n        self._engine = engine\n        self._schema = schema\n        if include_tables and ignore_tables:\n            raise ValueError(\"Cannot specify both include_tables and ignore_tables\")\n\n        self._inspector = inspect(self._engine)\n\n        # including view support by adding the views as well as tables to the all\n        # tables list if view_support is True\n        self._all_tables = set(\n            self._inspector.get_table_names(schema=schema)\n            + (self._inspector.get_view_names(schema=schema) if view_support else [])\n        )\n\n        self._include_tables = set(include_tables) if include_tables else set()\n        if self._include_tables:\n            missing_tables = self._include_tables - self._all_tables\n            if missing_tables:\n                raise ValueError(\n                    f\"include_tables {missing_tables} not found in database\"\n                )\n        self._ignore_tables = set(ignore_tables) if ignore_tables else set()\n        if self._ignore_tables:\n            missing_tables = self._ignore_tables - self._all_tables\n            if missing_tables:\n                raise ValueError(\n                    f\"ignore_tables {missing_tables} not found in database\"\n                )\n        usable_tables = self.get_usable_table_names()\n        self._usable_tables = set(usable_tables) if usable_tables else self._all_tables\n\n        if not isinstance(sample_rows_in_table_info, int):\n            raise TypeError(\"sample_rows_in_table_info must be an integer\")\n\n        self._sample_rows_in_table_info = sample_rows_in_table_info\n        self._indexes_in_table_info = indexes_in_table_info\n\n        self._custom_table_info = custom_table_info\n        if self._custom_table_info:\n            if not isinstance(self._custom_table_info, dict):\n                raise TypeError(\n                    \"table_info must be a dictionary with table names as keys and the \"\n                    \"desired table info as values\"\n                )\n            # only keep the tables that are also present in the database\n            intersection = set(self._custom_table_info).intersection(self._all_tables)\n            self._custom_table_info = {\n                table: info\n                for table, info in self._custom_table_info.items()\n                if table in intersection\n            }\n\n        self._max_string_length = max_string_length\n\n        self._metadata = metadata or MetaData()\n        # including view support if view_support = true\n        self._metadata.reflect(\n            views=view_support,\n            bind=self._engine,\n            only=list(self._usable_tables),\n            schema=self._schema,\n        )\n\n    @property\n    def engine(self) -> Engine:\n        \"\"\"Return SQL Alchemy engine.\"\"\"\n        return self._engine\n\n    @property\n    def metadata_obj(self) -> MetaData:\n        \"\"\"Return SQL Alchemy metadata.\"\"\"\n        return self._metadata\n\n    @classmethod\n    def from_uri(\n        cls, database_uri: str, engine_args: Optional[dict] = None, **kwargs: Any\n    ) -> \"SQLDatabase\":\n        \"\"\"Construct a SQLAlchemy engine from URI.\"\"\"\n        _engine_args = engine_args or {}\n        return cls(create_engine(database_uri, **_engine_args), **kwargs)\n\n    @property\n    def dialect(self) -> str:\n        \"\"\"Return string representation of dialect to use.\"\"\"\n        return self._engine.dialect.name\n\n    def get_usable_table_names(self) -> Iterable[str]:\n        \"\"\"Get names of tables available.\"\"\"\n        if self._include_tables:\n            return sorted(self._include_tables)\n        return sorted(self._all_tables - self._ignore_tables)\n\n    def get_table_columns(self, table_name: str) -> List[Any]:\n        \"\"\"Get table columns.\"\"\"\n        return self._inspector.get_columns(table_name)\n\n    def get_single_table_info(self, table_name: str) -> str:\n        \"\"\"Get table info for a single table.\"\"\"\n        # same logic as table_info, but with specific table names\n        template = \"Table '{table_name}' has columns: {columns}, \"\n        try:\n            # try to retrieve table comment\n            table_comment = self._inspector.get_table_comment(\n                table_name, schema=self._schema\n            )[\"text\"]\n            if table_comment:\n                template += f\"with comment: ({table_comment}) \"\n        except NotImplementedError:\n            # get_table_comment raises NotImplementedError for a dialect that does not support comments.\n            pass\n\n        template += \"{foreign_keys}.\"\n        columns = []\n        for column in self._inspector.get_columns(table_name, schema=self._schema):\n            if column.get(\"comment\"):\n                columns.append(\n                    f\"{column['name']} ({column['type']!s}): \"\n                    f\"'{column.get('comment')}'\"\n                )\n            else:\n                columns.append(f\"{column['name']} ({column['type']!s})\")\n\n        column_str = \", \".join(columns)\n        foreign_keys = []\n        for foreign_key in self._inspector.get_foreign_keys(\n            table_name, schema=self._schema\n        ):\n            foreign_keys.append(\n                f\"{foreign_key['constrained_columns']} -> \"\n                f\"{foreign_key['referred_table']}.{foreign_key['referred_columns']}\"\n            )\n        foreign_key_str = (\n            foreign_keys\n            and \" and foreign keys: {}\".format(\", \".join(foreign_keys))\n            or \"\"\n        )\n        return template.format(\n            table_name=table_name, columns=column_str, foreign_keys=foreign_key_str\n        )\n\n    def insert_into_table(self, table_name: str, data: dict) -> None:\n        \"\"\"Insert data into a table.\"\"\"\n        table = self._metadata.tables[table_name]\n        stmt = insert(table).values(**data)\n        with self._engine.begin() as connection:\n            connection.execute(stmt)\n\n    def truncate_word(self, content: Any, *, length: int, suffix: str = \"...\") -> str:\n        \"\"\"\n        Truncate a string to a certain number of words, based on the max string\n        length.\n        \"\"\"\n        if not isinstance(content, str) or length <= 0:\n            return content\n\n        if len(content) <= length:\n            return content\n\n        return content[: length - len(suffix)].rsplit(\" \", 1)[0] + suffix\n\n    def run_sql(self, command: str) -> Tuple[str, Dict]:\n        \"\"\"Execute a SQL statement and return a string representing the results.\n\n        If the statement returns rows, a string of the results is returned.\n        If the statement returns no rows, an empty string is returned.\n        \"\"\"\n        with self._engine.begin() as connection:\n            try:\n                if self._schema:\n                    command = command.replace(\"FROM \", f\"FROM {self._schema}.\")\n                    command = command.replace(\"JOIN \", f\"JOIN {self._schema}.\")\n                cursor = connection.execute(text(command))\n            except (ProgrammingError, OperationalError) as exc:\n                raise NotImplementedError(\n                    f\"Statement {command!r} is invalid SQL.\"\n                ) from exc\n            if cursor.returns_rows:\n                result = cursor.fetchall()\n                # truncate the results to the max string length\n                # we can't use str(result) directly because it automatically truncates long strings\n                truncated_results = []\n                for row in result:\n                    # truncate each column, then convert the row to a tuple\n                    truncated_row = tuple(\n                        self.truncate_word(column, length=self._max_string_length)\n                        for column in row\n                    )\n                    truncated_results.append(truncated_row)\n                return str(truncated_results), {\n                    \"result\": truncated_results,\n                    \"col_keys\": list(cursor.keys()),\n                }\n        return \"\", {}\n", "file_name": "885715.py", "cwe": ["CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"]}
{"source": "\"\"\"\nCallback handler for storing generation data in OpenInference format.\nOpenInference is an open standard for capturing and storing AI model inferences.\nIt enables production LLMapp servers to seamlessly integrate with LLM\nobservability solutions such as Arize and Phoenix.\n\nFor more information on the specification, see\nhttps://github.com/Arize-ai/open-inference-spec\n\"\"\"\n\nimport importlib\nimport uuid\nfrom dataclasses import dataclass, field, fields\nfrom datetime import datetime\nfrom types import ModuleType\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Dict,\n    Iterable,\n    List,\n    Optional,\n    Tuple,\n    TypeVar,\n)\n\nfrom llama_index.core.base.llms.types import ChatResponse\nfrom llama_index.core.callbacks.base_handler import BaseCallbackHandler\nfrom llama_index.core.callbacks.schema import CBEventType, EventPayload\n\nif TYPE_CHECKING:\n    from pandas import DataFrame\n\n\nOPENINFERENCE_COLUMN_NAME = \"openinference_column_name\"\nEmbedding = List[float]\n\n\ndef _generate_random_id() -> str:\n    \"\"\"Generates a random ID.\n\n    Returns:\n        str: A random ID.\n    \"\"\"\n    return str(uuid.uuid4())\n\n\n@dataclass\nclass QueryData:\n    \"\"\"\n    Query data with column names following the OpenInference specification.\n    \"\"\"\n\n    id: str = field(\n        default_factory=_generate_random_id,\n        metadata={OPENINFERENCE_COLUMN_NAME: \":id.id:\"},\n    )\n    timestamp: Optional[str] = field(\n        default=None, metadata={OPENINFERENCE_COLUMN_NAME: \":timestamp.iso_8601:\"}\n    )\n    query_text: Optional[str] = field(\n        default=None,\n        metadata={OPENINFERENCE_COLUMN_NAME: \":feature.text:prompt\"},\n    )\n    query_embedding: Optional[Embedding] = field(\n        default=None,\n        metadata={OPENINFERENCE_COLUMN_NAME: \":feature.[float].embedding:prompt\"},\n    )\n    llm_prompt: Optional[str] = field(\n        default=None,\n        metadata={OPENINFERENCE_COLUMN_NAME: \":feature.text:llm_prompt\"},\n    )\n    llm_messages: Optional[Tuple[str, str]] = field(\n        default=None,\n        metadata={OPENINFERENCE_COLUMN_NAME: \":feature.[str]:llm_messages\"},\n    )\n    response_text: Optional[str] = field(\n        default=None, metadata={OPENINFERENCE_COLUMN_NAME: \":prediction.text:response\"}\n    )\n    node_ids: List[str] = field(\n        default_factory=list,\n        metadata={\n            OPENINFERENCE_COLUMN_NAME: \":feature.[str].retrieved_document_ids:prompt\"\n        },\n    )\n    scores: List[float] = field(\n        default_factory=list,\n        metadata={\n            OPENINFERENCE_COLUMN_NAME: (\n                \":feature.[float].retrieved_document_scores:prompt\"\n            )\n        },\n    )\n\n\n@dataclass\nclass NodeData:\n    \"\"\"Node data.\"\"\"\n\n    id: str\n    node_text: Optional[str] = None\n    node_embedding: Optional[Embedding] = None\n\n\nBaseDataType = TypeVar(\"BaseDataType\", QueryData, NodeData)\n\n\ndef as_dataframe(data: Iterable[BaseDataType]) -> \"DataFrame\":\n    \"\"\"Converts a list of BaseDataType to a pandas dataframe.\n\n    Args:\n        data (Iterable[BaseDataType]): A list of BaseDataType.\n\n    Returns:\n        DataFrame: The converted pandas dataframe.\n    \"\"\"\n    pandas = _import_package(\"pandas\")\n    as_dict_list = []\n    for datum in data:\n        as_dict = {\n            field.metadata.get(OPENINFERENCE_COLUMN_NAME, field.name): getattr(\n                datum, field.name\n            )\n            for field in fields(datum)\n        }\n        as_dict_list.append(as_dict)\n\n    return pandas.DataFrame(as_dict_list)\n\n\n@dataclass\nclass TraceData:\n    \"\"\"Trace data.\"\"\"\n\n    query_data: QueryData = field(default_factory=QueryData)\n    node_datas: List[NodeData] = field(default_factory=list)\n\n\ndef _import_package(package_name: str) -> ModuleType:\n    \"\"\"Dynamically imports a package.\n\n    Args:\n        package_name (str): Name of the package to import.\n\n    Raises:\n        ImportError: If the package is not installed.\n\n    Returns:\n        ModuleType: The imported package.\n    \"\"\"\n    try:\n        package = importlib.import_module(package_name)\n    except ImportError:\n        raise ImportError(f\"The {package_name} package must be installed.\")\n    return package\n\n\nclass OpenInferenceCallbackHandler(BaseCallbackHandler):\n    \"\"\"Callback handler for storing generation data in OpenInference format.\n    OpenInference is an open standard for capturing and storing AI model\n    inferences. It enables production LLMapp servers to seamlessly integrate\n    with LLM observability solutions such as Arize and Phoenix.\n\n    For more information on the specification, see\n    https://github.com/Arize-ai/open-inference-spec\n    \"\"\"\n\n    def __init__(\n        self,\n        callback: Optional[Callable[[List[QueryData], List[NodeData]], None]] = None,\n    ) -> None:\n        \"\"\"Initializes the OpenInferenceCallbackHandler.\n\n        Args:\n            callback (Optional[Callable[[List[QueryData], List[NodeData]], None]], optional): A\n            callback function that will be called when a query trace is\n            completed, often used for logging or persisting query data.\n        \"\"\"\n        super().__init__(event_starts_to_ignore=[], event_ends_to_ignore=[])\n        self._callback = callback\n        self._trace_data = TraceData()\n        self._query_data_buffer: List[QueryData] = []\n        self._node_data_buffer: List[NodeData] = []\n\n    def start_trace(self, trace_id: Optional[str] = None) -> None:\n        if trace_id == \"query\" or trace_id == \"chat\":\n            self._trace_data = TraceData()\n            self._trace_data.query_data.timestamp = datetime.now().isoformat()\n            self._trace_data.query_data.id = _generate_random_id()\n\n    def end_trace(\n        self,\n        trace_id: Optional[str] = None,\n        trace_map: Optional[Dict[str, List[str]]] = None,\n    ) -> None:\n        if trace_id == \"query\" or trace_id == \"chat\":\n            self._query_data_buffer.append(self._trace_data.query_data)\n            self._node_data_buffer.extend(self._trace_data.node_datas)\n            self._trace_data = TraceData()\n            if self._callback is not None:\n                self._callback(self._query_data_buffer, self._node_data_buffer)\n\n    def on_event_start(\n        self,\n        event_type: CBEventType,\n        payload: Optional[Dict[str, Any]] = None,\n        event_id: str = \"\",\n        parent_id: str = \"\",\n        **kwargs: Any,\n    ) -> str:\n        if payload is not None:\n            if event_type is CBEventType.QUERY:\n                query_text = payload[EventPayload.QUERY_STR]\n                self._trace_data.query_data.query_text = query_text\n            elif event_type is CBEventType.LLM:\n                if prompt := payload.get(EventPayload.PROMPT, None):\n                    self._trace_data.query_data.llm_prompt = prompt\n                if messages := payload.get(EventPayload.MESSAGES, None):\n                    self._trace_data.query_data.llm_messages = [\n                        (m.role.value, m.content) for m in messages\n                    ]\n                    # For chat engines there is no query event and thus the\n                    # query text will be None, in this case we set the query\n                    # text to the last message passed to the LLM\n                    if self._trace_data.query_data.query_text is None:\n                        self._trace_data.query_data.query_text = messages[-1].content\n        return event_id\n\n    def on_event_end(\n        self,\n        event_type: CBEventType,\n        payload: Optional[Dict[str, Any]] = None,\n        event_id: str = \"\",\n        **kwargs: Any,\n    ) -> None:\n        if payload is None:\n            return\n        if event_type is CBEventType.RETRIEVE:\n            for node_with_score in payload[EventPayload.NODES]:\n                node = node_with_score.node\n                score = node_with_score.score\n                self._trace_data.query_data.node_ids.append(node.hash)\n                self._trace_data.query_data.scores.append(score)\n                self._trace_data.node_datas.append(\n                    NodeData(\n                        id=node.hash,\n                        node_text=node.text,\n                    )\n                )\n        elif event_type is CBEventType.LLM:\n            if self._trace_data.query_data.response_text is None:\n                if response := payload.get(EventPayload.RESPONSE, None):\n                    if isinstance(response, ChatResponse):\n                        # If the response is of class ChatResponse the string\n                        # representation has the format \"<role>: <message>\",\n                        # but we want just the message\n                        response_text = response.message.content\n                    else:\n                        response_text = str(response)\n                    self._trace_data.query_data.response_text = response_text\n                elif completion := payload.get(EventPayload.COMPLETION, None):\n                    self._trace_data.query_data.response_text = str(completion)\n        elif event_type is CBEventType.EMBEDDING:\n            self._trace_data.query_data.query_embedding = payload[\n                EventPayload.EMBEDDINGS\n            ][0]\n\n    def flush_query_data_buffer(self) -> List[QueryData]:\n        \"\"\"Clears the query data buffer and returns the data.\n\n        Returns:\n            List[QueryData]: The query data.\n        \"\"\"\n        query_data_buffer = self._query_data_buffer\n        self._query_data_buffer = []\n        return query_data_buffer\n\n    def flush_node_data_buffer(self) -> List[NodeData]:\n        \"\"\"Clears the node data buffer and returns the data.\n\n        Returns:\n            List[NodeData]: The node data.\n        \"\"\"\n        node_data_buffer = self._node_data_buffer\n        self._node_data_buffer = []\n        return node_data_buffer\n", "file_name": "910790.py", "cwe": ["CWE-706: Use of Incorrectly-Resolved Name or Reference"]}
{"source": "# Copyright (c) Microsoft Corporation.\n# SPDX-License-Identifier: Apache-2.0\n\n# DeepSpeed Team\nimport importlib\nimport inspect\n\nfrom .abstract_accelerator import DeepSpeedAccelerator\n# During setup stage torch may not be installed, pass on no torch will\n# allow op builder related API to be executed.\ntry:\n    import torch.npu\nexcept ImportError:\n    pass\n\n\nclass NPU_Accelerator(DeepSpeedAccelerator):\n\n    def __init__(self):\n        super().__init__()\n        self._name = 'npu'\n        self._communication_backend_name = 'hccl'\n        self._compile_backend = \"inductor\"\n        # dict that holds class name <--> class type mapping i.e.\n        # 'AsyncIOBuilder': <class 'op_builder.async_io.AsyncIOBuilder'>\n        # this dict will be filled at init stage\n        self.class_dict = None\n\n    def is_synchronized_device(self):\n        return False\n\n    def use_host_timers(self):\n        return self.is_synchronized_device()\n\n    def resolves_data_dependency(self):\n        return self.is_synchronized_device()\n\n    def handles_memory_backpressure(self):\n        return self.is_synchronized_device()\n\n    # Device APIs\n    def device_name(self, device_index=None):\n        if device_index is None:\n            return 'npu'\n        return 'npu:{}'.format(device_index)\n\n    def device(self, device_index=None):\n        return torch.npu.device(device_index)\n\n    def set_device(self, device_index):\n        torch.npu.set_device(device_index)\n\n    def current_device(self):\n        return torch.npu.current_device()\n\n    def current_device_name(self):\n        return 'npu:{}'.format(torch.npu.current_device())\n\n    def device_count(self):\n        return torch.npu.device_count()\n\n    def synchronize(self, device_index=None):\n        return torch.npu.synchronize(device_index)\n\n    # RNG APIs\n    def random(self):\n        return torch.random\n\n    def set_rng_state(self, new_state, device_index=None):\n        if device_index is None:\n            return torch.npu.set_rng_state(new_state)\n\n        return torch.npu.set_rng_state(new_state, device_index)\n\n    def get_rng_state(self, device_index=None):\n        if device_index is None:\n            return torch.npu.get_rng_state()\n\n        return torch.npu.get_rng_state(device_index)\n\n    def manual_seed(self, seed):\n        return torch.npu.manual_seed(seed)\n\n    def manual_seed_all(self, seed):\n        return torch.npu.manual_seed_all(seed)\n\n    def initial_seed(self):\n        return torch.npu.initial_seed()\n\n    def default_generator(self, device_index):\n        return torch.npu.default_generators[device_index]\n\n    # Streams/Events\n    @property\n    def Stream(self):\n        return torch.npu.Stream\n\n    def stream(self, stream):\n        return torch.npu.stream(stream)\n\n    def current_stream(self, device_index=None):\n        return torch.npu.current_stream(device_index)\n\n    def default_stream(self, device_index=None):\n        return torch.npu.default_stream(device_index)\n\n    @property\n    def Event(self):\n        return torch.npu.Event\n\n    # Memory management\n    def empty_cache(self):\n        return torch.npu.empty_cache()\n\n    def memory_allocated(self, device_index=None):\n        return torch.npu.memory_allocated(device_index)\n\n    def max_memory_allocated(self, device_index=None):\n        return torch.npu.max_memory_allocated(device_index)\n\n    def reset_max_memory_allocated(self, device_index=None):\n        return torch.npu.reset_max_memory_allocated(device_index)\n\n    def memory_cached(self, device_index=None):\n        return torch.npu.memory_cached(device_index)\n\n    def max_memory_cached(self, device_index=None):\n        return torch.npu.max_memory_cached(device_index)\n\n    def reset_max_memory_cached(self, device_index=None):\n        return torch.npu.reset_max_memory_cached(device_index)\n\n    def memory_stats(self, device_index=None):\n        if hasattr(torch.npu, 'memory_stats'):\n            return torch.npu.memory_stats(device_index)\n\n    def reset_peak_memory_stats(self, device_index=None):\n        if hasattr(torch.npu, 'reset_peak_memory_stats'):\n            return torch.npu.reset_peak_memory_stats(device_index)\n\n    def memory_reserved(self, device_index=None):\n        if hasattr(torch.npu, 'memory_reserved'):\n            return torch.npu.memory_reserved(device_index)\n\n    def max_memory_reserved(self, device_index=None):\n        if hasattr(torch.npu, 'max_memory_reserved'):\n            return torch.npu.max_memory_reserved(device_index)\n\n    def total_memory(self, device_index=None):\n        return torch.npu.get_device_properties(device_index).total_memory\n\n    def available_memory(self, device_index=None):\n        return self.total_memory(device_index) - self.memory_allocated(device_index)\n\n    # Data types\n    def is_bf16_supported(self):\n        return torch.npu.is_bf16_supported()\n\n    def is_fp16_supported(self):\n        return True\n\n    def supported_dtypes(self):\n        return [torch.float, torch.half, torch.bfloat16]\n\n    # Misc\n    def amp(self):\n        if hasattr(torch.npu, 'amp'):\n            return torch.npu.amp\n        return None\n\n    def is_available(self):\n        return torch.npu.is_available()\n\n    def range_push(self, msg):\n        return\n\n    def range_pop(self):\n        return\n\n    def lazy_call(self, callback):\n        return torch.npu._lazy_call(callback)\n\n    def communication_backend_name(self):\n        return self._communication_backend_name\n\n    def is_triton_supported(self):\n        return False\n\n    # Graph operations\n    def create_graph(self):\n        return None\n\n    def capture_to_graph(self, graph, pool=None, stream=None):\n        from deepspeed.runtime.utils import noop_context\n        return noop_context()\n\n    def replay_graph(self, graph):\n        return\n\n    # Tensor operations\n\n    @property\n    def BFloat16Tensor(self):\n        return torch.npu.BFloat16Tensor\n\n    @property\n    def ByteTensor(self):\n        return torch.npu.ByteTensor\n\n    @property\n    def DoubleTensor(self):\n        return torch.npu.DoubleTensor\n\n    @property\n    def FloatTensor(self):\n        return torch.npu.FloatTensor\n\n    @property\n    def HalfTensor(self):\n        return torch.npu.HalfTensor\n\n    @property\n    def IntTensor(self):\n        return torch.npu.IntTensor\n\n    @property\n    def LongTensor(self):\n        return torch.npu.LongTensor\n\n    def pin_memory(self, tensor, align_bytes=1):\n        return tensor.pin_memory()\n\n    def is_pinned(self, tensor):\n        return tensor.is_pinned()\n\n    def on_accelerator(self, tensor):\n        device_str = str(tensor.device)\n        if device_str.startswith('npu:'):\n            return True\n        else:\n            return False\n\n    def op_builder_dir(self):\n        try:\n            # is op_builder from deepspeed or a 3p version? this should only succeed if it's deepspeed\n            # if successful this also means we're doing a local install and not JIT compile path\n            from op_builder import __deepspeed__  # noqa: F401 # type: ignore\n            return \"op_builder.npu\"\n        except ImportError:\n            return \"deepspeed.ops.op_builder.npu\"\n\n    def _lazy_init_class_dict(self):\n        if self.class_dict:\n            return\n\n        op_builder_module = importlib.import_module(self.op_builder_dir())\n\n        # get op builder class from op_builder/npu/__init__.py\n        self.class_dict = {}\n        for class_name, class_obj in inspect.getmembers(op_builder_module, inspect.isclass):\n            self.class_dict[class_name] = class_obj\n\n    # create an instance of op builder and return, name specified by class_name\n    def create_op_builder(self, class_name):\n        builder_class = self.get_op_builder(class_name)\n        return None if builder_class is None else builder_class()\n\n    # return an op builder class, name specified by class_name\n    def get_op_builder(self, class_name):\n        self._lazy_init_class_dict()\n        if class_name in self.class_dict:\n            return self.class_dict[class_name]\n        else:\n            return self.class_dict['NotImplementedBuilder'] if 'NotImplementedBuilder' in self.class_dict else None\n\n    def build_extension(self):\n        from torch.utils.cpp_extension import BuildExtension\n        return BuildExtension\n\n    def export_envs(self):\n        return ['ASCEND', 'HCCL', 'LD_LIBRARY', 'PATH']\n\n    def visible_devices_envs(self):\n        return ['ASCEND_RT_VISIBLE_DEVICES']\n\n    def set_visible_devices_envs(self, current_env, local_accelerator_ids):\n        for env in self.visible_devices_envs():\n            current_env[env] = \",\".join(map(str, local_accelerator_ids))\n\n    def get_compile_backend(self):\n        return self._compile_backend\n\n    def set_compile_backend(self, backend):\n        supported_backends = torch._dynamo.list_backends(exclude_tags=())\n        if backend in supported_backends:\n            self._compile_backend = backend\n        else:\n            raise ValueError(\n                f\"{backend} not supported by {self.device_name()}. Supported Backends are {supported_backends }\")\n", "file_name": "181714.py", "cwe": ["CWE-706: Use of Incorrectly-Resolved Name or Reference"]}
{"source": "# Copyright (c) Microsoft Corporation.\n# SPDX-License-Identifier: Apache-2.0\n\n# DeepSpeed Team\n\nimport torch\nfrom deepspeed.accelerator.abstract_accelerator import DeepSpeedAccelerator\nimport intel_extension_for_pytorch as ipex  # noqa: F401 # type: ignore\nimport oneccl_bindings_for_pytorch  # noqa: F401 # type: ignore\nimport functools\n\nimport importlib\nimport inspect\n\n\nclass XPU_Accelerator(DeepSpeedAccelerator):\n\n    def __init__(self):\n        self._name = 'xpu'\n        self._communication_backend_name = 'ccl'\n        self._compile_backend = \"inductor\"\n        self.aligned_tensors = []\n        self.class_dict = None\n\n    def is_synchronized_device(self):\n        return False\n\n    def use_host_timers(self):\n        # WA XPU event will be consolidated in 2.5\n        if ipex.__version__ < '2.5':\n            return True\n        else:\n            return self.is_synchronized_device()\n\n    def resolves_data_dependency(self):\n        return self.is_synchronized_device()\n\n    def handles_memory_backpressure(self):\n        return self.is_synchronized_device()\n\n    # Device APIs\n    def device_name(self, device_index=None):\n        if device_index == None:\n            return 'xpu'\n        return 'xpu:{}'.format(device_index)\n\n    def device(self, device_index=None):\n        return torch.xpu.device(device_index)\n\n    def set_device(self, device_index):\n        torch.xpu.set_device(device_index)\n\n    def current_device(self):\n        return torch.xpu.current_device()\n\n    def current_device_name(self):\n        return 'xpu:{}'.format(torch.xpu.current_device())\n\n    def device_count(self):\n        return torch.xpu.device_count()\n\n    def synchronize(self, device_index=None):\n        return torch.xpu.synchronize(device_index)\n\n    # RNG APIs\n    def random(self):\n        return torch.xpu.random\n\n    def set_rng_state(self, new_state, device_index=None):\n        if device_index == None:\n            return torch.xpu.set_rng_state(new_state)\n        return torch.xpu.set_rng_state(new_state, device_index)\n\n    def get_rng_state(self, device_index=None):\n        if device_index == None:\n            return torch.xpu.get_rng_state()\n        return torch.xpu.get_rng_state(device_index)\n\n    def manual_seed(self, seed):\n        return torch.xpu.manual_seed(seed)\n\n    def manual_seed_all(self, seed):\n        return torch.xpu.manual_seed_all(seed)\n\n    def initial_seed(self):\n        return torch.xpu.initial_seed()\n\n    def default_generator(self, device_index):\n        return torch.xpu.default_generators[device_index]\n\n    # Streams/Events\n    @property\n    def Stream(self):\n        return torch.xpu.Stream\n\n    def stream(self, stream):\n        return torch.xpu.stream(stream)\n\n    def current_stream(self, device_index=None):\n        return torch.xpu.current_stream(device_index)\n\n    def default_stream(self, device_index=None):\n        # torch.xpu does not support the sync behavior of default stream as cuda\n        # use current_stream as workaround\n        # see https://pytorch.org/docs/stable/notes/cuda.html#cuda-streams\n        return torch.xpu.current_stream(device_index)\n\n    @property\n    def Event(self):\n        return torch.xpu.Event\n\n    # Memory management\n    def empty_cache(self):\n        return torch.xpu.empty_cache()\n\n    def memory_allocated(self, device_index=None):\n        return torch.xpu.memory_allocated(device_index)\n\n    def max_memory_allocated(self, device_index=None):\n        return torch.xpu.max_memory_allocated(device_index)\n\n    def reset_max_memory_allocated(self, device_index=None):\n        return torch.xpu.reset_max_memory_allocated(device_index)\n\n    def memory_cached(self, device_index=None):\n        return torch.xpu.memory_reserved(device_index)\n\n    def max_memory_cached(self, device_index=None):\n        return torch.xpu.max_memory_reserved(device_index)\n\n    def reset_max_memory_cached(self, device_index=None):\n        return torch.xpu.reset_max_memory_reserved(device_index)\n\n    def memory_stats(self, device_index=None):\n        return torch.xpu.memory_stats(device_index)\n\n    def reset_peak_memory_stats(self, device_index=None):\n        return torch.xpu.reset_peak_memory_stats(device_index)\n\n    def memory_reserved(self, device_index=None):\n        return torch.xpu.memory_reserved(device_index)\n\n    def max_memory_reserved(self, device_index=None):\n        return torch.xpu.max_memory_reserved(device_index)\n\n    def total_memory(self, device_index=None):\n        return torch.xpu.get_device_properties(device_index).total_memory\n\n    def available_memory(self, device_index=None):\n        return self.total_memory(device_index) - self.memory_allocated(device_index)\n\n    # Misc\n    def amp(self):\n        return torch.xpu.amp\n\n    def is_available(self):\n        return torch.xpu.is_available()\n\n    def range_push(self, msg):\n        # TODO itt is currently not supported yet\n        # return torch.profiler.itt.range_push(msg)\n        return\n\n    def range_pop(self):\n        # TODO itt is currently not supported yet\n        # return torch.profiler.itt.range_pop()\n        return\n\n    def lazy_call(self, callback):\n        if hasattr(torch.xpu, \"_lazy_call\"):\n            return torch.xpu._lazy_call(callback)\n        else:\n            return torch.xpu.lazy_init._lazy_call(callback)\n\n    def communication_backend_name(self):\n        return self._communication_backend_name\n\n    def is_triton_supported(self):\n        return False\n\n    # Graph operations\n    def create_graph(self):\n        return None\n\n    def capture_to_graph(self, graph, pool=None, stream=None):\n        from deepspeed.runtime.utils import noop_context\n        return noop_context()\n\n    def replay_graph(self, graph):\n        return\n\n    # Data types\n    def is_bf16_supported(self):\n        return True\n\n    def is_fp16_supported(self):\n        return True\n\n    def supported_dtypes(self):\n        return [torch.float, torch.half, torch.bfloat16]\n\n    # Tensor operations\n\n    @property\n    def BFloat16Tensor(self):\n        return functools.partial(torch.tensor, dtype=torch.bfloat16, device=self._name)\n\n    @property\n    def ByteTensor(self):\n        return functools.partial(torch.tensor, dtype=torch.uint8, device=self._name)\n\n    @property\n    def DoubleTensor(self):\n        return functools.partial(torch.tensor, dtype=torch.double, device=self._name)\n\n    @property\n    def FloatTensor(self):\n        return functools.partial(torch.tensor, dtype=torch.float, device=self._name)\n\n    @property\n    def HalfTensor(self):\n        return functools.partial(torch.tensor, dtype=torch.half, device=self._name)\n\n    @property\n    def IntTensor(self):\n        return functools.partial(torch.tensor, dtype=torch.int, device=self._name)\n\n    @property\n    def LongTensor(self):\n        return functools.partial(torch.tensor, dtype=torch.long, device=self._name)\n\n    def pin_memory(self, tensor, align_bytes=1):\n        if align_bytes == 1:\n            return tensor.pin_memory(device=self.current_device_name())\n        elif align_bytes == 0:\n            from deepspeed.ops.op_builder.xpu import AsyncIOBuilder\n            self.aio_handle = AsyncIOBuilder().load().aio_handle(128 * 1024, 8, False, False, False)\n            aligned_t = self.aio_handle.new_cpu_locked_tensor(tensor.numel(), tensor)\n            aligned_t = aligned_t[:tensor.numel()].copy_(tensor)\n            self.aligned_tensors.append([aligned_t.data_ptr(), aligned_t[-1].data_ptr()])\n            return aligned_t\n\n    def is_pinned(self, tensor):\n        if tensor.is_pinned(device=self.current_device_name()):\n            return True\n        else:\n            for begin, end in self.aligned_tensors:\n                if begin <= tensor.data_ptr() and tensor.data_ptr() <= end:\n                    return True\n        return False\n\n    def op_builder_dir(self):\n        try:\n            # is op_builder from deepspeed or a 3p version? this should only succeed if it's deepspeed\n            # if successful this also means we're doing a local install and not JIT compile path\n            from op_builder import __deepspeed__  # noqa: F401 # type: ignore\n            return \"op_builder.xpu\"\n        except ImportError:\n            return \"deepspeed.ops.op_builder.xpu\"\n\n    def on_accelerator(self, tensor):\n        device_str = str(tensor.device)\n        if device_str.startswith('xpu:'):\n            return True\n        else:\n            return False\n\n    def _lazy_init_class_dict(self):\n        if self.class_dict:\n            return\n\n        op_builder_module = importlib.import_module(self.op_builder_dir())\n\n        # get op builder class from op_builder/xpu/__init__.py\n        self.class_dict = {}\n        for class_name, class_obj in inspect.getmembers(op_builder_module, inspect.isclass):\n            self.class_dict[class_name] = class_obj\n\n    # create an instance of op builder and return, name specified by class_name\n    def create_op_builder(self, class_name):\n        builder_class = self.get_op_builder(class_name)\n        return builder_class()\n\n    # return an op builder class, name specified by class_name\n    def get_op_builder(self, class_name):\n        self._lazy_init_class_dict()\n        if class_name in self.class_dict:\n            return self.class_dict[class_name]\n        else:\n            return self.class_dict['NotImplementedBuilder']\n\n    def build_extension(self):\n        try:\n            from intel_extension_for_pytorch.xpu.cpp_extension import DpcppBuildExtension\n        except ImportError:\n            from intel_extension_for_pytorch.xpu.utils import DpcppBuildExtension\n        return DpcppBuildExtension\n\n    def export_envs(self):\n        return []\n\n    def visible_devices_envs(self):\n        return ['ZE_AFFINITY_MASK']\n\n    def set_visible_devices_envs(self, current_env, local_accelerator_ids):\n        for env in self.visible_devices_envs():\n            current_env[env] = \",\".join(map(str, local_accelerator_ids))\n\n    def get_compile_backend(self):\n        return self._compile_backend\n\n    def set_compile_backend(self, backend):\n        supported_backends = torch._dynamo.list_backends(exclude_tags=())\n        if backend in supported_backends:\n            self._compile_backend = backend\n        else:\n            raise ValueError(\n                f\"{backend} not supported by {self.device_name()}. Supported Backends are {supported_backends}\")\n", "file_name": "190570.py", "cwe": ["CWE-706: Use of Incorrectly-Resolved Name or Reference"]}
{"source": "# Copyright (c) Microsoft Corporation.\n# SPDX-License-Identifier: Apache-2.0\n\n# DeepSpeed Team\n\nimport os\nimport re\nimport torch\nimport types\nfrom typing import List, Tuple, Union\nfrom dataclasses import dataclass\nfrom .constants import (FP32_WEIGHT_KEY, PARAM, VOCAB_TENSOR, CAT_DIM, PARAM_N_SUB_PARAMS, SUB_PARAM_SHAPE)\n\n\n@dataclass\nclass SubparamShape:\n    patterns: List[str]\n    shape: Tuple[Union[Tuple[int], int]]\n    partition_dim: int\n\n\ndef load_hp_checkpoint_state(self, folder, tp_rank, tp_world_size):\n    hp_mapping = self._hp_mapping\n    hp_mapping.optim_fragment = {}\n\n    hp_keys = []\n    for file in os.listdir(folder):\n        # We expect files named something like \"exp_avg.pt\", \"exp_avg_sq.pt\", \"fp32.pt\"\n        pattern = r'(.+).pt'\n        match = re.search(pattern, file)\n        if match:\n            hp_keys.append(match.group(1))\n\n    step = None\n    for key in hp_keys:\n        ckpt_file = os.path.join(folder, f\"{key}.pt\")\n        ckpt_dict = torch.load(ckpt_file)\n\n        if key == \"step\":\n            step = ckpt_dict\n            continue\n\n        full_hp_param = ckpt_dict[PARAM]\n\n        # need to deal with slices that were averaged.\n        # the opposite of averaging here becomes an exact copy of the first slice\n        # I thought of 2 ways:\n        # implementation a. find a way for a client to pass a dict with patterns\n        # if any(re.search(pattern, folder) for pattern in WEIGHTS_TO_AVERAGE_PATTERNS):\n        #     tp_rank = 0\n        #     tp_world_size = 1\n        # the other approach is to assume that the saved data is correct and if full_hp_param.shape ==\n        # self.shape that means we automatically copy?\n        # implementation b.\n        # this version requires no additional data passed from the client\n        # if the shapes already match it must be slices that were averaged - so we just hack around those\n        if full_hp_param.shape == self.shape:\n            tp_rank = 0\n            tp_world_size = 1\n\n        # special case for word_embeddings weights which get padded differently depending on TP degree.\n        # the converter to universal currently strips the original padding completely so the saved\n        # weight is padding-free and we just need to add new padding depending on the target TP\n        # degree\n        is_vocab_tensor = ckpt_dict.get(VOCAB_TENSOR, False)\n        if is_vocab_tensor:\n            # In the absence of data passed from the user wrt new padded vocab specific to tp degree\n            # we can again derive that data by reverse engineering the target shapes like so:\n            padded_target_vocab_size = self.shape[0] * tp_world_size\n            assert padded_target_vocab_size >= full_hp_param.shape[0], \\\n                f'Vocab tensor padded size {padded_target_vocab_size} < loaded universal size {full_hp_param.shape[0]}'\n            if padded_target_vocab_size > full_hp_param.shape[0]:\n                padding_size = padded_target_vocab_size - full_hp_param.shape[0]\n                full_hp_param = torch.nn.functional.pad(full_hp_param, (0, 0, 0, padding_size), \"constant\", 0)\n\n        full_param_numel = full_hp_param.numel()\n        tp_slice_numel = self.numel()\n        #        if key == FP32_WEIGHT_KEY and 'word_embeddings.weight' in folder:\n        #            print_rank_0(f'{full_hp_param[:10]=}', force=True)\n\n\n        assert full_param_numel == tp_world_size * tp_slice_numel, \\\n            f'Loading {ckpt_file} full param numel {full_param_numel} != tensor slice numel {tp_slice_numel} * tp_world_size {tp_world_size}'\n\n        #        print(f\"{full_hp_param.shape=} {full_param_numel=} {folder=}\")\n        #        print(f\"{dst_tensor.shape=} {dst_tensor.numel()=}{folder=}\")\n\n        sub_param_shape = ckpt_dict.get(SUB_PARAM_SHAPE, None)\n        # since when we do many to 1 on tp we cat sometimes on dim=0 and other times on dim=1 we have to do exactly the same in reverse\n        # special case is when a single parameter is effectively a container for multiple sub parameters\n        # (more details at PARAM_N_SUB_PARAMS definition)\n        chunk_dim = ckpt_dict.get(CAT_DIM, 0)\n        n_sub_params = ckpt_dict.get(PARAM_N_SUB_PARAMS, 1)\n        if sub_param_shape:\n            partition_dim = sub_param_shape.partition_dim\n            sub_dim_sizes = sub_param_shape.shape[partition_dim]\n            if not isinstance(sub_dim_sizes, tuple):\n                sub_dim_sizes = (sub_dim_sizes, )\n\n            partition_shape = [sum(d) if isinstance(d, tuple) else d for d in sub_param_shape.shape]\n            full_hp_param = full_hp_param.view(partition_shape)\n\n            offset = 0\n            merged_chunks = []\n            for sub_dim_size in sub_dim_sizes:\n                sub_params_tp_slice = full_hp_param.narrow(partition_dim,\n                                                           offset, sub_dim_size).chunk(tp_world_size,\n                                                                                       dim=partition_dim)[tp_rank]\n                merged_chunks.append(sub_params_tp_slice)\n                offset += sub_dim_size\n            tp_hp_slice = torch.cat(merged_chunks, dim=partition_dim)\n\n        elif n_sub_params > 1:\n            sub_params = full_hp_param.chunk(n_sub_params, dim=chunk_dim)\n            sub_params_tp_slice = [p.chunk(tp_world_size, dim=chunk_dim)[tp_rank] for p in sub_params]\n            tp_hp_slice = torch.cat(sub_params_tp_slice, dim=chunk_dim)\n        else:\n            # this performs the opposite of cat when merging TP slices\n            tp_hp_slice = full_hp_param.chunk(tp_world_size, chunk_dim)[tp_rank]\n\n        tp_hp_slice = tp_hp_slice.flatten()\n\n        lp_frag_address = hp_mapping.lp_fragment_address\n        tp_hp_fragment = tp_hp_slice.narrow(0, lp_frag_address.start, lp_frag_address.numel)\n\n        #        print(f\"{key} SHAPE: {tp_hp_slice.shape=}\")\n        #        print(f\"{key} SHAPE: {dst_tensor.shape=}\")\n        #        print(f\"{key} SHAPE: {tp_hp_fragment.shape=}\")\n\n        if key == FP32_WEIGHT_KEY:\n            dst_tensor = hp_mapping.get_hp_fragment()\n            assert dst_tensor.numel() == lp_frag_address.numel, \\\n                f'Load checkpoint {key} dst numel {dst_tensor.numel()} != src numel {lp_frag_address.numel}'\n            dst_tensor.data.copy_(tp_hp_fragment.data)\n        else:\n            assert tp_hp_fragment.numel() == lp_frag_address.numel, \\\n                f'Load checkpoint {key} dst numel {tp_hp_fragment.numel()} != src numel {lp_frag_address.numel}'\n\n            hp_mapping.optim_fragment[key] = tp_hp_fragment.clone().detach()\n\n    return step\n\n\ndef enable_universal_checkpoint(param_list):\n    for param in param_list:\n        param.load_hp_checkpoint_state = types.MethodType(load_hp_checkpoint_state, param)\n", "file_name": "252141.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "from collections import Counter\nfrom typing import Union, List, Callable, Tuple\nimport torch\nimport penman\nfrom penman import Graph\nfrom hanlp.common.dataset import TransformableDataset\nfrom hanlp.components.amr.seq2seq.dataset.IO import read_raw_amr_data\nfrom hanlp.components.amr.seq2seq.dataset.penman import role_is_reverted\nfrom hanlp.components.amr.seq2seq.dataset.tokenization_bart import PENMANBartTokenizer\nfrom phrasetree.tree import Tree\nimport json\n\nfrom hanlp_common.constant import BOS, EOS, ROOT\nfrom hanlp_common.io import load_pickle\n\n\nclass AMRDataset(TransformableDataset):\n\n    def __init__(self,\n                 data: Union[str, List],\n                 use_recategorization=False,\n                 remove_wiki=False,\n                 dereify=False,\n                 transform: Union[Callable, List] = None,\n                 cache=None,\n                 generate_idx=None) -> None:\n        self.dereify = dereify\n        self.remove_wiki = remove_wiki\n        self.use_recategorization = use_recategorization\n        super().__init__(data, transform, cache, generate_idx)\n\n    def load_file(self, filepath: str):\n        graphs = read_raw_amr_data([filepath], self.use_recategorization, remove_wiki=self.remove_wiki,\n                                   dereify=self.dereify)\n        for g in graphs:\n            yield {'amr': g}\n\n    def get_roles(self):\n        roles = Counter()\n        for sample in self.data:\n            g: Graph = sample['amr']\n            for s, r, t in g.triples:\n                if role_is_reverted(r):\n                    r = r[:-3]\n                roles[r] += 1\n        return roles\n\n    def get_frames(self):\n        frames = Counter()\n        for sample in self.data:\n            g: Graph = sample['amr']\n            for i in g.instances():\n                t = i.target\n                cells = t.split('-')\n                if len(cells) == 2 and len(cells[1]) == 2 and cells[1].isdigit():\n                    frames[t] += 1\n        return frames\n\n\nclass AMRPickleDataset(AMRDataset):\n\n    def load_file(self, filepath: str):\n        items = torch.load(filepath)\n        for each in items:\n            each['amr'] = penman.decode(each['amr'])\n            yield each\n\n\ndef dfs_linearize_tokenize(sample: dict, tokenizer: PENMANBartTokenizer, remove_space=False, text_key='snt') -> dict:\n    amr = sample.get('amr', None)\n    if amr:\n        l, e = tokenizer.linearize(amr)\n        sample['graph_tokens'] = e['linearized_graphs']\n        sample['graph_token_ids'] = l\n        text = amr.metadata[text_key]\n    else:\n        text = sample['text']\n    if remove_space:\n        text = ''.join(text.split())\n    sample['text'] = text\n    sample['text_token_ids'] = tokenizer.encode(text)\n    return sample\n\n\ndef dfs_linearize_levi(sample: dict, tokenizer: PENMANBartTokenizer, remove_space=False) -> dict:\n    amr = sample.get('amr', None)\n    if amr:\n        l, e = tokenizer.linearize(amr)\n        sample['graph_tokens'] = e['linearized_graphs']\n        sample['graph_token_ids'] = l\n        tok = json.loads(amr.metadata['tok'])\n        dep = json.loads(amr.metadata['dep'])\n        levi = dep_to_levi(tok, dep)\n        sample['text'] = ' '.join(levi)\n        # ids = sum(tokenizer.batch_encode_plus([' ' + x for x in levi], add_special_tokens=False).input_ids, [])\n        ids = []\n        idx = 0\n        for t in levi:\n            if t in ('(', ')'):\n                ids.append(tokenizer.convert_tokens_to_ids(tokenizer.INIT + t))\n            else:\n                if idx % 2:\n                    ids.extend(tokenizer.encode(t, add_special_tokens=False))\n                else:\n                    ids.append(tokenizer.convert_tokens_to_ids(tokenizer.INIT + t))\n                idx += 1\n        sample['text_token_ids'] = [tokenizer.bos_token_id] + ids + [tokenizer.eos_token_id]\n    return sample\n\n\ndef dfs_linearize_rgcn(sample: dict, tokenizer: PENMANBartTokenizer) -> dict:\n    amr = sample.get('amr', None)\n    if amr:\n        l, e = tokenizer.linearize(amr)\n        sample['graph_tokens'] = e['linearized_graphs']\n        sample['graph_token_ids'] = l\n        tok = sample['tok']\n        sample['text'] = [tokenizer.cls_token] + [' ' + x for x in tok]\n        arc_scores = sample['dep']['scores']['arc_scores']\n        rel_scores = sample['dep']['scores']['rel_scores']\n        dep_graph = arc_scores[:, :, None] * rel_scores\n        root = torch.zeros((1,) + dep_graph.shape[1:])\n        sample['dep_graph'] = torch.cat([root, dep_graph], dim=0)\n    return sample\n\n\ndef dfs_linearize_constituency(sample: dict, tokenizer: PENMANBartTokenizer, remove_space=False) -> dict:\n    amr = sample.get('amr', None)\n    if amr:\n        l, e = tokenizer.linearize(amr)\n        sample['graph_tokens'] = e['linearized_graphs']\n        sample['graph_token_ids'] = l\n        tree = Tree.from_list(json.loads(sample['amr'].metadata['con_list']))\n        for each in tree.subtrees(lambda x: x.height() == 2):\n            if each[0] == '(':\n                each[0] = '<LBR>'\n            elif each[0] == ')':\n                each[0] = '<RBR>'\n        text = tree.pformat(margin=10e7)\n        tokens = []\n        buffer = []\n        for c in text:\n            if c == '(' or c == ')':\n                tokens.append(''.join(buffer))\n                tokens.append(c)\n                buffer.clear()\n                continue\n            buffer.append(c)\n        if buffer:\n            tokens.append(''.join(buffer))\n        tokens = [x.strip() for x in tokens]\n        tokens = [x for x in tokens if x]\n        restore_bracket = {'<LBR>': '(', '<RBR>': ')'}\n        tokens = [restore_bracket.get(x, x) for x in tokens]\n        ids = []\n        for each in tokens:\n            pairs = each.split(' ', 1)\n            if len(pairs) == 2:\n                con, token = pairs\n                ids.append(tokenizer.convert_tokens_to_ids(tokenizer.INIT + con))\n                ids.extend(tokenizer.encode(token, add_special_tokens=False))\n            else:\n                ids.append(tokenizer.convert_tokens_to_ids(tokenizer.INIT + each))\n        if remove_space:\n            text = ''.join(text.split())\n        sample['text'] = text\n        sample['text_token_ids'] = [tokenizer.bos_token_id] + ids + [tokenizer.eos_token_id]\n    return sample\n\n\ndef dfs_linearize_tokenize_with_linguistic_structures(sample: dict, tokenizer: PENMANBartTokenizer,\n                                                      remove_space=False,\n                                                      text_key='snt') -> dict:\n    amr = sample.get('amr', None)\n    if amr:\n        l, e = tokenizer.linearize(amr)\n        sample['graph_tokens'] = e['linearized_graphs']\n        sample['graph_token_ids'] = l\n        text = amr.metadata[text_key]\n        if remove_space:\n            text = ''.join(text.split())\n        sample['text'] = text\n        tok = json.loads(amr.metadata['tok'])\n        text_token_ids = tokenizer.batch_encode_plus(tok, add_special_tokens=False).input_ids\n        sample['text_token_ids'] = [tokenizer.bos_token_id] + sum(text_token_ids, []) + [tokenizer.eos_token_id]\n        pos = amr.metadata.get('pos', None)\n        if pos:\n            flat_pos = []\n            pos = json.loads(pos)\n            for subtokens, tag in zip(text_token_ids, pos):\n                flat_pos.extend([tag] * len(subtokens))\n            sample['pos'] = [BOS] + flat_pos + [EOS]\n        ner = amr.metadata.get('ner', None)\n        if ner is not None:\n            flat_ner = []\n            ner_spans = json.loads(ner)\n            ner = ['O'] * len(text_token_ids)\n            for form, tag, start, end in ner_spans:\n                ner[start:end] = [tag] * (end - start)\n            for subtokens, tag in zip(text_token_ids, ner):\n                flat_ner.extend([tag] * len(subtokens))\n            sample['ner'] = [BOS] + flat_ner + [EOS]\n        dep = amr.metadata.get('dep', None)\n        if dep:\n            token_to_1st_subtoken = [0]\n            num_subtokens = 1  # 1 for BOS\n            for subtokens in text_token_ids:\n                token_to_1st_subtoken.append(num_subtokens)\n                num_subtokens += len(subtokens)\n            flat_arc, flat_rel = [0], [BOS]\n            dep = json.loads(dep)\n            for subtokens, (arc, rel) in zip(text_token_ids, dep):\n                flat_arc.extend([token_to_1st_subtoken[arc]] * len(subtokens))\n                flat_rel.extend([rel] * len(subtokens))\n            sample['dep_arc'] = flat_arc + [0]\n            sample['dep_rel'] = flat_rel + [EOS]\n    return sample\n\n\ndef dep_to_levi(tok: List[str], dep: List[Tuple[int, str]]):\n    root = [i for i, x in enumerate(dep) if x[0] == 0][0]\n    seq = []\n    dfs(tok, dep, root, seq)\n    return seq\n\n\ndef dfs(tok: List[str], dep: List[Tuple[int, str]], s, seq):\n    seq.append(dep[s][1])\n    seq.append(tok[s])\n    children = [i for i, x in enumerate(dep) if x[0] == s + 1]\n    if children:\n        seq.append('(')\n        for child in children:\n            dfs(tok, dep, child, seq)\n        seq.append(')')\n", "file_name": "310532.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "import os\nimport tempfile\nimport time\nimport requests\nfrom unittest import mock\nfrom urllib.request import urlopen\n\nimport pytest\nfrom requests.structures import CaseInsensitiveDict\n\nfrom httpie.downloads import (\n    parse_content_range, filename_from_content_disposition, filename_from_url,\n    get_unique_filename, ContentRangeError, Downloader, PARTIAL_CONTENT\n)\nfrom .utils import http, MockEnvironment\n\n\nclass Response(requests.Response):\n    # noinspection PyDefaultArgument\n    def __init__(self, url, headers={}, status_code=200):\n        self.url = url\n        self.headers = CaseInsensitiveDict(headers)\n        self.status_code = status_code\n\n\nclass TestDownloadUtils:\n\n    def test_Content_Range_parsing(self):\n        parse = parse_content_range\n\n        assert parse('bytes 100-199/200', 100) == 200\n        assert parse('bytes 100-199/*', 100) == 200\n\n        # single byte\n        assert parse('bytes 100-100/*', 100) == 101\n\n        # missing\n        pytest.raises(ContentRangeError, parse, None, 100)\n\n        # syntax error\n        pytest.raises(ContentRangeError, parse, 'beers 100-199/*', 100)\n\n        # unexpected range\n        pytest.raises(ContentRangeError, parse, 'bytes 100-199/*', 99)\n\n        # invalid instance-length\n        pytest.raises(ContentRangeError, parse, 'bytes 100-199/199', 100)\n\n        # invalid byte-range-resp-spec\n        pytest.raises(ContentRangeError, parse, 'bytes 100-99/199', 100)\n\n    @pytest.mark.parametrize('header, expected_filename', [\n        ('attachment; filename=hello-WORLD_123.txt', 'hello-WORLD_123.txt'),\n        ('attachment; filename=\".hello-WORLD_123.txt\"', 'hello-WORLD_123.txt'),\n        ('attachment; filename=\"white space.txt\"', 'white space.txt'),\n        (r'attachment; filename=\"\\\"quotes\\\".txt\"', '\"quotes\".txt'),\n        ('attachment; filename=/etc/hosts', 'hosts'),\n        ('attachment; filename=', None)\n    ])\n    def test_Content_Disposition_parsing(self, header, expected_filename):\n        assert filename_from_content_disposition(header) == expected_filename\n\n    def test_filename_from_url(self):\n        assert 'foo.txt' == filename_from_url(\n            url='http://example.org/foo',\n            content_type='text/plain'\n        )\n        assert 'foo.html' == filename_from_url(\n            url='http://example.org/foo',\n            content_type='text/html; charset=UTF-8'\n        )\n        assert 'foo' == filename_from_url(\n            url='http://example.org/foo',\n            content_type=None\n        )\n        assert 'foo' == filename_from_url(\n            url='http://example.org/foo',\n            content_type='x-foo/bar'\n        )\n\n    @pytest.mark.parametrize(\n        'orig_name, unique_on_attempt, expected',\n        [\n            # Simple\n            ('foo.bar', 0, 'foo.bar'),\n            ('foo.bar', 1, 'foo.bar-1'),\n            ('foo.bar', 10, 'foo.bar-10'),\n            # Trim\n            ('A' * 20, 0, 'A' * 10),\n            ('A' * 20, 1, 'A' * 8 + '-1'),\n            ('A' * 20, 10, 'A' * 7 + '-10'),\n            # Trim before ext\n            ('A' * 20 + '.txt', 0, 'A' * 6 + '.txt'),\n            ('A' * 20 + '.txt', 1, 'A' * 4 + '.txt-1'),\n            # Trim at the end\n            ('foo.' + 'A' * 20, 0, 'foo.' + 'A' * 6),\n            ('foo.' + 'A' * 20, 1, 'foo.' + 'A' * 4 + '-1'),\n            ('foo.' + 'A' * 20, 10, 'foo.' + 'A' * 3 + '-10'),\n        ]\n    )\n    @mock.patch('httpie.downloads.get_filename_max_length')\n    def test_unique_filename(self, get_filename_max_length,\n                             orig_name, unique_on_attempt,\n                             expected):\n\n        def attempts(unique_on_attempt=0):\n            # noinspection PyUnresolvedReferences,PyUnusedLocal\n            def exists(filename):\n                if exists.attempt == unique_on_attempt:\n                    return False\n                exists.attempt += 1\n                return True\n\n            exists.attempt = 0\n            return exists\n\n        get_filename_max_length.return_value = 10\n\n        actual = get_unique_filename(orig_name, attempts(unique_on_attempt))\n        assert expected == actual\n\n\nclass TestDownloads:\n\n    def test_actual_download(self, httpbin_both, httpbin):\n        robots_txt = '/robots.txt'\n        body = urlopen(httpbin + robots_txt).read().decode()\n        env = MockEnvironment(stdin_isatty=True, stdout_isatty=False, show_displays=True)\n        r = http('--download', httpbin_both.url + robots_txt, env=env)\n        assert 'Downloading' in r.stderr\n        assert body == r\n\n    def test_download_with_Content_Length(self, mock_env, httpbin_both):\n        with open(os.devnull, 'w') as devnull:\n            downloader = Downloader(mock_env, output_file=devnull)\n            downloader.start(\n                initial_url='/',\n                final_response=Response(\n                    url=httpbin_both.url + '/',\n                    headers={'Content-Length': 10}\n                )\n            )\n            time.sleep(1.1)\n            downloader.chunk_downloaded(b'12345')\n            time.sleep(1.1)\n            downloader.chunk_downloaded(b'12345')\n            downloader.finish()\n            assert not downloader.interrupted\n\n    def test_download_no_Content_Length(self, mock_env, httpbin_both):\n        with open(os.devnull, 'w') as devnull:\n            downloader = Downloader(mock_env, output_file=devnull)\n            downloader.start(\n                final_response=Response(url=httpbin_both.url + '/'),\n                initial_url='/'\n            )\n            time.sleep(1.1)\n            downloader.chunk_downloaded(b'12345')\n            downloader.finish()\n            assert not downloader.interrupted\n\n    def test_download_output_from_content_disposition(self, mock_env, httpbin_both):\n        with tempfile.TemporaryDirectory() as tmp_dirname:\n            orig_cwd = os.getcwd()\n            os.chdir(tmp_dirname)\n            try:\n                assert not os.path.isfile('filename.bin')\n                downloader = Downloader(mock_env)\n                downloader.start(\n                    final_response=Response(\n                        url=httpbin_both.url + '/',\n                        headers={\n                            'Content-Length': 5,\n                            'Content-Disposition': 'attachment; filename=\"filename.bin\"',\n                        }\n                    ),\n                    initial_url='/'\n                )\n                downloader.chunk_downloaded(b'12345')\n                downloader.finish()\n                downloader.failed()  # Stop the reporter\n                assert not downloader.interrupted\n\n                # TODO: Auto-close the file in that case?\n                downloader._output_file.close()\n                assert os.path.isfile('filename.bin')\n            finally:\n                os.chdir(orig_cwd)\n\n    def test_download_interrupted(self, mock_env, httpbin_both):\n        with open(os.devnull, 'w') as devnull:\n            downloader = Downloader(mock_env, output_file=devnull)\n            downloader.start(\n                final_response=Response(\n                    url=httpbin_both.url + '/',\n                    headers={'Content-Length': 5}\n                ),\n                initial_url='/'\n            )\n            downloader.chunk_downloaded(b'1234')\n            downloader.finish()\n            assert downloader.interrupted\n\n    def test_download_resumed(self, mock_env, httpbin_both):\n        with tempfile.TemporaryDirectory() as tmp_dirname:\n            file = os.path.join(tmp_dirname, 'file.bin')\n            with open(file, 'a'):\n                pass\n\n            with open(file, 'a+b') as output_file:\n                # Start and interrupt the transfer after 3 bytes written\n                downloader = Downloader(mock_env, output_file=output_file)\n                downloader.start(\n                    final_response=Response(\n                        url=httpbin_both.url + '/',\n                        headers={'Content-Length': 5}\n                    ),\n                    initial_url='/'\n                )\n                downloader.chunk_downloaded(b'123')\n                downloader.finish()\n                downloader.failed()\n                assert downloader.interrupted\n\n            # Write bytes\n            with open(file, 'wb') as fh:\n                fh.write(b'123')\n\n            with open(file, 'a+b') as output_file:\n                # Resume the transfer\n                downloader = Downloader(mock_env, output_file=output_file, resume=True)\n\n                # Ensure `pre_request()` is working as expected too\n                headers = {}\n                downloader.pre_request(headers)\n                assert headers['Accept-Encoding'] == 'identity'\n                assert headers['Range'] == 'bytes=3-'\n\n                downloader.start(\n                    final_response=Response(\n                        url=httpbin_both.url + '/',\n                        headers={'Content-Length': 5, 'Content-Range': 'bytes 3-4/5'},\n                        status_code=PARTIAL_CONTENT\n                    ),\n                    initial_url='/'\n                )\n                downloader.chunk_downloaded(b'45')\n                downloader.finish()\n\n    def test_download_with_redirect_original_url_used_for_filename(self, httpbin):\n        # Redirect from `/redirect/1` to `/get`.\n        expected_filename = '1.json'\n        orig_cwd = os.getcwd()\n        with tempfile.TemporaryDirectory() as tmp_dirname:\n            os.chdir(tmp_dirname)\n            try:\n                assert os.listdir('.') == []\n                http('--download', httpbin + '/redirect/1')\n                assert os.listdir('.') == [expected_filename]\n            finally:\n                os.chdir(orig_cwd)\n", "file_name": "087698.py", "cwe": ["CWE-939: Improper Authorization in Handler for Custom URL Scheme"]}
{"source": "#!/usr/bin/env python3\n\"\"\"Extract Mel spectrograms with teacher forcing.\"\"\"\n\nimport argparse\nimport os\n\nimport numpy as np\nimport torch\nfrom torch.utils.data import DataLoader\nfrom tqdm import tqdm\n\nfrom TTS.config import load_config\nfrom TTS.tts.datasets import TTSDataset, load_tts_samples\nfrom TTS.tts.models import setup_model\nfrom TTS.tts.utils.speakers import SpeakerManager\nfrom TTS.tts.utils.text.tokenizer import TTSTokenizer\nfrom TTS.utils.audio import AudioProcessor\nfrom TTS.utils.audio.numpy_transforms import quantize\nfrom TTS.utils.generic_utils import count_parameters\n\nuse_cuda = torch.cuda.is_available()\n\n\ndef setup_loader(ap, r, verbose=False):\n    tokenizer, _ = TTSTokenizer.init_from_config(c)\n    dataset = TTSDataset(\n        outputs_per_step=r,\n        compute_linear_spec=False,\n        samples=meta_data,\n        tokenizer=tokenizer,\n        ap=ap,\n        batch_group_size=0,\n        min_text_len=c.min_text_len,\n        max_text_len=c.max_text_len,\n        min_audio_len=c.min_audio_len,\n        max_audio_len=c.max_audio_len,\n        phoneme_cache_path=c.phoneme_cache_path,\n        precompute_num_workers=0,\n        use_noise_augment=False,\n        verbose=verbose,\n        speaker_id_mapping=speaker_manager.name_to_id if c.use_speaker_embedding else None,\n        d_vector_mapping=speaker_manager.embeddings if c.use_d_vector_file else None,\n    )\n\n    if c.use_phonemes and c.compute_input_seq_cache:\n        # precompute phonemes to have a better estimate of sequence lengths.\n        dataset.compute_input_seq(c.num_loader_workers)\n    dataset.preprocess_samples()\n\n    loader = DataLoader(\n        dataset,\n        batch_size=c.batch_size,\n        shuffle=False,\n        collate_fn=dataset.collate_fn,\n        drop_last=False,\n        sampler=None,\n        num_workers=c.num_loader_workers,\n        pin_memory=False,\n    )\n    return loader\n\n\ndef set_filename(wav_path, out_path):\n    wav_file = os.path.basename(wav_path)\n    file_name = wav_file.split(\".\")[0]\n    os.makedirs(os.path.join(out_path, \"quant\"), exist_ok=True)\n    os.makedirs(os.path.join(out_path, \"mel\"), exist_ok=True)\n    os.makedirs(os.path.join(out_path, \"wav_gl\"), exist_ok=True)\n    os.makedirs(os.path.join(out_path, \"wav\"), exist_ok=True)\n    wavq_path = os.path.join(out_path, \"quant\", file_name)\n    mel_path = os.path.join(out_path, \"mel\", file_name)\n    wav_gl_path = os.path.join(out_path, \"wav_gl\", file_name + \".wav\")\n    wav_path = os.path.join(out_path, \"wav\", file_name + \".wav\")\n    return file_name, wavq_path, mel_path, wav_gl_path, wav_path\n\n\ndef format_data(data):\n    # setup input data\n    text_input = data[\"token_id\"]\n    text_lengths = data[\"token_id_lengths\"]\n    mel_input = data[\"mel\"]\n    mel_lengths = data[\"mel_lengths\"]\n    item_idx = data[\"item_idxs\"]\n    d_vectors = data[\"d_vectors\"]\n    speaker_ids = data[\"speaker_ids\"]\n    attn_mask = data[\"attns\"]\n    avg_text_length = torch.mean(text_lengths.float())\n    avg_spec_length = torch.mean(mel_lengths.float())\n\n    # dispatch data to GPU\n    if use_cuda:\n        text_input = text_input.cuda(non_blocking=True)\n        text_lengths = text_lengths.cuda(non_blocking=True)\n        mel_input = mel_input.cuda(non_blocking=True)\n        mel_lengths = mel_lengths.cuda(non_blocking=True)\n        if speaker_ids is not None:\n            speaker_ids = speaker_ids.cuda(non_blocking=True)\n        if d_vectors is not None:\n            d_vectors = d_vectors.cuda(non_blocking=True)\n        if attn_mask is not None:\n            attn_mask = attn_mask.cuda(non_blocking=True)\n    return (\n        text_input,\n        text_lengths,\n        mel_input,\n        mel_lengths,\n        speaker_ids,\n        d_vectors,\n        avg_text_length,\n        avg_spec_length,\n        attn_mask,\n        item_idx,\n    )\n\n\n@torch.no_grad()\ndef inference(\n    model_name,\n    model,\n    ap,\n    text_input,\n    text_lengths,\n    mel_input,\n    mel_lengths,\n    speaker_ids=None,\n    d_vectors=None,\n):\n    if model_name == \"glow_tts\":\n        speaker_c = None\n        if speaker_ids is not None:\n            speaker_c = speaker_ids\n        elif d_vectors is not None:\n            speaker_c = d_vectors\n        outputs = model.inference_with_MAS(\n            text_input,\n            text_lengths,\n            mel_input,\n            mel_lengths,\n            aux_input={\"d_vectors\": speaker_c, \"speaker_ids\": speaker_ids},\n        )\n        model_output = outputs[\"model_outputs\"]\n        model_output = model_output.detach().cpu().numpy()\n\n    elif \"tacotron\" in model_name:\n        aux_input = {\"speaker_ids\": speaker_ids, \"d_vectors\": d_vectors}\n        outputs = model(text_input, text_lengths, mel_input, mel_lengths, aux_input)\n        postnet_outputs = outputs[\"model_outputs\"]\n        # normalize tacotron output\n        if model_name == \"tacotron\":\n            mel_specs = []\n            postnet_outputs = postnet_outputs.data.cpu().numpy()\n            for b in range(postnet_outputs.shape[0]):\n                postnet_output = postnet_outputs[b]\n                mel_specs.append(torch.FloatTensor(ap.out_linear_to_mel(postnet_output.T).T))\n            model_output = torch.stack(mel_specs).cpu().numpy()\n\n        elif model_name == \"tacotron2\":\n            model_output = postnet_outputs.detach().cpu().numpy()\n    return model_output\n\n\ndef extract_spectrograms(\n    data_loader, model, ap, output_path, quantize_bits=0, save_audio=False, debug=False, metada_name=\"metada.txt\"\n):\n    model.eval()\n    export_metadata = []\n    for _, data in tqdm(enumerate(data_loader), total=len(data_loader)):\n        # format data\n        (\n            text_input,\n            text_lengths,\n            mel_input,\n            mel_lengths,\n            speaker_ids,\n            d_vectors,\n            _,\n            _,\n            _,\n            item_idx,\n        ) = format_data(data)\n\n        model_output = inference(\n            c.model.lower(),\n            model,\n            ap,\n            text_input,\n            text_lengths,\n            mel_input,\n            mel_lengths,\n            speaker_ids,\n            d_vectors,\n        )\n\n        for idx in range(text_input.shape[0]):\n            wav_file_path = item_idx[idx]\n            wav = ap.load_wav(wav_file_path)\n            _, wavq_path, mel_path, wav_gl_path, wav_path = set_filename(wav_file_path, output_path)\n\n            # quantize and save wav\n            if quantize_bits > 0:\n                wavq = quantize(wav, quantize_bits)\n                np.save(wavq_path, wavq)\n\n            # save TTS mel\n            mel = model_output[idx]\n            mel_length = mel_lengths[idx]\n            mel = mel[:mel_length, :].T\n            np.save(mel_path, mel)\n\n            export_metadata.append([wav_file_path, mel_path])\n            if save_audio:\n                ap.save_wav(wav, wav_path)\n\n            if debug:\n                print(\"Audio for debug saved at:\", wav_gl_path)\n                wav = ap.inv_melspectrogram(mel)\n                ap.save_wav(wav, wav_gl_path)\n\n    with open(os.path.join(output_path, metada_name), \"w\", encoding=\"utf-8\") as f:\n        for data in export_metadata:\n            f.write(f\"{data[0]}|{data[1]+'.npy'}\\n\")\n\n\ndef main(args):  # pylint: disable=redefined-outer-name\n    # pylint: disable=global-variable-undefined\n    global meta_data, speaker_manager\n\n    # Audio processor\n    ap = AudioProcessor(**c.audio)\n\n    # load data instances\n    meta_data_train, meta_data_eval = load_tts_samples(\n        c.datasets, eval_split=args.eval, eval_split_max_size=c.eval_split_max_size, eval_split_size=c.eval_split_size\n    )\n\n    # use eval and training partitions\n    meta_data = meta_data_train + meta_data_eval\n\n    # init speaker manager\n    if c.use_speaker_embedding:\n        speaker_manager = SpeakerManager(data_items=meta_data)\n    elif c.use_d_vector_file:\n        speaker_manager = SpeakerManager(d_vectors_file_path=c.d_vector_file)\n    else:\n        speaker_manager = None\n\n    # setup model\n    model = setup_model(c)\n\n    # restore model\n    model.load_checkpoint(c, args.checkpoint_path, eval=True)\n\n    if use_cuda:\n        model.cuda()\n\n    num_params = count_parameters(model)\n    print(\"\\n > Model has {} parameters\".format(num_params), flush=True)\n    # set r\n    r = 1 if c.model.lower() == \"glow_tts\" else model.decoder.r\n    own_loader = setup_loader(ap, r, verbose=True)\n\n    extract_spectrograms(\n        own_loader,\n        model,\n        ap,\n        args.output_path,\n        quantize_bits=args.quantize_bits,\n        save_audio=args.save_audio,\n        debug=args.debug,\n        metada_name=\"metada.txt\",\n    )\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--config_path\", type=str, help=\"Path to config file for training.\", required=True)\n    parser.add_argument(\"--checkpoint_path\", type=str, help=\"Model file to be restored.\", required=True)\n    parser.add_argument(\"--output_path\", type=str, help=\"Path to save mel specs\", required=True)\n    parser.add_argument(\"--debug\", default=False, action=\"store_true\", help=\"Save audio files for debug\")\n    parser.add_argument(\"--save_audio\", default=False, action=\"store_true\", help=\"Save audio files\")\n    parser.add_argument(\"--quantize_bits\", type=int, default=0, help=\"Save quantized audio files if non-zero\")\n    parser.add_argument(\"--eval\", type=bool, help=\"compute eval.\", default=True)\n    args = parser.parse_args()\n\n    c = load_config(args.config_path)\n    c.audio.trim_silence = False\n    main(args)\n", "file_name": "614629.py", "cwe": ["CWE-676: Use of Potentially Dangerous Function"]}
{"source": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport os\nimport sys\nimport time\nimport traceback\n\nimport torch\nfrom torch.utils.data import DataLoader\nfrom trainer.io import copy_model_files, save_best_model, save_checkpoint\nfrom trainer.torch import NoamLR\nfrom trainer.trainer_utils import get_optimizer\n\nfrom TTS.encoder.dataset import EncoderDataset\nfrom TTS.encoder.utils.generic_utils import setup_encoder_model\nfrom TTS.encoder.utils.training import init_training\nfrom TTS.encoder.utils.visual import plot_embeddings\nfrom TTS.tts.datasets import load_tts_samples\nfrom TTS.utils.audio import AudioProcessor\nfrom TTS.utils.generic_utils import count_parameters, remove_experiment_folder\nfrom TTS.utils.samplers import PerfectBatchSampler\nfrom TTS.utils.training import check_update\n\ntorch.backends.cudnn.enabled = True\ntorch.backends.cudnn.benchmark = True\ntorch.manual_seed(54321)\nuse_cuda = torch.cuda.is_available()\nnum_gpus = torch.cuda.device_count()\nprint(\" > Using CUDA: \", use_cuda)\nprint(\" > Number of GPUs: \", num_gpus)\n\n\ndef setup_loader(ap: AudioProcessor, is_val: bool = False, verbose: bool = False):\n    num_utter_per_class = c.num_utter_per_class if not is_val else c.eval_num_utter_per_class\n    num_classes_in_batch = c.num_classes_in_batch if not is_val else c.eval_num_classes_in_batch\n\n    dataset = EncoderDataset(\n        c,\n        ap,\n        meta_data_eval if is_val else meta_data_train,\n        voice_len=c.voice_len,\n        num_utter_per_class=num_utter_per_class,\n        num_classes_in_batch=num_classes_in_batch,\n        verbose=verbose,\n        augmentation_config=c.audio_augmentation if not is_val else None,\n        use_torch_spec=c.model_params.get(\"use_torch_spec\", False),\n    )\n    # get classes list\n    classes = dataset.get_class_list()\n\n    sampler = PerfectBatchSampler(\n        dataset.items,\n        classes,\n        batch_size=num_classes_in_batch * num_utter_per_class,  # total batch size\n        num_classes_in_batch=num_classes_in_batch,\n        num_gpus=1,\n        shuffle=not is_val,\n        drop_last=True,\n    )\n\n    if len(classes) < num_classes_in_batch:\n        if is_val:\n            raise RuntimeError(\n                f\"config.eval_num_classes_in_batch ({num_classes_in_batch}) need to be <= {len(classes)} (Number total of Classes in the Eval dataset) !\"\n            )\n        raise RuntimeError(\n            f\"config.num_classes_in_batch ({num_classes_in_batch}) need to be <= {len(classes)} (Number total of Classes in the Train dataset) !\"\n        )\n\n    # set the classes to avoid get wrong class_id when the number of training and eval classes are not equal\n    if is_val:\n        dataset.set_classes(train_classes)\n\n    loader = DataLoader(\n        dataset,\n        num_workers=c.num_loader_workers,\n        batch_sampler=sampler,\n        collate_fn=dataset.collate_fn,\n    )\n\n    return loader, classes, dataset.get_map_classid_to_classname()\n\n\ndef evaluation(model, criterion, data_loader, global_step):\n    eval_loss = 0\n    for _, data in enumerate(data_loader):\n        with torch.no_grad():\n            # setup input data\n            inputs, labels = data\n\n            # agroup samples of each class in the batch. perfect sampler produces [3,2,1,3,2,1] we need [3,3,2,2,1,1]\n            labels = torch.transpose(\n                labels.view(c.eval_num_utter_per_class, c.eval_num_classes_in_batch), 0, 1\n            ).reshape(labels.shape)\n            inputs = torch.transpose(\n                inputs.view(c.eval_num_utter_per_class, c.eval_num_classes_in_batch, -1), 0, 1\n            ).reshape(inputs.shape)\n\n            # dispatch data to GPU\n            if use_cuda:\n                inputs = inputs.cuda(non_blocking=True)\n                labels = labels.cuda(non_blocking=True)\n\n            # forward pass model\n            outputs = model(inputs)\n\n            # loss computation\n            loss = criterion(\n                outputs.view(c.eval_num_classes_in_batch, outputs.shape[0] // c.eval_num_classes_in_batch, -1), labels\n            )\n\n            eval_loss += loss.item()\n\n    eval_avg_loss = eval_loss / len(data_loader)\n    # save stats\n    dashboard_logger.eval_stats(global_step, {\"loss\": eval_avg_loss})\n    # plot the last batch in the evaluation\n    figures = {\n        \"UMAP Plot\": plot_embeddings(outputs.detach().cpu().numpy(), c.num_classes_in_batch),\n    }\n    dashboard_logger.eval_figures(global_step, figures)\n    return eval_avg_loss\n\n\ndef train(model, optimizer, scheduler, criterion, data_loader, eval_data_loader, global_step):\n    model.train()\n    best_loss = {\"train_loss\": None, \"eval_loss\": float(\"inf\")}\n    avg_loader_time = 0\n    end_time = time.time()\n    for epoch in range(c.epochs):\n        tot_loss = 0\n        epoch_time = 0\n        for _, data in enumerate(data_loader):\n            start_time = time.time()\n\n            # setup input data\n            inputs, labels = data\n            # agroup samples of each class in the batch. perfect sampler produces [3,2,1,3,2,1] we need [3,3,2,2,1,1]\n            labels = torch.transpose(labels.view(c.num_utter_per_class, c.num_classes_in_batch), 0, 1).reshape(\n                labels.shape\n            )\n            inputs = torch.transpose(inputs.view(c.num_utter_per_class, c.num_classes_in_batch, -1), 0, 1).reshape(\n                inputs.shape\n            )\n            # ToDo: move it to a unit test\n            # labels_converted = torch.transpose(labels.view(c.num_utter_per_class, c.num_classes_in_batch), 0, 1).reshape(labels.shape)\n            # inputs_converted = torch.transpose(inputs.view(c.num_utter_per_class, c.num_classes_in_batch, -1), 0, 1).reshape(inputs.shape)\n            # idx = 0\n            # for j in range(0, c.num_classes_in_batch, 1):\n            #     for i in range(j, len(labels), c.num_classes_in_batch):\n            #         if not torch.all(labels[i].eq(labels_converted[idx])) or not torch.all(inputs[i].eq(inputs_converted[idx])):\n            #             print(\"Invalid\")\n            #             print(labels)\n            #             exit()\n            #         idx += 1\n            # labels = labels_converted\n            # inputs = inputs_converted\n\n            loader_time = time.time() - end_time\n            global_step += 1\n\n            # setup lr\n            if c.lr_decay:\n                scheduler.step()\n            optimizer.zero_grad()\n\n            # dispatch data to GPU\n            if use_cuda:\n                inputs = inputs.cuda(non_blocking=True)\n                labels = labels.cuda(non_blocking=True)\n\n            # forward pass model\n            outputs = model(inputs)\n\n            # loss computation\n            loss = criterion(\n                outputs.view(c.num_classes_in_batch, outputs.shape[0] // c.num_classes_in_batch, -1), labels\n            )\n            loss.backward()\n            grad_norm, _ = check_update(model, c.grad_clip)\n            optimizer.step()\n\n            step_time = time.time() - start_time\n            epoch_time += step_time\n\n            # acumulate the total epoch loss\n            tot_loss += loss.item()\n\n            # Averaged Loader Time\n            num_loader_workers = c.num_loader_workers if c.num_loader_workers > 0 else 1\n            avg_loader_time = (\n                1 / num_loader_workers * loader_time + (num_loader_workers - 1) / num_loader_workers * avg_loader_time\n                if avg_loader_time != 0\n                else loader_time\n            )\n            current_lr = optimizer.param_groups[0][\"lr\"]\n\n            if global_step % c.steps_plot_stats == 0:\n                # Plot Training Epoch Stats\n                train_stats = {\n                    \"loss\": loss.item(),\n                    \"lr\": current_lr,\n                    \"grad_norm\": grad_norm,\n                    \"step_time\": step_time,\n                    \"avg_loader_time\": avg_loader_time,\n                }\n                dashboard_logger.train_epoch_stats(global_step, train_stats)\n                figures = {\n                    \"UMAP Plot\": plot_embeddings(outputs.detach().cpu().numpy(), c.num_classes_in_batch),\n                }\n                dashboard_logger.train_figures(global_step, figures)\n\n            if global_step % c.print_step == 0:\n                print(\n                    \"   | > Step:{}  Loss:{:.5f}  GradNorm:{:.5f}  \"\n                    \"StepTime:{:.2f}  LoaderTime:{:.2f}  AvGLoaderTime:{:.2f}  LR:{:.6f}\".format(\n                        global_step, loss.item(), grad_norm, step_time, loader_time, avg_loader_time, current_lr\n                    ),\n                    flush=True,\n                )\n\n            if global_step % c.save_step == 0:\n                # save model\n                save_checkpoint(\n                    c, model, optimizer, None, global_step, epoch, OUT_PATH, criterion=criterion.state_dict()\n                )\n\n            end_time = time.time()\n\n        print(\"\")\n        print(\n            \">>> Epoch:{}  AvgLoss: {:.5f} GradNorm:{:.5f}  \"\n            \"EpochTime:{:.2f} AvGLoaderTime:{:.2f} \".format(\n                epoch, tot_loss / len(data_loader), grad_norm, epoch_time, avg_loader_time\n            ),\n            flush=True,\n        )\n        # evaluation\n        if c.run_eval:\n            model.eval()\n            eval_loss = evaluation(model, criterion, eval_data_loader, global_step)\n            print(\"\\n\\n\")\n            print(\"--> EVAL PERFORMANCE\")\n            print(\n                \"   | > Epoch:{}  AvgLoss: {:.5f} \".format(epoch, eval_loss),\n                flush=True,\n            )\n            # save the best checkpoint\n            best_loss = save_best_model(\n                {\"train_loss\": None, \"eval_loss\": eval_loss},\n                best_loss,\n                c,\n                model,\n                optimizer,\n                None,\n                global_step,\n                epoch,\n                OUT_PATH,\n                criterion=criterion.state_dict(),\n            )\n            model.train()\n\n    return best_loss, global_step\n\n\ndef main(args):  # pylint: disable=redefined-outer-name\n    # pylint: disable=global-variable-undefined\n    global meta_data_train\n    global meta_data_eval\n    global train_classes\n\n    ap = AudioProcessor(**c.audio)\n    model = setup_encoder_model(c)\n\n    optimizer = get_optimizer(c.optimizer, c.optimizer_params, c.lr, model)\n\n    # pylint: disable=redefined-outer-name\n    meta_data_train, meta_data_eval = load_tts_samples(c.datasets, eval_split=True)\n\n    train_data_loader, train_classes, map_classid_to_classname = setup_loader(ap, is_val=False, verbose=True)\n    if c.run_eval:\n        eval_data_loader, _, _ = setup_loader(ap, is_val=True, verbose=True)\n    else:\n        eval_data_loader = None\n\n    num_classes = len(train_classes)\n    criterion = model.get_criterion(c, num_classes)\n\n    if c.loss == \"softmaxproto\" and c.model != \"speaker_encoder\":\n        c.map_classid_to_classname = map_classid_to_classname\n        copy_model_files(c, OUT_PATH, new_fields={})\n\n    if args.restore_path:\n        criterion, args.restore_step = model.load_checkpoint(\n            c, args.restore_path, eval=False, use_cuda=use_cuda, criterion=criterion\n        )\n        print(\" > Model restored from step %d\" % args.restore_step, flush=True)\n    else:\n        args.restore_step = 0\n\n    if c.lr_decay:\n        scheduler = NoamLR(optimizer, warmup_steps=c.warmup_steps, last_epoch=args.restore_step - 1)\n    else:\n        scheduler = None\n\n    num_params = count_parameters(model)\n    print(\"\\n > Model has {} parameters\".format(num_params), flush=True)\n\n    if use_cuda:\n        model = model.cuda()\n        criterion.cuda()\n\n    global_step = args.restore_step\n    _, global_step = train(model, optimizer, scheduler, criterion, train_data_loader, eval_data_loader, global_step)\n\n\nif __name__ == \"__main__\":\n    args, c, OUT_PATH, AUDIO_PATH, c_logger, dashboard_logger = init_training()\n\n    try:\n        main(args)\n    except KeyboardInterrupt:\n        remove_experiment_folder(OUT_PATH)\n        try:\n            sys.exit(0)\n        except SystemExit:\n            os._exit(0)  # pylint: disable=protected-access\n    except Exception:  # pylint: disable=broad-except\n        remove_experiment_folder(OUT_PATH)\n        traceback.print_exc()\n        sys.exit(1)\n", "file_name": "588795.py", "cwe": ["CWE-676: Use of Potentially Dangerous Function"]}
{"source": "import os\nfrom glob import glob\nfrom typing import Dict, List\n\nimport librosa\nimport numpy as np\nimport torch\nimport torchaudio\nfrom scipy.io.wavfile import read\n\nfrom TTS.utils.audio.torch_transforms import TorchSTFT\n\n\ndef load_wav_to_torch(full_path):\n    sampling_rate, data = read(full_path)\n    if data.dtype == np.int32:\n        norm_fix = 2**31\n    elif data.dtype == np.int16:\n        norm_fix = 2**15\n    elif data.dtype == np.float16 or data.dtype == np.float32:\n        norm_fix = 1.0\n    else:\n        raise NotImplementedError(f\"Provided data dtype not supported: {data.dtype}\")\n    return (torch.FloatTensor(data.astype(np.float32)) / norm_fix, sampling_rate)\n\n\ndef check_audio(audio, audiopath: str):\n    # Check some assumptions about audio range. This should be automatically fixed in load_wav_to_torch, but might not be in some edge cases, where we should squawk.\n    # '2' is arbitrarily chosen since it seems like audio will often \"overdrive\" the [-1,1] bounds.\n    if torch.any(audio > 2) or not torch.any(audio < 0):\n        print(f\"Error with {audiopath}. Max={audio.max()} min={audio.min()}\")\n    audio.clip_(-1, 1)\n\n\ndef read_audio_file(audiopath: str):\n    if audiopath[-4:] == \".wav\":\n        audio, lsr = load_wav_to_torch(audiopath)\n    elif audiopath[-4:] == \".mp3\":\n        audio, lsr = librosa.load(audiopath, sr=None)\n        audio = torch.FloatTensor(audio)\n    else:\n        assert False, f\"Unsupported audio format provided: {audiopath[-4:]}\"\n\n    # Remove any channel data.\n    if len(audio.shape) > 1:\n        if audio.shape[0] < 5:\n            audio = audio[0]\n        else:\n            assert audio.shape[1] < 5\n            audio = audio[:, 0]\n\n    return audio, lsr\n\n\ndef load_required_audio(audiopath: str):\n    audio, lsr = read_audio_file(audiopath)\n\n    audios = [torchaudio.functional.resample(audio, lsr, sampling_rate) for sampling_rate in (22050, 24000)]\n    for audio in audios:\n        check_audio(audio, audiopath)\n\n    return [audio.unsqueeze(0) for audio in audios]\n\n\ndef load_audio(audiopath, sampling_rate):\n    audio, lsr = read_audio_file(audiopath)\n\n    if lsr != sampling_rate:\n        audio = torchaudio.functional.resample(audio, lsr, sampling_rate)\n    check_audio(audio, audiopath)\n\n    return audio.unsqueeze(0)\n\n\nTACOTRON_MEL_MAX = 2.3143386840820312\nTACOTRON_MEL_MIN = -11.512925148010254\n\n\ndef denormalize_tacotron_mel(norm_mel):\n    return ((norm_mel + 1) / 2) * (TACOTRON_MEL_MAX - TACOTRON_MEL_MIN) + TACOTRON_MEL_MIN\n\n\ndef normalize_tacotron_mel(mel):\n    return 2 * ((mel - TACOTRON_MEL_MIN) / (TACOTRON_MEL_MAX - TACOTRON_MEL_MIN)) - 1\n\n\ndef dynamic_range_compression(x, C=1, clip_val=1e-5):\n    \"\"\"\n    PARAMS\n    ------\n    C: compression factor\n    \"\"\"\n    return torch.log(torch.clamp(x, min=clip_val) * C)\n\n\ndef dynamic_range_decompression(x, C=1):\n    \"\"\"\n    PARAMS\n    ------\n    C: compression factor used to compress\n    \"\"\"\n    return torch.exp(x) / C\n\n\ndef get_voices(extra_voice_dirs: List[str] = []):\n    dirs = extra_voice_dirs\n    voices: Dict[str, List[str]] = {}\n    for d in dirs:\n        subs = os.listdir(d)\n        for sub in subs:\n            subj = os.path.join(d, sub)\n            if os.path.isdir(subj):\n                voices[sub] = list(glob(f\"{subj}/*.wav\")) + list(glob(f\"{subj}/*.mp3\")) + list(glob(f\"{subj}/*.pth\"))\n    return voices\n\n\ndef load_voice(voice: str, extra_voice_dirs: List[str] = []):\n    if voice == \"random\":\n        return None, None\n\n    voices = get_voices(extra_voice_dirs)\n    paths = voices[voice]\n    if len(paths) == 1 and paths[0].endswith(\".pth\"):\n        return None, torch.load(paths[0])\n    else:\n        conds = []\n        for cond_path in paths:\n            c = load_required_audio(cond_path)\n            conds.append(c)\n        return conds, None\n\n\ndef load_voices(voices: List[str], extra_voice_dirs: List[str] = []):\n    latents = []\n    clips = []\n    for voice in voices:\n        if voice == \"random\":\n            if len(voices) > 1:\n                print(\"Cannot combine a random voice with a non-random voice. Just using a random voice.\")\n            return None, None\n        clip, latent = load_voice(voice, extra_voice_dirs)\n        if latent is None:\n            assert (\n                len(latents) == 0\n            ), \"Can only combine raw audio voices or latent voices, not both. Do it yourself if you want this.\"\n            clips.extend(clip)\n        elif clip is None:\n            assert (\n                len(clips) == 0\n            ), \"Can only combine raw audio voices or latent voices, not both. Do it yourself if you want this.\"\n            latents.append(latent)\n    if len(latents) == 0:\n        return clips, None\n    else:\n        latents_0 = torch.stack([l[0] for l in latents], dim=0).mean(dim=0)\n        latents_1 = torch.stack([l[1] for l in latents], dim=0).mean(dim=0)\n        latents = (latents_0, latents_1)\n        return None, latents\n\n\ndef wav_to_univnet_mel(wav, do_normalization=False, device=\"cuda\"):\n    stft = TorchSTFT(\n        n_fft=1024,\n        hop_length=256,\n        win_length=1024,\n        use_mel=True,\n        n_mels=100,\n        sample_rate=24000,\n        mel_fmin=0,\n        mel_fmax=12000,\n    )\n    stft = stft.to(device)\n    mel = stft(wav)\n    mel = dynamic_range_compression(mel)\n    if do_normalization:\n        mel = normalize_tacotron_mel(mel)\n    return mel\n", "file_name": "779518.py", "cwe": ["CWE-502: Deserialization of Untrusted Data"]}
{"source": "import re\nimport importlib\nimport inspect\n\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom typing import Optional, List, Tuple, Set, Dict\n\n\n_SPHINX_AUTOSUMMARY_HEADER = \".. autosummary::\"\n_SPHINX_AUTOCLASS_HEADER = \".. autoclass::\"\n# This is a special character used in autosummary to render only the api shortname, for\n# example ~module.api_name will render only api_name\n_SPHINX_AUTODOC_SHORTNAME = \"~\"\n\n\nclass AnnotationType(Enum):\n    PUBLIC_API = \"PublicAPI\"\n    DEVELOPER_API = \"DeveloperAPI\"\n    DEPRECATED = \"Deprecated\"\n    UNKNOWN = \"Unknown\"\n\n\nclass CodeType(Enum):\n    CLASS = \"Class\"\n    FUNCTION = \"Function\"\n\n\n@dataclass\nclass API:\n    name: str\n    annotation_type: AnnotationType\n    code_type: CodeType\n\n    @staticmethod\n    def from_autosummary(doc: str, current_module: Optional[str] = None) -> List[\"API\"]:\n        \"\"\"\n        Parse API from the following autosummary sphinx block.\n\n        .. autosummary::\n            :option_01\n            :option_02\n\n            api_01\n            api_02\n        \"\"\"\n        apis = []\n        lines = doc.splitlines()\n        if not lines:\n            return apis\n\n        if lines[0].strip() != _SPHINX_AUTOSUMMARY_HEADER:\n            return apis\n\n        for line in lines:\n            if line == _SPHINX_AUTOSUMMARY_HEADER:\n                continue\n            if line.strip().startswith(\":\"):\n                # option lines\n                continue\n            if line.strip().startswith(\"..\"):\n                # comment lines\n                continue\n            if not line.strip():\n                # empty lines\n                continue\n            if not re.match(r\"\\s\", line):\n                # end of autosummary, \\s means empty space, this line is checking if\n                # the line is not empty and not starting with empty space\n                break\n            attribute = line.strip().removeprefix(_SPHINX_AUTODOC_SHORTNAME)\n            api_name = f\"{current_module}.{attribute}\" if current_module else attribute\n            apis.append(\n                API(\n                    name=api_name,\n                    annotation_type=AnnotationType.PUBLIC_API,\n                    code_type=CodeType.FUNCTION,\n                )\n            )\n\n        return apis\n\n    @staticmethod\n    def from_autoclass(\n        doc: str, current_module: Optional[str] = None\n    ) -> Optional[\"API\"]:\n        \"\"\"\n        Parse API from the following autoclass sphinx block.\n\n        .. autoclass:: api_01\n        \"\"\"\n        doc = doc.strip()\n        if not doc.startswith(_SPHINX_AUTOCLASS_HEADER):\n            return None\n        cls = (\n            doc[len(_SPHINX_AUTOCLASS_HEADER) :]\n            .strip()\n            .removeprefix(_SPHINX_AUTODOC_SHORTNAME)\n        )\n        api_name = f\"{current_module}.{cls}\" if current_module else cls\n\n        return API(\n            name=api_name,\n            annotation_type=AnnotationType.PUBLIC_API,\n            code_type=CodeType.CLASS,\n        )\n\n    def get_canonical_name(self) -> str:\n        \"\"\"\n        Some APIs have aliases declared in __init__.py file (see ray/data/__init__.py\n        for example). This method converts the alias to full name. This is to make sure\n        out analysis can be performed on the same set of canonial names.\n        \"\"\"\n        tokens = self.name.split(\".\")\n\n        # convert the name into a python object, by converting the module token by token\n        attribute = importlib.import_module(tokens[0])\n        for token in tokens[1:]:\n            if not hasattr(attribute, token):\n                # return as it is if the name seems malformed\n                return self.name\n            attribute = getattr(attribute, token)\n\n        if inspect.isclass(attribute) or inspect.isfunction(attribute):\n            return f\"{attribute.__module__}.{attribute.__qualname__}\"\n        return self.name\n\n    def _is_private_name(self) -> bool:\n        \"\"\"\n        Check if this API has a private name. Private names are those that start with\n        underscores.\n        \"\"\"\n        name_has_underscore = self.name.split(\".\")[-1].startswith(\"_\")\n        is_internal = \"._internal.\" in self.name\n\n        return name_has_underscore or is_internal\n\n    def is_public(self) -> bool:\n        \"\"\"\n        Check if this API is public. Public APIs are those that are annotated as public\n        and not have private names.\n        \"\"\"\n        return (\n            self.annotation_type == AnnotationType.PUBLIC_API\n            and not self._is_private_name()\n        )\n\n    def is_deprecated(self) -> bool:\n        \"\"\"\n        Check if this API is deprecated. Deprecated APIs are those that are annotated as\n        deprecated.\n        \"\"\"\n        return self.annotation_type == AnnotationType.DEPRECATED\n\n    @staticmethod\n    def split_good_and_bad_apis(\n        api_in_codes: Dict[str, \"API\"], api_in_docs: Set[str], white_list_apis: Set[str]\n    ) -> Tuple[List[str]]:\n        \"\"\"\n        Given the APIs in the codebase and the documentation, split the APIs into good\n        and bad APIs. Good APIs are those that are public and documented, bad APIs are\n        those that are public but NOT documented.\n        \"\"\"\n        good_apis = []\n        bad_apis = []\n\n        for name, api in api_in_codes.items():\n            if not api.is_public():\n                continue\n\n            if name in white_list_apis:\n                continue\n\n            if name in api_in_docs:\n                good_apis.append(name)\n            else:\n                bad_apis.append(name)\n\n        return good_apis, bad_apis\n", "file_name": "210196.py", "cwe": ["CWE-706: Use of Incorrectly-Resolved Name or Reference"]}
{"source": "import os.path\nimport subprocess\nimport platform\n\nfrom PyQt5 import QtGui\nfrom PyQt5.QtCore import QSize, pyqtSignal, Qt, QThread\nfrom PyQt5.QtGui import QPainter, QFont, QColor, QPixmap, QPolygon, QFontMetrics\nfrom PyQt5.QtWidgets import QWidget, QLabel, QHBoxLayout, QSizePolicy, QVBoxLayout, QSpacerItem, \\\n    QScrollArea\n\nfrom app.components.scroll_bar import ScrollBar\n\n\nclass MessageType:\n    Text = 1\n    Image = 3\n\n\nclass TextMessage(QLabel):\n    heightSingal = pyqtSignal(int)\n\n    def __init__(self, text, is_send=False, parent=None):\n        if isinstance(text, bytes):\n            text = text.decode('utf-8')\n        super(TextMessage, self).__init__(text, parent)\n        font = QFont('\u5fae\u8f6f\u96c5\u9ed1', 12)\n        self.setFont(font)\n        self.setWordWrap(True)\n        self.setMaximumWidth(800)\n        # self.setMinimumWidth(100)\n        self.setMinimumHeight(45)\n        self.setTextInteractionFlags(Qt.TextSelectableByMouse)\n        self.setSizePolicy(QSizePolicy.Ignored, QSizePolicy.Ignored)\n        if is_send:\n            self.setAlignment(Qt.AlignCenter | Qt.AlignRight)\n            self.setStyleSheet(\n                '''\n                background-color:#b2e281;\n                border-radius:10px;\n                padding:10px;\n                '''\n            )\n        else:\n            self.setStyleSheet(\n                '''\n                background-color:white;\n                border-radius:10px;\n                padding:10px;\n                '''\n            )\n        font_metrics = QFontMetrics(font)\n        rect = font_metrics.boundingRect(text)\n        # rect = font_metrics\n        self.setMaximumWidth(rect.width() + 40)\n\n    def paintEvent(self, a0: QtGui.QPaintEvent) -> None:\n        super(TextMessage, self).paintEvent(a0)\n\n\nclass Triangle(QLabel):\n    def __init__(self, Type, is_send=False, position=(0, 0), parent=None):\n        \"\"\"\n\n        @param Type:\n        @param is_send:\n        @param position:(x,y)\n        @param parent:\n        \"\"\"\n        super().__init__(parent)\n        self.Type = Type\n        self.is_send = is_send\n        self.position = position\n\n    def paintEvent(self, a0: QtGui.QPaintEvent) -> None:\n\n        super(Triangle, self).paintEvent(a0)\n        if self.Type == MessageType.Text:\n            self.setFixedSize(6, 45)\n            painter = QPainter(self)\n            triangle = QPolygon()\n            x, y = self.position\n            if self.is_send:\n                painter.setPen(QColor('#b2e281'))\n                painter.setBrush(QColor('#b2e281'))\n                triangle.setPoints(0, 20+y, 0, 34+y, 6, 27+y)\n            else:\n                painter.setPen(QColor('white'))\n                painter.setBrush(QColor('white'))\n                triangle.setPoints(0, 27+y, 6, 20+y, 6, 34+y)\n            painter.drawPolygon(triangle)\n\n\nclass Notice(QLabel):\n    def __init__(self, text, type_=3, parent=None):\n        super().__init__(text, parent)\n        self.type_ = type_\n        self.setFont(QFont('\u5fae\u8f6f\u96c5\u9ed1', 10))\n        self.setWordWrap(True)\n        self.setTextInteractionFlags(Qt.TextSelectableByMouse)\n        self.setAlignment(Qt.AlignCenter)\n\n\nclass Avatar(QLabel):\n    def __init__(self, avatar, parent=None):\n        super().__init__(parent)\n        if isinstance(avatar, str):\n            self.setPixmap(QPixmap(avatar).scaled(45, 45))\n            self.image_path = avatar\n        elif isinstance(avatar, QPixmap):\n            self.setPixmap(avatar.scaled(45, 45))\n        self.setFixedSize(QSize(45, 45))\n\n\ndef open_image_viewer(file_path):\n    system_platform = platform.system()\n\n    if system_platform == \"Darwin\":  # macOS\n        subprocess.run([\"open\", file_path])\n    elif system_platform == \"Windows\":\n        subprocess.run([\"start\", \" \", file_path], shell=True)\n    elif system_platform == \"Linux\":\n        subprocess.run([\"xdg-open\", file_path])\n    else:\n        print(\"Unsupported platform\")\n\n\nclass OpenImageThread(QThread):\n    def __init__(self, image_path):\n        super().__init__()\n        self.image_path = image_path\n\n    def run(self) -> None:\n        if os.path.exists(self.image_path):\n            open_image_viewer(self.image_path)\n\n\nclass ImageMessage(QLabel):\n    def __init__(self, image, is_send, image_link='', max_width=480, max_height=240, parent=None):\n        \"\"\"\n        param:image \u56fe\u50cf\u8def\u5f84\u6216\u8005QPixmap\u5bf9\u8c61\n        param:image_link='' \u70b9\u51fb\u56fe\u50cf\u6253\u5f00\u7684\u6587\u4ef6\u8def\u5f84\n        \"\"\"\n        super().__init__(parent)\n        self.image = QLabel(self)\n        self.max_width = max_width\n        self.max_height = max_height\n        # self.setFixedSize(self.max_width,self.max_height)\n        self.setMaximumWidth(self.max_width)\n        self.setMaximumHeight(self.max_height)\n        self.setCursor(Qt.PointingHandCursor)\n        if isinstance(image, str):\n            pixmap = QPixmap(image)\n            self.image_path = image\n        elif isinstance(image, QPixmap):\n            pixmap = image\n        self.set_image(pixmap)\n        if image_link:\n            self.image_path = image_link\n        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n\n        if is_send:\n            self.setAlignment(Qt.AlignCenter | Qt.AlignRight)\n        # self.setScaledContents(True)\n\n    def set_image(self, pixmap):\n        # \u8ba1\u7b97\u8c03\u6574\u540e\u7684\u5927\u5c0f\n        adjusted_width = min(pixmap.width(), self.max_width)\n        adjusted_height = min(pixmap.height(), self.max_height)\n        self.setPixmap(pixmap.scaled(adjusted_width, adjusted_height, Qt.KeepAspectRatio))\n        # \u8c03\u6574QLabel\u7684\u5927\u5c0f\u4ee5\u9002\u5e94\u56fe\u7247\u7684\u5bbd\u9ad8\uff0c\u4f46\u4e0d\u8d85\u8fc7\u6700\u5927\u5bbd\u9ad8\n        # self.setFixedSize(adjusted_width, adjusted_height)\n\n    def mousePressEvent(self, event):\n        if event.buttons() == Qt.LeftButton:  # \u5de6\u952e\u6309\u4e0b\n            print('\u6253\u5f00\u56fe\u50cf', self.image_path)\n            self.open_image_thread = OpenImageThread(self.image_path)\n            self.open_image_thread.start()\n\n\nclass BubbleMessage(QWidget):\n    def __init__(self, str_content, avatar, Type, is_send=False, display_name=None, parent=None):\n        super().__init__(parent)\n        self.isSend = is_send\n        # self.set\n        self.setStyleSheet(\n            '''\n            border:none;\n            '''\n        )\n        layout = QHBoxLayout()\n        layout.setSpacing(0)\n        layout.setContentsMargins(0, 5, 5, 5)\n        # self.resize(QSize(200, 50))\n        self.avatar = Avatar(avatar)\n        triangle = Triangle(Type, is_send, (0, 0))\n        if Type == MessageType.Text:\n            self.message = TextMessage(str_content, is_send)\n            # self.message.setMaximumWidth(int(self.width() * 0.6))\n        elif Type == MessageType.Image:\n            self.message = ImageMessage(str_content, is_send)\n        else:\n            raise ValueError(\"\u672a\u77e5\u7684\u6d88\u606f\u7c7b\u578b\")\n        if display_name:\n            triangle = Triangle(Type, is_send, (0, 10))\n            label_name = QLabel(display_name, self)\n            label_name.setFont(QFont('\u5fae\u8f6f\u96c5\u9ed1', 10))\n            if is_send:\n                label_name.setAlignment(Qt.AlignRight)\n            vlayout = QVBoxLayout()\n            vlayout.setSpacing(0)\n            if is_send:\n                vlayout.addWidget(label_name, 0, Qt.AlignTop | Qt.AlignRight)\n                vlayout.addWidget(self.message, 0, Qt.AlignTop | Qt.AlignRight)\n            else:\n                vlayout.addWidget(label_name)\n                vlayout.addWidget(self.message)\n        self.spacerItem = QSpacerItem(45 + 6, 45, QSizePolicy.Expanding, QSizePolicy.Minimum)\n        if is_send:\n            layout.addItem(self.spacerItem)\n            if display_name:\n                layout.addLayout(vlayout, 1)\n            else:\n                layout.addWidget(self.message, 1)\n            layout.addWidget(triangle, 0, Qt.AlignTop | Qt.AlignLeft)\n            layout.addWidget(self.avatar, 0, Qt.AlignTop | Qt.AlignLeft)\n        else:\n            layout.addWidget(self.avatar, 0, Qt.AlignTop | Qt.AlignRight)\n            layout.addWidget(triangle, 0, Qt.AlignTop | Qt.AlignRight)\n            if display_name:\n                layout.addLayout(vlayout, 1)\n            else:\n                layout.addWidget(self.message, 1)\n            layout.addItem(self.spacerItem)\n        self.setLayout(layout)\n\n\nclass ScrollAreaContent(QWidget):\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.adjustSize()\n\n\nclass ScrollArea(QScrollArea):\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.setWidgetResizable(True)\n        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n        self.setStyleSheet(\n            '''\n            border:none;\n            '''\n        )\n\n\nclass ChatWidget(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.resize(500, 200)\n\n        layout = QVBoxLayout()\n        layout.setSpacing(0)\n        self.adjustSize()\n        # \u751f\u6210\u6eda\u52a8\u533a\u57df\n        self.scrollArea = ScrollArea(self)\n        scrollBar = ScrollBar()\n        self.scrollArea.setVerticalScrollBar(scrollBar)\n        # \u751f\u6210\u6eda\u52a8\u533a\u57df\u7684\u5185\u5bb9\u90e8\u7f72\u5c42\u90e8\u4ef6\n        self.scrollAreaWidgetContents = ScrollAreaContent(self.scrollArea)\n        self.scrollAreaWidgetContents.setMinimumSize(50, 100)\n        # \u8bbe\u7f6e\u6eda\u52a8\u533a\u57df\u7684\u5185\u5bb9\u90e8\u7f72\u90e8\u4ef6\u4e3a\u524d\u9762\u751f\u6210\u7684\u5185\u5bb9\u90e8\u7f72\u5c42\u90e8\u4ef6\n        self.scrollArea.setWidget(self.scrollAreaWidgetContents)\n        layout.addWidget(self.scrollArea)\n        self.layout0 = QVBoxLayout()\n        self.layout0.setSpacing(0)\n        self.scrollAreaWidgetContents.setLayout(self.layout0)\n        self.setLayout(layout)\n\n    def add_message_item(self, bubble_message, index=1):\n        if index:\n            self.layout0.addWidget(bubble_message)\n        else:\n            self.layout0.insertWidget(0, bubble_message)\n        # self.set_scroll_bar_last()\n\n    def set_scroll_bar_last(self):\n        self.scrollArea.verticalScrollBar().setValue(\n            self.scrollArea.verticalScrollBar().maximum()\n        )\n\n    def set_scroll_bar_value(self, val):\n        self.verticalScrollBar().setValue(val)\n\n    def verticalScrollBar(self):\n        return self.scrollArea.verticalScrollBar()\n\n    def update(self) -> None:\n        super().update()\n        self.scrollAreaWidgetContents.adjustSize()\n        self.scrollArea.update()\n        # self.scrollArea.repaint()\n        # self.verticalScrollBar().setMaximum(self.scrollAreaWidgetContents.height())\n", "file_name": "494330.py", "cwe": ["CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"]}
{"source": "# -*- coding: utf-8 -*-\n\"\"\"\nemoji.py\n\n!!!\u58f0\u660e\uff1a\n\u7531\u4e8e\u8868\u60c5\u5305\u5e76\u4e0d\u5c5e\u4e8e\u4e2a\u4eba\uff0c\u5e76\u4e14\u5176\u53ef\u80fd\u5177\u6709\u7248\u6743\u98ce\u9669\uff0c\u4f60\u53ea\u6709\u6d4f\u89c8\u6743\u6ca1\u6709\u62e5\u6709\u6743\n\u53e6\u5916\u8bbf\u95ee\u817e\u8bafAPI\u53ef\u80fd\u4f1a\u7ed9\u817e\u8baf\u670d\u52a1\u5668\u9020\u6210\u538b\u529b\n\u6240\u4ee5\u7981\u6b62\u4efb\u4f55\u4eba\u4ee5\u4efb\u4f55\u65b9\u5f0f\u4fee\u6539\u6216\u95f4\u63a5\u4fee\u6539\u8be5\u6587\u4ef6\uff0c\u8fdd\u8005\u540e\u679c\u81ea\u8d1f\n\"\"\"\n\nimport os\nimport re\nimport traceback\nimport xml.etree.ElementTree as ET\nimport sqlite3\nimport threading\nfrom PyQt5.QtGui import QPixmap\nimport requests\n\nfrom app.log import log, logger\n\nlock = threading.Lock()\ndb_path = \"./app/Database/Msg/Emotion.db\"\nroot_path = \"./data/emoji/\"\nif not os.path.exists(\"./data\"):\n    os.mkdir(\"./data\")\nif not os.path.exists(root_path):\n    os.mkdir(root_path)\n\n\n@log\ndef get_image_format(header):\n    # \u5b9a\u4e49\u56fe\u7247\u683c\u5f0f\u7684 magic numbers\n    image_formats = {\n        b\"\\xFF\\xD8\\xFF\": \"jpeg\",\n        b\"\\x89\\x50\\x4E\\x47\\x0D\\x0A\\x1A\\x0A\": \"png\",\n        b\"\\x47\\x49\\x46\": \"gif\",\n        b\"\\x42\\x4D\": \"bmp\",\n        # \u6dfb\u52a0\u5176\u4ed6\u56fe\u7247\u683c\u5f0f\u7684 magic numbers\n    }\n    # \u5224\u65ad\u6587\u4ef6\u7684\u56fe\u7247\u683c\u5f0f\n    for magic_number, image_format in image_formats.items():\n        if header.startswith(magic_number):\n            return image_format\n    # \u5982\u679c\u65e0\u6cd5\u8bc6\u522b\u683c\u5f0f\uff0c\u8fd4\u56de None\n    return None\n\n\n@log\ndef parser_xml(xml_string):\n    assert type(xml_string) == str\n    # Parse the XML string\n    try:\n        root = ET.fromstring(xml_string)\n    except:\n        res = re.search('<msg>.*</msg>', xml_string)\n        if res:\n            xml_string = res.group()\n        root = ET.fromstring(xml_string.replace(\"&\", \"&amp;\"))\n    emoji = root.find(\"./emoji\")\n    # Accessing attributes of the 'emoji' element\n    fromusername = emoji.get(\"fromusername\")\n    tousername = emoji.get(\"tousername\")\n    md5 = emoji.get(\"md5\")\n    cdnurl = emoji.get(\"cdnurl\")\n    encrypturl = emoji.get(\"encrypturl\")\n    thumburl = emoji.get(\"thumburl\")\n    externurl = emoji.get(\"externurl\")\n    androidmd5 = emoji.get(\"androidmd5\")\n    width = emoji.get(\"width\")\n    height = emoji.get(\"height\")\n    return {\n        \"width\": width,\n        \"height\": height,\n        \"cdnurl\": cdnurl,\n        \"thumburl\": thumburl if thumburl else cdnurl,\n        \"md5\": (md5 if md5 else androidmd5).lower(),\n    }\n\n\ndef singleton(cls):\n    _instance = {}\n\n    def inner():\n        if cls not in _instance:\n            _instance[cls] = cls()\n        return _instance[cls]\n\n    return inner\n\n\n# \u4e00\u5b9a\u8981\u4fdd\u8bc1\u53ea\u6709\u4e00\u4e2a\u5b9e\u4f8b\u5bf9\u8c61\n@singleton\nclass Emotion:\n    def __init__(self):\n        self.DB = None\n        self.cursor: sqlite3.Cursor = None\n        self.open_flag = False\n        self.init_database()\n\n    def init_database(self):\n        if not self.open_flag:\n            if os.path.exists(db_path):\n                self.DB = sqlite3.connect(db_path, check_same_thread=False)\n                # '''\u521b\u5efa\u6e38\u6807'''\n                self.cursor = self.DB.cursor()\n                self.open_flag = True\n                if lock.locked():\n                    lock.release()\n\n    def get_emoji_url(self, md5: str, thumb: bool) -> str | bytes:\n        \"\"\"\u4f9b\u4e0b\u8f7d\u7528\uff0c\u8fd4\u56de\u53ef\u80fd\u662furl\u53ef\u80fd\u662fbytes\"\"\"\n        if thumb:\n            sql = \"\"\"\n                select\n                    case\n                        when thumburl is NULL or thumburl = '' then cdnurl\n                        else thumburl\n                    end as selected_url\n                from CustomEmotion\n                where md5 = ?\n            \"\"\"\n        else:\n            sql = \"\"\"\n                select CDNUrl\n                from CustomEmotion\n                where md5 = ?\n            \"\"\"\n        try:\n            lock.acquire(True)\n            self.cursor.execute(sql, [md5])\n            return self.cursor.fetchone()[0]\n        except:\n            md5 = md5.upper()\n            sql = f\"\"\"\n                select {\"Thumb\" if thumb else \"Data\"}\n                from EmotionItem\n                where md5 = ?\n            \"\"\"\n            self.cursor.execute(sql, [md5])\n            res = self.cursor.fetchone()\n            return res[0] if res else \"\"\n        finally:\n            lock.release()\n\n    def get_emoji_URL(self, md5: str, thumb: bool):\n        \"\"\"\u53ea\u7ba1url\uff0c\u53e6\u5916\u7684\u4e0d\u7ba1\"\"\"\n        if thumb:\n            sql = \"\"\"\n                select\n                    case\n                        when thumburl is NULL or thumburl = '' then cdnurl\n                        else thumburl\n                    end as selected_url\n                from CustomEmotion\n                where md5 = ?\n            \"\"\"\n        else:\n            sql = \"\"\"\n                select CDNUrl\n                from CustomEmotion\n                where md5 = ?\n            \"\"\"\n        try:\n            lock.acquire(True)\n            self.cursor.execute(sql, [md5])\n            return self.cursor.fetchone()[0]\n        except:\n            return \"\"\n        finally:\n            lock.release()\n\n    def close(self):\n        if self.open_flag:\n            try:\n                lock.acquire(True)\n                self.open_flag = False\n                self.DB.close()\n            finally:\n                lock.release()\n\n    def __del__(self):\n        self.close()\n\n\n@log\ndef download(url, output_dir, name, thumb=False):\n    resp = requests.get(url)\n    byte = resp.content\n    image_format = get_image_format(byte[:8])\n    if image_format:\n        if thumb:\n            output_path = os.path.join(output_dir, \"th_\" + name + \".\" + image_format)\n        else:\n            output_path = os.path.join(output_dir, name + \".\" + image_format)\n    else:\n        output_path = os.path.join(output_dir, name)\n    with open(output_path, \"wb\") as f:\n        f.write(resp.content)\n    return output_path\n\n\ndef get_most_emoji(messages):\n    dic = {}\n    for msg in messages:\n        str_content = msg[7]\n        emoji_info = parser_xml(str_content)\n        if emoji_info is None:\n            continue\n        md5 = emoji_info[\"md5\"]\n        if not md5:\n            continue\n        try:\n            dic[md5][0] += 1\n        except:\n            dic[md5] = [1, emoji_info]\n    md5_nums = [(num[0], key, num[1]) for key, num in dic.items()]\n    md5_nums.sort(key=lambda x: x[0], reverse=True)\n    if not md5_nums:\n        return \"\", 0\n    md5 = md5_nums[0][1]\n    num = md5_nums[0][0]\n    emoji_info = md5_nums[0][2]\n    url = emoji_info[\"cdnurl\"]\n    if not url or url == \"\":\n        url = Emotion().get_emoji_url(md5, False)\n    return url, num\n\n\ndef get_emoji(xml_string, thumb=True, output_path=root_path) -> str:\n    \"\"\"\u4f9b\u4e0b\u8f7d\u7528\"\"\"\n    try:\n        emoji_info = parser_xml(xml_string)\n        md5 = emoji_info[\"md5\"]\n        image_format = [\".png\", \".gif\", \".jpeg\"]\n        for f in image_format:\n            prefix = \"th_\" if thumb else \"\"\n            file_path = os.path.join(output_path, prefix + md5 + f)\n            if os.path.exists(file_path):\n                return file_path\n        url = emoji_info[\"thumburl\"] if thumb else emoji_info[\"cdnurl\"]\n        if not url or url == \"\":\n            url = Emotion().get_emoji_url(md5, thumb)\n        if type(url) == str and url != \"\":\n            print(\"\u4e0b\u8f7d\u8868\u60c5\u5305ing:\", url)\n            emoji_path = download(url, output_path, md5, thumb)\n            return emoji_path\n        elif type(url) == bytes:\n            image_format = get_image_format(url[:8])\n            if image_format:\n                if thumb:\n                    output_path = os.path.join(\n                        output_path, \"th_\" + md5 + \".\" + image_format\n                    )\n                else:\n                    output_path = os.path.join(output_path, md5 + \".\" + image_format)\n            else:\n                output_path = os.path.join(output_path, md5)\n            with open(output_path, \"wb\") as f:\n                f.write(url)\n            print(\"\u8868\u60c5\u5305\u6570\u636e\u5e93\u52a0\u8f7d\", output_path)\n            return output_path\n        else:\n            print(\"\uff01\uff01\uff01\u672a\u77e5\u8868\u60c5\u5305\u6570\u636e\uff0c\u4fe1\u606f\uff1a\", xml_string, emoji_info, url)\n            output_path = os.path.join(output_path, \"404.png\")\n            if not os.path.exists(output_path):\n                QPixmap(\":/icons/icons/404.png\").save(output_path)\n            return output_path\n    except:\n        logger.error(traceback.format_exc())\n        output_path = os.path.join(output_path, \"404.png\")\n        if not os.path.exists(output_path):\n            QPixmap(\":/icons/icons/404.png\").save(output_path)\n        return output_path\n\n\ndef get_emoji_path(xml_string, thumb=True, output_path=root_path) -> str:\n    try:\n        emoji_info = parser_xml(xml_string)\n        md5 = emoji_info[\"md5\"]\n        image_format = [\".png\", \".gif\", \".jpeg\"]\n        for f in image_format:\n            prefix = \"th_\" if thumb else \"\"\n            file_path = os.path.join(output_path, prefix + md5 + f)\n            return file_path\n    except:\n        logger.error(traceback.format_exc())\n        output_path = os.path.join(output_path, \"404.png\")\n        return output_path\n\n\ndef get_emoji_url(xml_string, thumb=True) -> str:\n    \"\"\"\u4e0d\u7ba1\u4e0b\u8f7d\uff0c\u53ea\u8fd4\u56deurl\"\"\"\n    try:\n        emoji_info = parser_xml(xml_string)\n        md5 = emoji_info[\"md5\"]\n        url = emoji_info[\"thumburl\" if thumb else \"cdnurl\"]\n        if not url or url == \"\":\n            url = Emotion().get_emoji_URL(md5=md5, thumb=thumb)\n        return url\n    except:\n        logger.error(traceback.format_exc())\n        output_path = os.path.join(\"./emoji/404.png\")\n        return output_path\n\n\nif __name__ == \"__main__\":\n    # xml_string = '<msg><emoji fromusername = \"wxid_0o18ef858vnu22\" tousername = \"wxid_27hqbq7vx5hf22\" type=\"2\" idbuffer=\"media:0_0\" md5=\"71ce49ed3ce9e57e43e07f802983bf45\" len = \"352588\" productid=\"com.tencent.xin.emoticon.person.stiker_1678703862259eb01f2ef4a313\" androidmd5=\"71ce49ed3ce9e57e43e07f802983bf45\" androidlen=\"352588\" s60v3md5 = \"71ce49ed3ce9e57e43e07f802983bf45\" s60v3len=\"352588\" s60v5md5 = \"71ce49ed3ce9e57e43e07f802983bf45\" s60v5len=\"352588\" cdnurl = \"http://wxapp.tc.qq.com/262/20304/stodownload?m=71ce49ed3ce9e57e43e07f802983bf45&amp;filekey=30350201010421301f020201060402535a041071ce49ed3ce9e57e43e07f802983bf45020305614c040d00000004627466730000000132&amp;hy=SZ&amp;storeid=263ffa00b000720d03274c5820000010600004f50535a1ca0c950b64287022&amp;bizid=1023\" designerid = \"\" thumburl = \"http://mmbiz.qpic.cn/mmemoticon/ajNVdqHZLLDSKTMRgM8agiadpFhKz9IJ3cD5Ra2sTROibOaShdt3D4z6PfE92WkjQY/0\" encrypturl = \"http://wxapp.tc.qq.com/262/20304/stodownload?m=cbaae1d847aac6389652b65562bacaa2&amp;filekey=30350201010421301f020201060402535a0410cbaae1d847aac6389652b65562bacaa20203056150040d00000004627466730000000132&amp;hy=SZ&amp;storeid=263ffa00b0008d8223274c5820000010600004f50535a17b82910b64764739&amp;bizid=1023\" aeskey= \"7051ab2a34442dec63434832463f45ce\" externurl = \"http://wxapp.tc.qq.com/262/20304/stodownload?m=960f68693454dfa64b9966ca5d70dbd3&amp;filekey=30340201010420301e020201060402535a0410960f68693454dfa64b9966ca5d70dbd3020221a0040d00000004627466730000000132&amp;hy=SZ&amp;storeid=26423dbe3000793a8720e40de0000010600004f50535a1d40c950b71be0a50&amp;bizid=1023\" externmd5 = \"41895664fc5a77878e2155fc96209a19\" width= \"240\" height= \"240\" tpurl= \"\" tpauthkey= \"\" attachedtext= \"\" attachedtextcolor= \"\" lensid= \"\" emojiattr= \"\" linkid= \"\" desc= \"ChEKB2RlZmF1bHQSBuWNlee6rw==\" ></emoji> </msg>'\n    # res1 = parser_xml(xml_string)\n    # print(res1, res1['md5'])\n    # download(res1['cdnurl'], \"./data/emoji/\", res1['md5'])\n    # download(res1['thumburl'], \"./data/emoji/\", res1['md5'], True)\n    # print(Emotion().get_emoji_url(\"144714f65c98844128ac3a1042445d9a\", True))\n    # print(Emotion().get_emoji_url(\"144714f65c98844128ac3a1042445d9a\", False))\n    print(parser_xml(\"\"))\n    # print(get_emoji(xml_string, True))\n    # print(get_emoji(xml_string, False))\n#     http://vweixinf.tc.qq.com/110/20403/stodownload?m=3a4d439aba02dce4834b2c54e9f15597&filekey=3043020101042f302d02016e0402534804203361346434333961626130326463653438333462326335346539663135353937020213f0040d00000004627466730000000131&hy=SH&storeid=323032313037323030373236313130303039653236646365316535316534383236386234306230303030303036653033303034666233&ef=3&bizid=1022\n", "file_name": "095146.py", "cwe": ["CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"]}
{"source": "#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2024 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nimport glob\nimport os\nimport re\nimport shutil\nimport subprocess\nimport time\nimport zipfile\n\nfrom lib.core.common import dataToStdout\nfrom lib.core.common import extractRegexResult\nfrom lib.core.common import getLatestRevision\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import openFile\nfrom lib.core.common import pollProcess\nfrom lib.core.common import readInput\nfrom lib.core.convert import getText\nfrom lib.core.data import conf\nfrom lib.core.data import logger\nfrom lib.core.data import paths\nfrom lib.core.revision import getRevisionNumber\nfrom lib.core.settings import GIT_REPOSITORY\nfrom lib.core.settings import IS_WIN\nfrom lib.core.settings import VERSION\nfrom lib.core.settings import TYPE\nfrom lib.core.settings import ZIPBALL_PAGE\nfrom thirdparty.six.moves import urllib as _urllib\n\ndef update():\n    if not conf.updateAll:\n        return\n\n    success = False\n\n    if TYPE == \"pip\":\n        infoMsg = \"updating sqlmap to the latest stable version from the \"\n        infoMsg += \"PyPI repository\"\n        logger.info(infoMsg)\n\n        debugMsg = \"sqlmap will try to update itself using 'pip' command\"\n        logger.debug(debugMsg)\n\n        dataToStdout(\"\\r[%s] [INFO] update in progress\" % time.strftime(\"%X\"))\n\n        output = \"\"\n        try:\n            process = subprocess.Popen(\"pip install -U sqlmap\", shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=paths.SQLMAP_ROOT_PATH)\n            pollProcess(process, True)\n            output, _ = process.communicate()\n            success = not process.returncode\n        except Exception as ex:\n            success = False\n            output = getSafeExString(ex)\n        finally:\n            output = getText(output)\n\n        if success:\n            logger.info(\"%s the latest revision '%s'\" % (\"already at\" if \"already up-to-date\" in output else \"updated to\", extractRegexResult(r\"\\binstalled sqlmap-(?P<result>\\d+\\.\\d+\\.\\d+)\", output) or extractRegexResult(r\"\\((?P<result>\\d+\\.\\d+\\.\\d+)\\)\", output)))\n        else:\n            logger.error(\"update could not be completed ('%s')\" % re.sub(r\"[^a-z0-9:/\\\\]+\", \" \", output).strip())\n\n    elif not os.path.exists(os.path.join(paths.SQLMAP_ROOT_PATH, \".git\")):\n        warnMsg = \"not a git repository. It is recommended to clone the 'sqlmapproject/sqlmap' repository \"\n        warnMsg += \"from GitHub (e.g. 'git clone --depth 1 %s sqlmap')\" % GIT_REPOSITORY\n        logger.warning(warnMsg)\n\n        if VERSION == getLatestRevision():\n            logger.info(\"already at the latest revision '%s'\" % (getRevisionNumber() or VERSION))\n            return\n\n        message = \"do you want to try to fetch the latest 'zipball' from repository and extract it (experimental) ? [y/N]\"\n        if readInput(message, default='N', boolean=True):\n            directory = os.path.abspath(paths.SQLMAP_ROOT_PATH)\n\n            try:\n                open(os.path.join(directory, \"sqlmap.py\"), \"w+b\")\n            except Exception as ex:\n                errMsg = \"unable to update content of directory '%s' ('%s')\" % (directory, getSafeExString(ex))\n                logger.error(errMsg)\n            else:\n                attrs = os.stat(os.path.join(directory, \"sqlmap.py\")).st_mode\n                for wildcard in ('*', \".*\"):\n                    for _ in glob.glob(os.path.join(directory, wildcard)):\n                        try:\n                            if os.path.isdir(_):\n                                shutil.rmtree(_)\n                            else:\n                                os.remove(_)\n                        except:\n                            pass\n\n                if glob.glob(os.path.join(directory, '*')):\n                    errMsg = \"unable to clear the content of directory '%s'\" % directory\n                    logger.error(errMsg)\n                else:\n                    try:\n                        archive = _urllib.request.urlretrieve(ZIPBALL_PAGE)[0]\n\n                        with zipfile.ZipFile(archive) as f:\n                            for info in f.infolist():\n                                info.filename = re.sub(r\"\\Asqlmap[^/]+\", \"\", info.filename)\n                                if info.filename:\n                                    f.extract(info, directory)\n\n                        filepath = os.path.join(paths.SQLMAP_ROOT_PATH, \"lib\", \"core\", \"settings.py\")\n                        if os.path.isfile(filepath):\n                            with openFile(filepath, \"rb\") as f:\n                                version = re.search(r\"(?m)^VERSION\\s*=\\s*['\\\"]([^'\\\"]+)\", f.read()).group(1)\n                                logger.info(\"updated to the latest version '%s#dev'\" % version)\n                                success = True\n                    except Exception as ex:\n                        logger.error(\"update could not be completed ('%s')\" % getSafeExString(ex))\n                    else:\n                        if not success:\n                            logger.error(\"update could not be completed\")\n                        else:\n                            try:\n                                os.chmod(os.path.join(directory, \"sqlmap.py\"), attrs)\n                            except OSError:\n                                logger.warning(\"could not set the file attributes of '%s'\" % os.path.join(directory, \"sqlmap.py\"))\n\n    else:\n        infoMsg = \"updating sqlmap to the latest development revision from the \"\n        infoMsg += \"GitHub repository\"\n        logger.info(infoMsg)\n\n        debugMsg = \"sqlmap will try to update itself using 'git' command\"\n        logger.debug(debugMsg)\n\n        dataToStdout(\"\\r[%s] [INFO] update in progress\" % time.strftime(\"%X\"))\n\n        output = \"\"\n        try:\n            process = subprocess.Popen(\"git checkout . && git pull %s HEAD\" % GIT_REPOSITORY, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=paths.SQLMAP_ROOT_PATH)\n            pollProcess(process, True)\n            output, _ = process.communicate()\n            success = not process.returncode\n        except Exception as ex:\n            success = False\n            output = getSafeExString(ex)\n        finally:\n            output = getText(output)\n\n        if success:\n            logger.info(\"%s the latest revision '%s'\" % (\"already at\" if \"Already\" in output else \"updated to\", getRevisionNumber()))\n        else:\n            if \"Not a git repository\" in output:\n                errMsg = \"not a valid git repository. Please checkout the 'sqlmapproject/sqlmap' repository \"\n                errMsg += \"from GitHub (e.g. 'git clone --depth 1 %s sqlmap')\" % GIT_REPOSITORY\n                logger.error(errMsg)\n            else:\n                logger.error(\"update could not be completed ('%s')\" % re.sub(r\"\\W+\", \" \", output).strip())\n\n    if not success:\n        if IS_WIN:\n            infoMsg = \"for Windows platform it's recommended \"\n            infoMsg += \"to use a GitHub for Windows client for updating \"\n            infoMsg += \"purposes (https://desktop.github.com/) or just \"\n            infoMsg += \"download the latest snapshot from \"\n            infoMsg += \"https://github.com/sqlmapproject/sqlmap/downloads\"\n        else:\n            infoMsg = \"for Linux platform it's recommended \"\n            infoMsg += \"to install a standard 'git' package (e.g.: 'apt install git')\"\n\n        logger.info(infoMsg)\n", "file_name": "782536.py", "cwe": ["CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"]}
